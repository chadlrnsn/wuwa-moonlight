#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroData

#include "Basic.hpp"

#include "KuroData_classes.hpp"
#include "KuroData_parameters.hpp"


namespace SDK
{

// Function KuroData.KuroHitResult.Clear
// (Final, Native, Public, BlueprintCallable)

void UKuroHitResult::Clear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroHitResult", "Clear");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroData.KuroHitResult.GetHitCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroHitResult::GetHitCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroHitResult", "GetHitCount");

	Params::KuroHitResult_GetHitCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroData.KuroTraceLibrary.BoxTrace
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UTraceBoxElement*                 Element                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ProfileKey                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroTraceLibrary::BoxTrace(class UTraceBoxElement* Element, const class FString& ProfileKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroTraceLibrary", "BoxTrace");

	Params::KuroTraceLibrary_BoxTrace Parms{};

	Parms.Element = Element;
	Parms.ProfileKey = std::move(ProfileKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroData.KuroTraceLibrary.CapsuleTrace
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UTraceCapsuleElement*             Element                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ProfileKey                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroTraceLibrary::CapsuleTrace(class UTraceCapsuleElement* Element, const class FString& ProfileKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroTraceLibrary", "CapsuleTrace");

	Params::KuroTraceLibrary_CapsuleTrace Parms{};

	Parms.Element = Element;
	Parms.ProfileKey = std::move(ProfileKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroData.KuroTraceLibrary.LineTrace
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UTraceLineElement*                Element                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ProfileKey                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroTraceLibrary::LineTrace(class UTraceLineElement* Element, const class FString& ProfileKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroTraceLibrary", "LineTrace");

	Params::KuroTraceLibrary_LineTrace Parms{};

	Parms.Element = Element;
	Parms.ProfileKey = std::move(ProfileKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroData.KuroTraceLibrary.ShapeTrace
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UShapeComponent*                  InShapeComp                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTraceBaseElement*                Element                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TraceTagName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ProfileKey                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroTraceLibrary::ShapeTrace(class UShapeComponent* InShapeComp, class UTraceBaseElement* Element, const class FName& TraceTagName, const class FString& ProfileKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroTraceLibrary", "ShapeTrace");

	Params::KuroTraceLibrary_ShapeTrace Parms{};

	Parms.InShapeComp = InShapeComp;
	Parms.Element = Element;
	Parms.TraceTagName = TraceTagName;
	Parms.ProfileKey = std::move(ProfileKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroData.KuroTraceLibrary.SphereTrace
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UTraceSphereElement*              Element                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ProfileKey                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroTraceLibrary::SphereTrace(class UTraceSphereElement* Element, const class FString& ProfileKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroTraceLibrary", "SphereTrace");

	Params::KuroTraceLibrary_SphereTrace Parms{};

	Parms.Element = Element;
	Parms.ProfileKey = std::move(ProfileKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroData.TraceBaseElement.AddObjectTypeQuery
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EObjectTypeQuery                        ObjectType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTraceBaseElement::AddObjectTypeQuery(EObjectTypeQuery ObjectType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TraceBaseElement", "AddObjectTypeQuery");

	Params::TraceBaseElement_AddObjectTypeQuery Parms{};

	Parms.ObjectType = ObjectType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroData.TraceBaseElement.ClearCacheData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bClearWorld                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTraceBaseElement::ClearCacheData(bool bClearWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TraceBaseElement", "ClearCacheData");

	Params::TraceBaseElement_ClearCacheData Parms{};

	Parms.bClearWorld = bClearWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroData.TraceBaseElement.Dispose
// (Final, Native, Public, BlueprintCallable)

void UTraceBaseElement::Dispose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TraceBaseElement", "Dispose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroData.TraceBaseElement.SetDrawDebugTrace
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDrawDebugTrace                         Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTraceBaseElement::SetDrawDebugTrace(EDrawDebugTrace Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TraceBaseElement", "SetDrawDebugTrace");

	Params::TraceBaseElement_SetDrawDebugTrace Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroData.TraceBaseElement.SetEndLocation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTraceBaseElement::SetEndLocation(float X, float Y, float Z)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TraceBaseElement", "SetEndLocation");

	Params::TraceBaseElement_SetEndLocation Parms{};

	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroData.TraceBaseElement.SetObjectTypesQuery
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<EObjectTypeQuery>                ObjectTypes                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UTraceBaseElement::SetObjectTypesQuery(TArray<EObjectTypeQuery>* ObjectTypes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TraceBaseElement", "SetObjectTypesQuery");

	Params::TraceBaseElement_SetObjectTypesQuery Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ObjectTypes != nullptr)
		*ObjectTypes = std::move(Parms.ObjectTypes);
}


// Function KuroData.TraceBaseElement.SetStartLocation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTraceBaseElement::SetStartLocation(float X, float Y, float Z)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TraceBaseElement", "SetStartLocation");

	Params::TraceBaseElement_SetStartLocation Parms{};

	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroData.TraceBaseElement.SetTraceColor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   R                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   G                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTraceBaseElement::SetTraceColor(float R, float G, float B, float A)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TraceBaseElement", "SetTraceColor");

	Params::TraceBaseElement_SetTraceColor Parms{};

	Parms.R = R;
	Parms.G = G;
	Parms.B = B;
	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroData.TraceBaseElement.SetTraceHitColor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   R                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   G                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTraceBaseElement::SetTraceHitColor(float R, float G, float B, float A)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TraceBaseElement", "SetTraceHitColor");

	Params::TraceBaseElement_SetTraceHitColor Parms{};

	Parms.R = R;
	Parms.G = G;
	Parms.B = B;
	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroData.TraceBaseElement.SetTraceTypeQuery
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETraceTypeQuery                         Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTraceBaseElement::SetTraceTypeQuery(ETraceTypeQuery Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TraceBaseElement", "SetTraceTypeQuery");

	Params::TraceBaseElement_SetTraceTypeQuery Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroData.TraceBoxElement.SetBoxHalfSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTraceBoxElement::SetBoxHalfSize(float X, float Y, float Z)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TraceBoxElement", "SetBoxHalfSize");

	Params::TraceBoxElement_SetBoxHalfSize Parms{};

	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroData.TraceBoxElement.SetBoxOrientation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Pitch                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Yaw                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Roll                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTraceBoxElement::SetBoxOrientation(float Pitch, float Yaw, float Roll)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TraceBoxElement", "SetBoxOrientation");

	Params::TraceBoxElement_SetBoxOrientation Parms{};

	Parms.Pitch = Pitch;
	Parms.Yaw = Yaw;
	Parms.Roll = Roll;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

