#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroRenderingRuntimeBPPlugin

#include "Basic.hpp"

#include "KuroCurve_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "DeveloperSettings_classes.hpp"
#include "KuroRenderingRuntimeBPPlugin_structs.hpp"
#include "KuroPointCloud_structs.hpp"
#include "ProceduralMeshComponent_classes.hpp"
#include "Renderer_structs.hpp"
#include "LevelSequence_classes.hpp"
#include "Niagara_classes.hpp"


namespace SDK
{

// Class KuroRenderingRuntimeBPPlugin.KuroEffectActor
// 0x0008 (0x02B0 - 0x02A8)
class AKuroEffectActor : public AActor
{
public:
	bool                                          bEditorTickBySelected;                             // 0x02A8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetActorComponentTickEnabledByFocus;              // 0x02A9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18BF[0x6];                                     // 0x02AA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoHiddenInGame(bool bValue);
	void EditorFocusIn();
	void EditorFocusOut();
	void EditorInit();
	void EditorTick(float DeltaSeconds);

	void EditorSetActorComponentsTickEnabled(bool bValue) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroEffectActor">();
	}
	static class AKuroEffectActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroEffectActor>();
	}
};
static_assert(alignof(AKuroEffectActor) == 0x000008, "Wrong alignment on AKuroEffectActor");
static_assert(sizeof(AKuroEffectActor) == 0x0002B0, "Wrong size on AKuroEffectActor");
static_assert(offsetof(AKuroEffectActor, bEditorTickBySelected) == 0x0002A8, "Member 'AKuroEffectActor::bEditorTickBySelected' has a wrong offset!");
static_assert(offsetof(AKuroEffectActor, bSetActorComponentTickEnabledByFocus) == 0x0002A9, "Member 'AKuroEffectActor::bSetActorComponentTickEnabledByFocus' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroSceneRainActor
// 0x01C0 (0x0470 - 0x02B0)
class alignas(0x10) AKuroSceneRainActor final : public AKuroEffectActor
{
public:
	class UKuroSceneRainEmitterConfig*            RainConfig_Front;                                  // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKuroSceneRainEmitterConfig*            RainConfig_Back;                                   // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKuroRainComponent*                     RainComponent_Front;                               // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UKuroRainComponent*                     RainComponent_Back;                                // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_18C0[0x1A0];                                   // 0x02D0(0x01A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCurrentRain(float InDensity, float InGravity, const struct FVector& InWindSpeed);
	void StartRain();
	void StopRain();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroSceneRainActor">();
	}
	static class AKuroSceneRainActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroSceneRainActor>();
	}
};
static_assert(alignof(AKuroSceneRainActor) == 0x000010, "Wrong alignment on AKuroSceneRainActor");
static_assert(sizeof(AKuroSceneRainActor) == 0x000470, "Wrong size on AKuroSceneRainActor");
static_assert(offsetof(AKuroSceneRainActor, RainConfig_Front) == 0x0002B0, "Member 'AKuroSceneRainActor::RainConfig_Front' has a wrong offset!");
static_assert(offsetof(AKuroSceneRainActor, RainConfig_Back) == 0x0002B8, "Member 'AKuroSceneRainActor::RainConfig_Back' has a wrong offset!");
static_assert(offsetof(AKuroSceneRainActor, RainComponent_Front) == 0x0002C0, "Member 'AKuroSceneRainActor::RainComponent_Front' has a wrong offset!");
static_assert(offsetof(AKuroSceneRainActor, RainComponent_Back) == 0x0002C8, "Member 'AKuroSceneRainActor::RainComponent_Back' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroChangeMaterialsTextures
// 0x0030 (0x0068 - 0x0038)
class UKuroChangeMaterialsTextures final : public UPrimaryDataAsset
{
public:
	class FString                                 SkeletalMeshName;                                  // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0048(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C1[0x4];                                     // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UTexture2D>>      Textures;                                          // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroChangeMaterialsTextures">();
	}
	static class UKuroChangeMaterialsTextures* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroChangeMaterialsTextures>();
	}
};
static_assert(alignof(UKuroChangeMaterialsTextures) == 0x000008, "Wrong alignment on UKuroChangeMaterialsTextures");
static_assert(sizeof(UKuroChangeMaterialsTextures) == 0x000068, "Wrong size on UKuroChangeMaterialsTextures");
static_assert(offsetof(UKuroChangeMaterialsTextures, SkeletalMeshName) == 0x000038, "Member 'UKuroChangeMaterialsTextures::SkeletalMeshName' has a wrong offset!");
static_assert(offsetof(UKuroChangeMaterialsTextures, ParameterName) == 0x000048, "Member 'UKuroChangeMaterialsTextures::ParameterName' has a wrong offset!");
static_assert(offsetof(UKuroChangeMaterialsTextures, Textures) == 0x000058, "Member 'UKuroChangeMaterialsTextures::Textures' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroRuntimeTransientActor
// 0x0010 (0x02B8 - 0x02A8)
class AKuroRuntimeTransientActor final : public AActor
{
public:
	uint8                                         Pad_18C2[0x10];                                    // 0x02A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroRuntimeTransientActor">();
	}
	static class AKuroRuntimeTransientActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroRuntimeTransientActor>();
	}
};
static_assert(alignof(AKuroRuntimeTransientActor) == 0x000008, "Wrong alignment on AKuroRuntimeTransientActor");
static_assert(sizeof(AKuroRuntimeTransientActor) == 0x0002B8, "Wrong size on AKuroRuntimeTransientActor");

// Class KuroRenderingRuntimeBPPlugin.InteractiveLeaves
// 0x01D8 (0x0480 - 0x02A8)
class alignas(0x10) AInteractiveLeaves final : public AActor
{
public:
	class UInstancedStaticMeshComponent*          IsmComponent;                                      // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   StaticComponent;                                   // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractiveLeavesConfigData*           Config;                                            // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_18C3[0x1C0];                                   // 0x02C0(0x01C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractiveLeaves">();
	}
	static class AInteractiveLeaves* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInteractiveLeaves>();
	}
};
static_assert(alignof(AInteractiveLeaves) == 0x000010, "Wrong alignment on AInteractiveLeaves");
static_assert(sizeof(AInteractiveLeaves) == 0x000480, "Wrong size on AInteractiveLeaves");
static_assert(offsetof(AInteractiveLeaves, IsmComponent) == 0x0002A8, "Member 'AInteractiveLeaves::IsmComponent' has a wrong offset!");
static_assert(offsetof(AInteractiveLeaves, StaticComponent) == 0x0002B0, "Member 'AInteractiveLeaves::StaticComponent' has a wrong offset!");
static_assert(offsetof(AInteractiveLeaves, Config) == 0x0002B8, "Member 'AInteractiveLeaves::Config' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroChangeSkeletalMaterialsComponent
// 0x0010 (0x00D0 - 0x00C0)
class UKuroChangeSkeletalMaterialsComponent final : public UActorComponent
{
public:
	uint8                                         Pad_18C4[0x10];                                    // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelChangeMaterials();
	void ChangeMaterialsWithDataAsset(const class UKuroChangeMaterialsTextures* DataAsset);
	void ChangeMaterialsWithTextures(class USkeletalMeshComponent* SkeletalMeshComponent, class FName ParameterName, const TArray<TSoftObjectPtr<class UTexture2D>>& Textures);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroChangeSkeletalMaterialsComponent">();
	}
	static class UKuroChangeSkeletalMaterialsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroChangeSkeletalMaterialsComponent>();
	}
};
static_assert(alignof(UKuroChangeSkeletalMaterialsComponent) == 0x000008, "Wrong alignment on UKuroChangeSkeletalMaterialsComponent");
static_assert(sizeof(UKuroChangeSkeletalMaterialsComponent) == 0x0000D0, "Wrong size on UKuroChangeSkeletalMaterialsComponent");

// Class KuroRenderingRuntimeBPPlugin.InteractiveLeavesConfigData
// 0x0128 (0x0160 - 0x0038)
class UInteractiveLeavesConfigData final : public UPrimaryDataAsset
{
public:
	class UKuroPointCloudCache*                   PointCache;                                        // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKuroPointCloudCache*                   PointCacheMobile;                                  // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            InstanceMesh;                                      // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     InstanceMaterial;                                  // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            WholeMesh;                                         // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            WholeMeshMobile;                                   // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     WholeMaterial;                                     // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerRadius;                                      // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReviveRadius;                                      // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeTime;                                          // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialAgeRandom;                                  // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisappearTime;                                     // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReviveTime;                                        // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Drag;                                              // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerForceSize;                                   // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerForceExp;                                    // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitVelocitySizeMin;                               // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitVelocitySizeMax;                               // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitFloatVelocitySizeMin;                          // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitFloatVelocitySizeMax;                          // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ConstForce;                                        // 0x00A4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKuroPointKdTree                       SpatialTree;                                       // 0x00B0(0x0058)(Edit, EditConst, NativeAccessSpecifierPublic)
	struct FKuroPointKdTree                       SpatialTreeMobile;                                 // 0x0108(0x0058)(Edit, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractiveLeavesConfigData">();
	}
	static class UInteractiveLeavesConfigData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractiveLeavesConfigData>();
	}
};
static_assert(alignof(UInteractiveLeavesConfigData) == 0x000008, "Wrong alignment on UInteractiveLeavesConfigData");
static_assert(sizeof(UInteractiveLeavesConfigData) == 0x000160, "Wrong size on UInteractiveLeavesConfigData");
static_assert(offsetof(UInteractiveLeavesConfigData, PointCache) == 0x000038, "Member 'UInteractiveLeavesConfigData::PointCache' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, PointCacheMobile) == 0x000040, "Member 'UInteractiveLeavesConfigData::PointCacheMobile' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, InstanceMesh) == 0x000048, "Member 'UInteractiveLeavesConfigData::InstanceMesh' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, InstanceMaterial) == 0x000050, "Member 'UInteractiveLeavesConfigData::InstanceMaterial' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, WholeMesh) == 0x000058, "Member 'UInteractiveLeavesConfigData::WholeMesh' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, WholeMeshMobile) == 0x000060, "Member 'UInteractiveLeavesConfigData::WholeMeshMobile' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, WholeMaterial) == 0x000068, "Member 'UInteractiveLeavesConfigData::WholeMaterial' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, PlayerRadius) == 0x000070, "Member 'UInteractiveLeavesConfigData::PlayerRadius' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, ReviveRadius) == 0x000074, "Member 'UInteractiveLeavesConfigData::ReviveRadius' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, LifeTime) == 0x000078, "Member 'UInteractiveLeavesConfigData::LifeTime' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, InitialAgeRandom) == 0x00007C, "Member 'UInteractiveLeavesConfigData::InitialAgeRandom' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, DisappearTime) == 0x000080, "Member 'UInteractiveLeavesConfigData::DisappearTime' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, ReviveTime) == 0x000084, "Member 'UInteractiveLeavesConfigData::ReviveTime' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, Drag) == 0x000088, "Member 'UInteractiveLeavesConfigData::Drag' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, PlayerForceSize) == 0x00008C, "Member 'UInteractiveLeavesConfigData::PlayerForceSize' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, PlayerForceExp) == 0x000090, "Member 'UInteractiveLeavesConfigData::PlayerForceExp' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, InitVelocitySizeMin) == 0x000094, "Member 'UInteractiveLeavesConfigData::InitVelocitySizeMin' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, InitVelocitySizeMax) == 0x000098, "Member 'UInteractiveLeavesConfigData::InitVelocitySizeMax' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, InitFloatVelocitySizeMin) == 0x00009C, "Member 'UInteractiveLeavesConfigData::InitFloatVelocitySizeMin' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, InitFloatVelocitySizeMax) == 0x0000A0, "Member 'UInteractiveLeavesConfigData::InitFloatVelocitySizeMax' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, ConstForce) == 0x0000A4, "Member 'UInteractiveLeavesConfigData::ConstForce' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, SpatialTree) == 0x0000B0, "Member 'UInteractiveLeavesConfigData::SpatialTree' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, SpatialTreeMobile) == 0x000108, "Member 'UInteractiveLeavesConfigData::SpatialTreeMobile' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroSaveGame
// 0x00F0 (0x0120 - 0x0030)
class UKuroSaveGame final : public USaveGame
{
public:
	TMap<class FString, int32>                    IntMap;                                            // 0x0030(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FString, float>                    FloatMap;                                          // 0x0080(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            StringMap;                                         // 0x00D0(0x0050)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroSaveGame">();
	}
	static class UKuroSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroSaveGame>();
	}
};
static_assert(alignof(UKuroSaveGame) == 0x000008, "Wrong alignment on UKuroSaveGame");
static_assert(sizeof(UKuroSaveGame) == 0x000120, "Wrong size on UKuroSaveGame");
static_assert(offsetof(UKuroSaveGame, IntMap) == 0x000030, "Member 'UKuroSaveGame::IntMap' has a wrong offset!");
static_assert(offsetof(UKuroSaveGame, FloatMap) == 0x000080, "Member 'UKuroSaveGame::FloatMap' has a wrong offset!");
static_assert(offsetof(UKuroSaveGame, StringMap) == 0x0000D0, "Member 'UKuroSaveGame::StringMap' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroAnimNotify
// 0x0008 (0x0048 - 0x0040)
class UKuroAnimNotify : public UAnimNotify
{
public:
	int32                                         ExportIndex;                                       // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C6[0x4];                                     // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool K2_Notify(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation);
	bool K2_PostChangeProperty(const class FName PropertyName);
	bool K2_ValidateAssets();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroAnimNotify">();
	}
	static class UKuroAnimNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroAnimNotify>();
	}
};
static_assert(alignof(UKuroAnimNotify) == 0x000008, "Wrong alignment on UKuroAnimNotify");
static_assert(sizeof(UKuroAnimNotify) == 0x000048, "Wrong size on UKuroAnimNotify");
static_assert(offsetof(UKuroAnimNotify, ExportIndex) == 0x000040, "Member 'UKuroAnimNotify::ExportIndex' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroSceneEffectActor
// 0x0038 (0x02E8 - 0x02B0)
class AKuroSceneEffectActor : public AKuroEffectActor
{
public:
	bool                                          bIsSceneEffectHidden;                              // 0x02B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C9[0x7];                                     // 0x02B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNiagaraDiKuroRenderingParameters      NiagaraDiKuroRenderingParameters;                  // 0x02B8(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	bool GetIsWorldPartitionActor();
	void OnReceiveHideSceneEffectActor();
	void OnReceiveShowSceneEffectActor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroSceneEffectActor">();
	}
	static class AKuroSceneEffectActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroSceneEffectActor>();
	}
};
static_assert(alignof(AKuroSceneEffectActor) == 0x000008, "Wrong alignment on AKuroSceneEffectActor");
static_assert(sizeof(AKuroSceneEffectActor) == 0x0002E8, "Wrong size on AKuroSceneEffectActor");
static_assert(offsetof(AKuroSceneEffectActor, bIsSceneEffectHidden) == 0x0002B0, "Member 'AKuroSceneEffectActor::bIsSceneEffectHidden' has a wrong offset!");
static_assert(offsetof(AKuroSceneEffectActor, NiagaraDiKuroRenderingParameters) == 0x0002B8, "Member 'AKuroSceneEffectActor::NiagaraDiKuroRenderingParameters' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroAnimNotifyState
// 0x0008 (0x0048 - 0x0040)
class UKuroAnimNotifyState : public UAnimNotifyState
{
public:
	int32                                         ExportIndex;                                       // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18CA[0x4];                                     // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool K2_NotifyBegin(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation, float TotalDuration);
	bool K2_NotifyEnd(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation);
	bool K2_NotifyTick(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation, float FrameDeltaTime);
	bool K2_PostChangeProperty(const class FName PropertyName);
	bool K2_ValidateAssets();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroAnimNotifyState">();
	}
	static class UKuroAnimNotifyState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroAnimNotifyState>();
	}
};
static_assert(alignof(UKuroAnimNotifyState) == 0x000008, "Wrong alignment on UKuroAnimNotifyState");
static_assert(sizeof(UKuroAnimNotifyState) == 0x000048, "Wrong size on UKuroAnimNotifyState");
static_assert(offsetof(UKuroAnimNotifyState, ExportIndex) == 0x000040, "Member 'UKuroAnimNotifyState::ExportIndex' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroSceneInteractionActorSystem
// 0x0060 (0x0098 - 0x0038)
class UKuroSceneInteractionActorSystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_18CF[0x10];                                    // 0x0038(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class UKuroSceneInteractionInfo*> AllSceneInteractionInfos;                          // 0x0048(0x0050)(Transient, NativeAccessSpecifierPublic)

public:
	void BindActorToLevelSequenceActor(class AActor* ActorToBind, class ALevelSequenceActor* LevelSequenceActor, const class FString& BindingName);
	int32 CreateSceneInteractionLevel(const class FString& InLevelName, const EKuroSceneInteractionState InitState, const struct FVector& Location, const struct FRotator& Rotation);
	bool DestroySceneInteractionLevel(const int32 HandleId);
	EKuroSceneInteractionState GetCurrentState(const int32 HandleId);
	void SetSequenceWithTargetLevelActor(class ALevelSequenceActor* LevelSequenceActor, class ULevelSequence* InSequence, class AActor* TargetLevelActor);
	bool SwitchToState(const int32 HandleId, const EKuroSceneInteractionState TargetState, const bool NeedTransition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroSceneInteractionActorSystem">();
	}
	static class UKuroSceneInteractionActorSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroSceneInteractionActorSystem>();
	}
};
static_assert(alignof(UKuroSceneInteractionActorSystem) == 0x000008, "Wrong alignment on UKuroSceneInteractionActorSystem");
static_assert(sizeof(UKuroSceneInteractionActorSystem) == 0x000098, "Wrong size on UKuroSceneInteractionActorSystem");
static_assert(offsetof(UKuroSceneInteractionActorSystem, AllSceneInteractionInfos) == 0x000048, "Member 'UKuroSceneInteractionActorSystem::AllSceneInteractionInfos' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroBezierMeshComponent
// 0x00B0 (0x0630 - 0x0580)
class UKuroBezierMeshComponent final : public UProceduralMeshComponent
{
public:
	uint8                                         Pad_18D4[0xB8];                                    // 0x0578(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddLayer(float Alpha);
	void ClearData();
	void Dissipate(float SubLayersNum);
	int32 GetLayerNum();
	int32 GetMeshHeight();
	TArray<struct FVector> GetMeshPoints();
	TArray<int32> GetMeshTriangles();
	int32 GetMeshWidth();
	TArray<struct FVector> GetPointsArray();
	void SetKeyPoint(int32 Param_Index, float X, float Y, float Z);
	void Setup(int32 Width, float InUnitLength);
	void UpdateMesh(int32 Section);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroBezierMeshComponent">();
	}
	static class UKuroBezierMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroBezierMeshComponent>();
	}
};
static_assert(alignof(UKuroBezierMeshComponent) == 0x000010, "Wrong alignment on UKuroBezierMeshComponent");
static_assert(sizeof(UKuroBezierMeshComponent) == 0x000630, "Wrong size on UKuroBezierMeshComponent");

// Class KuroRenderingRuntimeBPPlugin.KuroSceneRainEmitterConfig
// 0x0058 (0x0090 - 0x0038)
class UKuroSceneRainEmitterConfig final : public UPrimaryDataAsset
{
public:
	TArray<struct FKuroRainActorSpawnProperties>  SpawnProperties;                                   // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                CycleBoxExtent;                                    // 0x0048(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DragSize;                                          // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gravity;                                           // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WindSize;                                          // 0x005C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVectorFieldStatic*                     VectorField;                                       // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VectorFieldPosScale;                               // 0x0070(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VectorFieldMoveSpeed;                              // 0x007C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VectorFieldForceSize;                              // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CenterBiasByWind;                                  // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroSceneRainEmitterConfig">();
	}
	static class UKuroSceneRainEmitterConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroSceneRainEmitterConfig>();
	}
};
static_assert(alignof(UKuroSceneRainEmitterConfig) == 0x000008, "Wrong alignment on UKuroSceneRainEmitterConfig");
static_assert(sizeof(UKuroSceneRainEmitterConfig) == 0x000090, "Wrong size on UKuroSceneRainEmitterConfig");
static_assert(offsetof(UKuroSceneRainEmitterConfig, SpawnProperties) == 0x000038, "Member 'UKuroSceneRainEmitterConfig::SpawnProperties' has a wrong offset!");
static_assert(offsetof(UKuroSceneRainEmitterConfig, CycleBoxExtent) == 0x000048, "Member 'UKuroSceneRainEmitterConfig::CycleBoxExtent' has a wrong offset!");
static_assert(offsetof(UKuroSceneRainEmitterConfig, DragSize) == 0x000054, "Member 'UKuroSceneRainEmitterConfig::DragSize' has a wrong offset!");
static_assert(offsetof(UKuroSceneRainEmitterConfig, Gravity) == 0x000058, "Member 'UKuroSceneRainEmitterConfig::Gravity' has a wrong offset!");
static_assert(offsetof(UKuroSceneRainEmitterConfig, WindSize) == 0x00005C, "Member 'UKuroSceneRainEmitterConfig::WindSize' has a wrong offset!");
static_assert(offsetof(UKuroSceneRainEmitterConfig, VectorField) == 0x000068, "Member 'UKuroSceneRainEmitterConfig::VectorField' has a wrong offset!");
static_assert(offsetof(UKuroSceneRainEmitterConfig, VectorFieldPosScale) == 0x000070, "Member 'UKuroSceneRainEmitterConfig::VectorFieldPosScale' has a wrong offset!");
static_assert(offsetof(UKuroSceneRainEmitterConfig, VectorFieldMoveSpeed) == 0x00007C, "Member 'UKuroSceneRainEmitterConfig::VectorFieldMoveSpeed' has a wrong offset!");
static_assert(offsetof(UKuroSceneRainEmitterConfig, VectorFieldForceSize) == 0x000088, "Member 'UKuroSceneRainEmitterConfig::VectorFieldForceSize' has a wrong offset!");
static_assert(offsetof(UKuroSceneRainEmitterConfig, CenterBiasByWind) == 0x00008C, "Member 'UKuroSceneRainEmitterConfig::CenterBiasByWind' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroBillboardComponent
// 0x0010 (0x00D0 - 0x00C0)
class UKuroBillboardComponent final : public UActorComponent
{
public:
	bool                                          IsUpdateEveryFrame;                                // 0x00C0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBillboardMode                                OrientAxis;                                        // 0x00C1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFixSize;                                         // 0x00C2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18D5[0x1];                                     // 0x00C3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScaleSize;                                         // 0x00C4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x00C8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSize;                                           // 0x00CC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Initialize();

	void Update() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroBillboardComponent">();
	}
	static class UKuroBillboardComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroBillboardComponent>();
	}
};
static_assert(alignof(UKuroBillboardComponent) == 0x000008, "Wrong alignment on UKuroBillboardComponent");
static_assert(sizeof(UKuroBillboardComponent) == 0x0000D0, "Wrong size on UKuroBillboardComponent");
static_assert(offsetof(UKuroBillboardComponent, IsUpdateEveryFrame) == 0x0000C0, "Member 'UKuroBillboardComponent::IsUpdateEveryFrame' has a wrong offset!");
static_assert(offsetof(UKuroBillboardComponent, OrientAxis) == 0x0000C1, "Member 'UKuroBillboardComponent::OrientAxis' has a wrong offset!");
static_assert(offsetof(UKuroBillboardComponent, IsFixSize) == 0x0000C2, "Member 'UKuroBillboardComponent::IsFixSize' has a wrong offset!");
static_assert(offsetof(UKuroBillboardComponent, ScaleSize) == 0x0000C4, "Member 'UKuroBillboardComponent::ScaleSize' has a wrong offset!");
static_assert(offsetof(UKuroBillboardComponent, MaxDistance) == 0x0000C8, "Member 'UKuroBillboardComponent::MaxDistance' has a wrong offset!");
static_assert(offsetof(UKuroBillboardComponent, MinSize) == 0x0000CC, "Member 'UKuroBillboardComponent::MinSize' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache
// 0x6970 (0x69A0 - 0x0030)
class UKuroCharacterMaterialControllerCache final : public UObject
{
public:
	struct FKuroCharMaterialControllerFloatGroup  Rotation;                                          // 0x0030(0x01B0)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerColorGroup  TextureScaleAndOffset;                             // 0x01E0(0x0660)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerColorGroup  TextureSpeed;                                      // 0x0840(0x0660)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerColorGroup  TextureColorTint;                                  // 0x0EA0(0x0660)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerFloatGroup  TextureStrength;                                   // 0x1500(0x01B0)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerFloatGroup  TextureLowerLimit;                                 // 0x16B0(0x01B0)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerFloatGroup  TextureUpperLimit;                                 // 0x1860(0x01B0)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FKuroCharMaterialControllerFloatGroup> FloatParameters;                                   // 0x1A10(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKuroCharMaterialControllerColorGroup> ColorParameters;                                   // 0x1A20(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerFloatGroup  RimRange;                                          // 0x1A30(0x01B0)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerColorGroup  RimColor;                                          // 0x1BE0(0x0660)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerFloatGroup  OutlineWidth;                                      // 0x2240(0x01B0)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerColorGroup  OutlineColor;                                      // 0x23F0(0x0660)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerFloatGroup  DissolveProgress;                                  // 0x2A50(0x01B0)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerFloatGroup  DissolveColorIntensity;                            // 0x2C00(0x01B0)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerColorGroup  DissolveColor;                                     // 0x2DB0(0x0660)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerFloatGroup  DissolveSmooth;                                    // 0x3410(0x01B0)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerColorGroup  BaseColorTint;                                     // 0x35C0(0x0660)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerColorGroup  MainTexColorTint;                                  // 0x3C20(0x0660)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerColorGroup  EmissionColor;                                     // 0x4280(0x0660)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerFloatGroup  EmissionIntensity;                                 // 0x48E0(0x01B0)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerColorGroup  BaseRefine;                                        // 0x4A90(0x0660)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerColorGroup  MotionColorStart;                                  // 0x50F0(0x0660)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerColorGroup  MotionColorEnd;                                    // 0x5750(0x0660)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerFloatGroup  MotionNoiseSpeed;                                  // 0x5DB0(0x01B0)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerFloatGroup  StripMaskProportion;                               // 0x5F60(0x01B0)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerFloatGroup  StripMaskVScale;                                   // 0x6110(0x01B0)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerFloatGroup  StripMaskVSpeed;                                   // 0x62C0(0x01B0)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerFloatGroup  DitherValue;                                       // 0x6470(0x01B0)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FKuroCharMaterialControllerFloatGroup> CustomFloatParameters;                             // 0x6620(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKuroCharMaterialControllerColorGroup> CustomColorParameters;                             // 0x6630(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerFloatGroup  HairDisplaceProgress;                              // 0x6640(0x01B0)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerFloatGroup  HairDisplaceContrast;                              // 0x67F0(0x01B0)(Edit, NativeAccessSpecifierPublic)

public:
	struct FLinearColor GetBaseColorTint(float Factor, int32 Type);
	struct FLinearColor GetBaseRefine(float Factor, int32 Type);
	struct FLinearColor GetCustomColorParametersValue(float Factor, int32 Type, int32 Param_Index);
	float GetCustomFloatParametersValue(float Factor, int32 Type, int32 Param_Index);
	struct FLinearColor GetDissolveColor(float Factor, int32 Type);
	float GetDissolveColorIntensity(float Factor, int32 Type);
	float GetDissolveProgress(float Factor, int32 Type);
	float GetDissolveSmooth(float Factor, int32 Type);
	float GetDitherValue(float Factor, int32 Type);
	struct FLinearColor GetEmissionColor(float Factor, int32 Type);
	float GetEmissionIntensity(float Factor, int32 Type);
	float GetHairDisplaceContrast(float Factor, int32 Type);
	float GetHairDisplaceProgress(float Factor, int32 Type);
	struct FLinearColor GetMainTexColorTint(float Factor, int32 Type);
	struct FLinearColor GetMotionColorEnd(float Factor, int32 Type);
	struct FLinearColor GetMotionColorStart(float Factor, int32 Type);
	float GetMotionNoiseSpeed(float Factor, int32 Type);
	struct FLinearColor GetOutlineColor(float Factor, int32 Type);
	float GetOutlineWidth(float Factor, int32 Type);
	struct FLinearColor GetRimColor(float Factor, int32 Type);
	float GetRimRange(float Factor, int32 Type);
	float GetRotation(float Factor, int32 Type);
	float GetStripMaskProportion(float Factor, int32 Type);
	float GetStripMaskVScale(float Factor, int32 Type);
	float GetStripMaskVSpeed(float Factor, int32 Type);
	struct FLinearColor GetTextureColorTint(float Factor, int32 Type);
	float GetTextureLowerLimit(float Factor, int32 Type);
	struct FLinearColor GetTextureScaleAndOffset(float Factor, int32 Type);
	struct FLinearColor GetTextureSpeed(float Factor, int32 Type);
	float GetTextureStrength(float Factor, int32 Type);
	float GetTextureUpperLimit(float Factor, int32 Type);
	void SetBaseColorTint(const struct FKuroCurveLinearColor& Start, const struct FKuroCurveLinearColor& Loop, const struct FKuroCurveLinearColor& End);
	void SetBaseRefine(const struct FKuroCurveLinearColor& Start, const struct FKuroCurveLinearColor& Loop, const struct FKuroCurveLinearColor& End);
	void SetCustomColorParametersValue(const TArray<struct FKuroCurveLinearColor>& Start, const TArray<struct FKuroCurveLinearColor>& Loop, const TArray<struct FKuroCurveLinearColor>& End);
	void SetCustomFloatParametersValue(const TArray<struct FKuroCurveFloat>& Start, const TArray<struct FKuroCurveFloat>& Loop, const TArray<struct FKuroCurveFloat>& End);
	void SetDissolveColor(const struct FKuroCurveLinearColor& Start, const struct FKuroCurveLinearColor& Loop, const struct FKuroCurveLinearColor& End);
	void SetDissolveColorIntensity(const struct FKuroCurveFloat& Start, const struct FKuroCurveFloat& Loop, const struct FKuroCurveFloat& End);
	void SetDissolveProgress(const struct FKuroCurveFloat& Start, const struct FKuroCurveFloat& Loop, const struct FKuroCurveFloat& End);
	void SetDissolveSmooth(const struct FKuroCurveFloat& Start, const struct FKuroCurveFloat& Loop, const struct FKuroCurveFloat& End);
	void SetDitherValue(const struct FKuroCurveFloat& Start, const struct FKuroCurveFloat& Loop, const struct FKuroCurveFloat& End);
	void SetEmissionColor(const struct FKuroCurveLinearColor& Start, const struct FKuroCurveLinearColor& Loop, const struct FKuroCurveLinearColor& End);
	void SetEmissionIntensity(const struct FKuroCurveFloat& Start, const struct FKuroCurveFloat& Loop, const struct FKuroCurveFloat& End);
	void SetHairDisplaceContrast(const struct FKuroCurveFloat& Start, const struct FKuroCurveFloat& Loop, const struct FKuroCurveFloat& End);
	void SetHairDisplaceProgress(const struct FKuroCurveFloat& Start, const struct FKuroCurveFloat& Loop, const struct FKuroCurveFloat& End);
	void SetMainTexColorTint(const struct FKuroCurveLinearColor& Start, const struct FKuroCurveLinearColor& Loop, const struct FKuroCurveLinearColor& End);
	void SetMotionColorEnd(const struct FKuroCurveLinearColor& Start, const struct FKuroCurveLinearColor& Loop, const struct FKuroCurveLinearColor& End);
	void SetMotionColorStart(const struct FKuroCurveLinearColor& Start, const struct FKuroCurveLinearColor& Loop, const struct FKuroCurveLinearColor& End);
	void SetMotionNoiseSpeed(const struct FKuroCurveFloat& Start, const struct FKuroCurveFloat& Loop, const struct FKuroCurveFloat& End);
	void SetOutlineColor(const struct FKuroCurveLinearColor& Start, const struct FKuroCurveLinearColor& Loop, const struct FKuroCurveLinearColor& End);
	void SetOutlineWidth(const struct FKuroCurveFloat& Start, const struct FKuroCurveFloat& Loop, const struct FKuroCurveFloat& End);
	void SetRimColor(const struct FKuroCurveLinearColor& Start, const struct FKuroCurveLinearColor& Loop, const struct FKuroCurveLinearColor& End);
	void SetRimRange(const struct FKuroCurveFloat& Start, const struct FKuroCurveFloat& Loop, const struct FKuroCurveFloat& End);
	void SetRotation(const struct FKuroCurveFloat& Start, const struct FKuroCurveFloat& Loop, const struct FKuroCurveFloat& End);
	void SetStripMaskProportion(const struct FKuroCurveFloat& Start, const struct FKuroCurveFloat& Loop, const struct FKuroCurveFloat& End);
	void SetStripMaskVScale(const struct FKuroCurveFloat& Start, const struct FKuroCurveFloat& Loop, const struct FKuroCurveFloat& End);
	void SetStripMaskVSpeed(const struct FKuroCurveFloat& Start, const struct FKuroCurveFloat& Loop, const struct FKuroCurveFloat& End);
	void SetTextureColorTint(const struct FKuroCurveLinearColor& Start, const struct FKuroCurveLinearColor& Loop, const struct FKuroCurveLinearColor& End);
	void SetTextureLowerLimit(const struct FKuroCurveFloat& Start, const struct FKuroCurveFloat& Loop, const struct FKuroCurveFloat& End);
	void SetTextureScaleAndOffset(const struct FKuroCurveLinearColor& Start, const struct FKuroCurveLinearColor& Loop, const struct FKuroCurveLinearColor& End);
	void SetTextureSpeed(const struct FKuroCurveLinearColor& Start, const struct FKuroCurveLinearColor& Loop, const struct FKuroCurveLinearColor& End);
	void SetTextureStrength(const struct FKuroCurveFloat& Start, const struct FKuroCurveFloat& Loop, const struct FKuroCurveFloat& End);
	void SetTextureUpperLimit(const struct FKuroCurveFloat& Start, const struct FKuroCurveFloat& Loop, const struct FKuroCurveFloat& End);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroCharacterMaterialControllerCache">();
	}
	static class UKuroCharacterMaterialControllerCache* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroCharacterMaterialControllerCache>();
	}
};
static_assert(alignof(UKuroCharacterMaterialControllerCache) == 0x000008, "Wrong alignment on UKuroCharacterMaterialControllerCache");
static_assert(sizeof(UKuroCharacterMaterialControllerCache) == 0x0069A0, "Wrong size on UKuroCharacterMaterialControllerCache");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, Rotation) == 0x000030, "Member 'UKuroCharacterMaterialControllerCache::Rotation' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, TextureScaleAndOffset) == 0x0001E0, "Member 'UKuroCharacterMaterialControllerCache::TextureScaleAndOffset' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, TextureSpeed) == 0x000840, "Member 'UKuroCharacterMaterialControllerCache::TextureSpeed' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, TextureColorTint) == 0x000EA0, "Member 'UKuroCharacterMaterialControllerCache::TextureColorTint' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, TextureStrength) == 0x001500, "Member 'UKuroCharacterMaterialControllerCache::TextureStrength' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, TextureLowerLimit) == 0x0016B0, "Member 'UKuroCharacterMaterialControllerCache::TextureLowerLimit' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, TextureUpperLimit) == 0x001860, "Member 'UKuroCharacterMaterialControllerCache::TextureUpperLimit' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, FloatParameters) == 0x001A10, "Member 'UKuroCharacterMaterialControllerCache::FloatParameters' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, ColorParameters) == 0x001A20, "Member 'UKuroCharacterMaterialControllerCache::ColorParameters' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, RimRange) == 0x001A30, "Member 'UKuroCharacterMaterialControllerCache::RimRange' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, RimColor) == 0x001BE0, "Member 'UKuroCharacterMaterialControllerCache::RimColor' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, OutlineWidth) == 0x002240, "Member 'UKuroCharacterMaterialControllerCache::OutlineWidth' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, OutlineColor) == 0x0023F0, "Member 'UKuroCharacterMaterialControllerCache::OutlineColor' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, DissolveProgress) == 0x002A50, "Member 'UKuroCharacterMaterialControllerCache::DissolveProgress' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, DissolveColorIntensity) == 0x002C00, "Member 'UKuroCharacterMaterialControllerCache::DissolveColorIntensity' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, DissolveColor) == 0x002DB0, "Member 'UKuroCharacterMaterialControllerCache::DissolveColor' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, DissolveSmooth) == 0x003410, "Member 'UKuroCharacterMaterialControllerCache::DissolveSmooth' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, BaseColorTint) == 0x0035C0, "Member 'UKuroCharacterMaterialControllerCache::BaseColorTint' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, MainTexColorTint) == 0x003C20, "Member 'UKuroCharacterMaterialControllerCache::MainTexColorTint' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, EmissionColor) == 0x004280, "Member 'UKuroCharacterMaterialControllerCache::EmissionColor' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, EmissionIntensity) == 0x0048E0, "Member 'UKuroCharacterMaterialControllerCache::EmissionIntensity' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, BaseRefine) == 0x004A90, "Member 'UKuroCharacterMaterialControllerCache::BaseRefine' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, MotionColorStart) == 0x0050F0, "Member 'UKuroCharacterMaterialControllerCache::MotionColorStart' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, MotionColorEnd) == 0x005750, "Member 'UKuroCharacterMaterialControllerCache::MotionColorEnd' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, MotionNoiseSpeed) == 0x005DB0, "Member 'UKuroCharacterMaterialControllerCache::MotionNoiseSpeed' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, StripMaskProportion) == 0x005F60, "Member 'UKuroCharacterMaterialControllerCache::StripMaskProportion' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, StripMaskVScale) == 0x006110, "Member 'UKuroCharacterMaterialControllerCache::StripMaskVScale' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, StripMaskVSpeed) == 0x0062C0, "Member 'UKuroCharacterMaterialControllerCache::StripMaskVSpeed' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, DitherValue) == 0x006470, "Member 'UKuroCharacterMaterialControllerCache::DitherValue' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, CustomFloatParameters) == 0x006620, "Member 'UKuroCharacterMaterialControllerCache::CustomFloatParameters' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, CustomColorParameters) == 0x006630, "Member 'UKuroCharacterMaterialControllerCache::CustomColorParameters' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, HairDisplaceProgress) == 0x006640, "Member 'UKuroCharacterMaterialControllerCache::HairDisplaceProgress' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, HairDisplaceContrast) == 0x0067F0, "Member 'UKuroCharacterMaterialControllerCache::HairDisplaceContrast' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroEditorTickActor
// 0x0010 (0x02B8 - 0x02A8)
class AKuroEditorTickActor : public AActor
{
public:
	bool                                          bEditorTickBySelected;                             // 0x02A8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetActorComponentTickEnabledByFocus;              // 0x02A9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18D6[0x2];                                     // 0x02AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KuroEditorTickActorId;                             // 0x02AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, DuplicateTransient, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18D7[0x8];                                     // 0x02B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EditorFocusIn();
	void EditorFocusOut();
	void EditorInit();
	void EditorTick(float DeltaSeconds);

	void EditorSetActorComponentsTickEnabled(bool bValue) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroEditorTickActor">();
	}
	static class AKuroEditorTickActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroEditorTickActor>();
	}
};
static_assert(alignof(AKuroEditorTickActor) == 0x000008, "Wrong alignment on AKuroEditorTickActor");
static_assert(sizeof(AKuroEditorTickActor) == 0x0002B8, "Wrong size on AKuroEditorTickActor");
static_assert(offsetof(AKuroEditorTickActor, bEditorTickBySelected) == 0x0002A8, "Member 'AKuroEditorTickActor::bEditorTickBySelected' has a wrong offset!");
static_assert(offsetof(AKuroEditorTickActor, bSetActorComponentTickEnabledByFocus) == 0x0002A9, "Member 'AKuroEditorTickActor::bSetActorComponentTickEnabledByFocus' has a wrong offset!");
static_assert(offsetof(AKuroEditorTickActor, KuroEditorTickActorId) == 0x0002AC, "Member 'AKuroEditorTickActor::KuroEditorTickActorId' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroCloudPrefabActor
// 0x0008 (0x02C0 - 0x02B8)
class AKuroCloudPrefabActor : public AKuroEditorTickActor
{
public:
	class UKuroPDCloudPrefab*                     CloudPrefab;                                       // 0x02B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class UMaterialInstanceDynamic* CreateDMI(class UStaticMeshComponent* Mesh);
	void SetGIParams(const float CurrentTime, class UMaterialParameterCollection* CloudCardCollection, const class FName& ParameterName);
	void SingleBuildingParametersInitial(class UMaterialInstanceDynamic* DynamicMaterial, class UStaticMeshComponent* Mesh, const struct FAnomaliesParameters& CloudStructParameter, const int32 TransSortNumber, class UMaterialParameterCollection* GloablShadingParameters);
	class UMaterialInstanceDynamic* SingleCloudCoverParametersInitial(class UStaticMeshComponent* Mesh, const struct FCloudCover& CloudStructParameter, const int32 TransSortNumber, class UMaterialParameterCollection* GloablShadingParameters, class UMaterialInstance** CurrentCoverMaterial, bool* bSetCoverMaterial, class UMaterialParameterCollection* CloudParameters);
	void SingleCloudParametersInitial(class UMaterialInstanceDynamic* DynamicMaterial, class UStaticMeshComponent* Mesh, const struct FCloudParameters& CloudStructParameter, const int32 TransSortNumber, class UMaterialParameterCollection* GloablShadingParameters);
	void SingleMountainParametersInitial(class UStaticMeshComponent* Mesh, const bool bHasMountain, class UMaterialParameterCollection* GloablShadingParameters);
	void SinglePOICloudParametersInitial(class UMaterialInstanceDynamic* DynamicMaterial, class UStaticMeshComponent* Mesh, const struct FPOICloudParameters& CloudStructParameter, const int32 TransSortNumber, class UMaterialParameterCollection* GloablShadingParameters, class UMaterialParameterCollection* CloudParameters, float Random);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroCloudPrefabActor">();
	}
	static class AKuroCloudPrefabActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroCloudPrefabActor>();
	}
};
static_assert(alignof(AKuroCloudPrefabActor) == 0x000008, "Wrong alignment on AKuroCloudPrefabActor");
static_assert(sizeof(AKuroCloudPrefabActor) == 0x0002C0, "Wrong size on AKuroCloudPrefabActor");
static_assert(offsetof(AKuroCloudPrefabActor, CloudPrefab) == 0x0002B8, "Member 'AKuroCloudPrefabActor::CloudPrefab' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroCloudsActor
// 0x0000 (0x02B8 - 0x02B8)
class AKuroCloudsActor : public AKuroEditorTickActor
{
public:
	void GetGIParams(const bool bCounting, class UChildActorComponent* Child01, class UChildActorComponent* Child02, class UMaterialParameterCollection* CloudCardCollection, const class FName ParameterName, float CurrentTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroCloudsActor">();
	}
	static class AKuroCloudsActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroCloudsActor>();
	}
};
static_assert(alignof(AKuroCloudsActor) == 0x000008, "Wrong alignment on AKuroCloudsActor");
static_assert(sizeof(AKuroCloudsActor) == 0x0002B8, "Wrong size on AKuroCloudsActor");

// Class KuroRenderingRuntimeBPPlugin.KuroEditorTickActorSubsystem
// 0x0028 (0x0060 - 0x0038)
class UKuroEditorTickActorSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_18E2[0x28];                                    // 0x0038(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroEditorTickActorSubsystem">();
	}
	static class UKuroEditorTickActorSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroEditorTickActorSubsystem>();
	}
};
static_assert(alignof(UKuroEditorTickActorSubsystem) == 0x000008, "Wrong alignment on UKuroEditorTickActorSubsystem");
static_assert(sizeof(UKuroEditorTickActorSubsystem) == 0x000060, "Wrong size on UKuroEditorTickActorSubsystem");

// Class KuroRenderingRuntimeBPPlugin.KuroEffectMakerAN
// 0x0038 (0x0080 - 0x0048)
class UKuroEffectMakerAN : public UKuroAnimNotify
{
public:
	uint8                                         Pad_18E3[0x4];                                     // 0x0048(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x004C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0058(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0064(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Attached;                                          // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AttachLocationOnly;                                // 0x0071(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18E4[0x2];                                     // 0x0072(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x0074(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroEffectMakerAN">();
	}
	static class UKuroEffectMakerAN* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroEffectMakerAN>();
	}
};
static_assert(alignof(UKuroEffectMakerAN) == 0x000008, "Wrong alignment on UKuroEffectMakerAN");
static_assert(sizeof(UKuroEffectMakerAN) == 0x000080, "Wrong size on UKuroEffectMakerAN");
static_assert(offsetof(UKuroEffectMakerAN, Location) == 0x00004C, "Member 'UKuroEffectMakerAN::Location' has a wrong offset!");
static_assert(offsetof(UKuroEffectMakerAN, Rotation) == 0x000058, "Member 'UKuroEffectMakerAN::Rotation' has a wrong offset!");
static_assert(offsetof(UKuroEffectMakerAN, Scale) == 0x000064, "Member 'UKuroEffectMakerAN::Scale' has a wrong offset!");
static_assert(offsetof(UKuroEffectMakerAN, Attached) == 0x000070, "Member 'UKuroEffectMakerAN::Attached' has a wrong offset!");
static_assert(offsetof(UKuroEffectMakerAN, AttachLocationOnly) == 0x000071, "Member 'UKuroEffectMakerAN::AttachLocationOnly' has a wrong offset!");
static_assert(offsetof(UKuroEffectMakerAN, SocketName) == 0x000074, "Member 'UKuroEffectMakerAN::SocketName' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroEffectMakerANS
// 0x0038 (0x0080 - 0x0048)
class UKuroEffectMakerANS : public UKuroAnimNotifyState
{
public:
	uint8                                         Pad_18E5[0x4];                                     // 0x0048(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x004C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0058(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0064(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Attached;                                          // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AttachLocationOnly;                                // 0x0071(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18E6[0x2];                                     // 0x0072(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x0074(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroEffectMakerANS">();
	}
	static class UKuroEffectMakerANS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroEffectMakerANS>();
	}
};
static_assert(alignof(UKuroEffectMakerANS) == 0x000008, "Wrong alignment on UKuroEffectMakerANS");
static_assert(sizeof(UKuroEffectMakerANS) == 0x000080, "Wrong size on UKuroEffectMakerANS");
static_assert(offsetof(UKuroEffectMakerANS, Location) == 0x00004C, "Member 'UKuroEffectMakerANS::Location' has a wrong offset!");
static_assert(offsetof(UKuroEffectMakerANS, Rotation) == 0x000058, "Member 'UKuroEffectMakerANS::Rotation' has a wrong offset!");
static_assert(offsetof(UKuroEffectMakerANS, Scale) == 0x000064, "Member 'UKuroEffectMakerANS::Scale' has a wrong offset!");
static_assert(offsetof(UKuroEffectMakerANS, Attached) == 0x000070, "Member 'UKuroEffectMakerANS::Attached' has a wrong offset!");
static_assert(offsetof(UKuroEffectMakerANS, AttachLocationOnly) == 0x000071, "Member 'UKuroEffectMakerANS::AttachLocationOnly' has a wrong offset!");
static_assert(offsetof(UKuroEffectMakerANS, SocketName) == 0x000074, "Member 'UKuroEffectMakerANS::SocketName' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroFloatingStaticMesh
// 0x0078 (0x0320 - 0x02A8)
class AKuroFloatingStaticMesh final : public AActor
{
public:
	class AKuroFloatingStaticMesh*                BindingActor;                                      // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18E7[0x20];                                    // 0x02B0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Movement;                                          // 0x02D0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Frequency;                                         // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RotateCenter;                                      // 0x02E0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x02EC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UStaticMesh*                            StaticMesh;                                        // 0x02F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TickFactorScale;                                   // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18E8[0x1C];                                    // 0x0304(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroFloatingStaticMesh">();
	}
	static class AKuroFloatingStaticMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroFloatingStaticMesh>();
	}
};
static_assert(alignof(AKuroFloatingStaticMesh) == 0x000008, "Wrong alignment on AKuroFloatingStaticMesh");
static_assert(sizeof(AKuroFloatingStaticMesh) == 0x000320, "Wrong size on AKuroFloatingStaticMesh");
static_assert(offsetof(AKuroFloatingStaticMesh, BindingActor) == 0x0002A8, "Member 'AKuroFloatingStaticMesh::BindingActor' has a wrong offset!");
static_assert(offsetof(AKuroFloatingStaticMesh, Movement) == 0x0002D0, "Member 'AKuroFloatingStaticMesh::Movement' has a wrong offset!");
static_assert(offsetof(AKuroFloatingStaticMesh, Frequency) == 0x0002DC, "Member 'AKuroFloatingStaticMesh::Frequency' has a wrong offset!");
static_assert(offsetof(AKuroFloatingStaticMesh, RotateCenter) == 0x0002E0, "Member 'AKuroFloatingStaticMesh::RotateCenter' has a wrong offset!");
static_assert(offsetof(AKuroFloatingStaticMesh, Rotation) == 0x0002EC, "Member 'AKuroFloatingStaticMesh::Rotation' has a wrong offset!");
static_assert(offsetof(AKuroFloatingStaticMesh, StaticMesh) == 0x0002F8, "Member 'AKuroFloatingStaticMesh::StaticMesh' has a wrong offset!");
static_assert(offsetof(AKuroFloatingStaticMesh, TickFactorScale) == 0x000300, "Member 'AKuroFloatingStaticMesh::TickFactorScale' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroFoliageRemoverActor
// 0x0000 (0x02B8 - 0x02B8)
class AKuroFoliageRemoverActor final : public AKuroEditorTickActor
{
public:
	void RemoveCrushedAllInstances();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroFoliageRemoverActor">();
	}
	static class AKuroFoliageRemoverActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroFoliageRemoverActor>();
	}
};
static_assert(alignof(AKuroFoliageRemoverActor) == 0x000008, "Wrong alignment on AKuroFoliageRemoverActor");
static_assert(sizeof(AKuroFoliageRemoverActor) == 0x0002B8, "Wrong size on AKuroFoliageRemoverActor");

// Class KuroRenderingRuntimeBPPlugin.ClusteredStuffDataAsset
// 0x0138 (0x0170 - 0x0038)
class UClusteredStuffDataAsset final : public UPrimaryDataAsset
{
public:
	class UNiagaraSystem*                         NiagaraSystem;                                     // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      FloatParameters;                                   // 0x0040(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FLinearColor>        ColorParameters;                                   // 0x0090(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FVector>             VectorParameters;                                  // 0x00E0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0130(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseWorldPosition : 1;                             // 0x013C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_18E9[0x3];                                     // 0x013D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WorldTransform;                                    // 0x0140(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClusteredStuffDataAsset">();
	}
	static class UClusteredStuffDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClusteredStuffDataAsset>();
	}
};
static_assert(alignof(UClusteredStuffDataAsset) == 0x000010, "Wrong alignment on UClusteredStuffDataAsset");
static_assert(sizeof(UClusteredStuffDataAsset) == 0x000170, "Wrong size on UClusteredStuffDataAsset");
static_assert(offsetof(UClusteredStuffDataAsset, NiagaraSystem) == 0x000038, "Member 'UClusteredStuffDataAsset::NiagaraSystem' has a wrong offset!");
static_assert(offsetof(UClusteredStuffDataAsset, FloatParameters) == 0x000040, "Member 'UClusteredStuffDataAsset::FloatParameters' has a wrong offset!");
static_assert(offsetof(UClusteredStuffDataAsset, ColorParameters) == 0x000090, "Member 'UClusteredStuffDataAsset::ColorParameters' has a wrong offset!");
static_assert(offsetof(UClusteredStuffDataAsset, VectorParameters) == 0x0000E0, "Member 'UClusteredStuffDataAsset::VectorParameters' has a wrong offset!");
static_assert(offsetof(UClusteredStuffDataAsset, Scale) == 0x000130, "Member 'UClusteredStuffDataAsset::Scale' has a wrong offset!");
static_assert(offsetof(UClusteredStuffDataAsset, WorldTransform) == 0x000140, "Member 'UClusteredStuffDataAsset::WorldTransform' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroWeatherDataAsset
// 0x09A8 (0x09E0 - 0x0038)
class UKuroWeatherDataAsset final : public UDataAsset
{
public:
	bool                                          UseOnlyOverrideProperty;                           // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseFixedTime;                                      // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18EA[0x2];                                     // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FixedTime;                                         // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseFixedSunAngle;                                  // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18EB[0x3];                                     // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FixedSunHorizonAngle;                              // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FixedSunVerticalAngle;                             // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18EC[0x4];                                     // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroGISetting                         GISetting;                                         // 0x0050(0x0990)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroWeatherDataAsset">();
	}
	static class UKuroWeatherDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroWeatherDataAsset>();
	}
};
static_assert(alignof(UKuroWeatherDataAsset) == 0x000010, "Wrong alignment on UKuroWeatherDataAsset");
static_assert(sizeof(UKuroWeatherDataAsset) == 0x0009E0, "Wrong size on UKuroWeatherDataAsset");
static_assert(offsetof(UKuroWeatherDataAsset, UseOnlyOverrideProperty) == 0x000038, "Member 'UKuroWeatherDataAsset::UseOnlyOverrideProperty' has a wrong offset!");
static_assert(offsetof(UKuroWeatherDataAsset, UseFixedTime) == 0x000039, "Member 'UKuroWeatherDataAsset::UseFixedTime' has a wrong offset!");
static_assert(offsetof(UKuroWeatherDataAsset, FixedTime) == 0x00003C, "Member 'UKuroWeatherDataAsset::FixedTime' has a wrong offset!");
static_assert(offsetof(UKuroWeatherDataAsset, UseFixedSunAngle) == 0x000040, "Member 'UKuroWeatherDataAsset::UseFixedSunAngle' has a wrong offset!");
static_assert(offsetof(UKuroWeatherDataAsset, FixedSunHorizonAngle) == 0x000044, "Member 'UKuroWeatherDataAsset::FixedSunHorizonAngle' has a wrong offset!");
static_assert(offsetof(UKuroWeatherDataAsset, FixedSunVerticalAngle) == 0x000048, "Member 'UKuroWeatherDataAsset::FixedSunVerticalAngle' has a wrong offset!");
static_assert(offsetof(UKuroWeatherDataAsset, GISetting) == 0x000050, "Member 'UKuroWeatherDataAsset::GISetting' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroTODData
// 0x0020 (0x0058 - 0x0038)
class UKuroTODData final : public UDataAsset
{
public:
	TArray<struct FKuroTODEntryData>              EntryDatas;                                        // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UKuroWeatherDataAsset*>          TODConfigs;                                        // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroTODData">();
	}
	static class UKuroTODData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroTODData>();
	}
};
static_assert(alignof(UKuroTODData) == 0x000008, "Wrong alignment on UKuroTODData");
static_assert(sizeof(UKuroTODData) == 0x000058, "Wrong size on UKuroTODData");
static_assert(offsetof(UKuroTODData, EntryDatas) == 0x000038, "Member 'UKuroTODData::EntryDatas' has a wrong offset!");
static_assert(offsetof(UKuroTODData, TODConfigs) == 0x000048, "Member 'UKuroTODData::TODConfigs' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroLandscapeParametersData
// 0x0010 (0x0048 - 0x0038)
class UKuroLandscapeParametersData final : public UDataAsset
{
public:
	TArray<float>                                 Parameters;                                        // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroLandscapeParametersData">();
	}
	static class UKuroLandscapeParametersData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroLandscapeParametersData>();
	}
};
static_assert(alignof(UKuroLandscapeParametersData) == 0x000008, "Wrong alignment on UKuroLandscapeParametersData");
static_assert(sizeof(UKuroLandscapeParametersData) == 0x000048, "Wrong size on UKuroLandscapeParametersData");
static_assert(offsetof(UKuroLandscapeParametersData, Parameters) == 0x000038, "Member 'UKuroLandscapeParametersData::Parameters' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroPPLensflareData
// 0x0030 (0x0068 - 0x0038)
class UKuroPPLensflareData final : public UPrimaryDataAsset
{
public:
	class FName                                   ConfigName;                                        // 0x0038(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18ED[0x4];                                     // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroLensflareSettings                 Settings;                                          // 0x0048(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroPPLensflareData">();
	}
	static class UKuroPPLensflareData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroPPLensflareData>();
	}
};
static_assert(alignof(UKuroPPLensflareData) == 0x000008, "Wrong alignment on UKuroPPLensflareData");
static_assert(sizeof(UKuroPPLensflareData) == 0x000068, "Wrong size on UKuroPPLensflareData");
static_assert(offsetof(UKuroPPLensflareData, ConfigName) == 0x000038, "Member 'UKuroPPLensflareData::ConfigName' has a wrong offset!");
static_assert(offsetof(UKuroPPLensflareData, Settings) == 0x000048, "Member 'UKuroPPLensflareData::Settings' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroGISettings
// 0x0070 (0x00B8 - 0x0048)
class UKuroGISettings final : public UDeveloperSettings
{
public:
	TArray<class FName>                           ThunderProfileNames;                               // 0x0048(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<class FName>                           RainProfileNames;                                  // 0x0058(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                LensflareDatas;                                    // 0x0068(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UKuroLandscapeParametersData> LandscapeParametersData;                           // 0x0078(0x0030)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UKuroPPLensflareData*>           LensflareDatasLoaded;                              // 0x00A8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroGISettings">();
	}
	static class UKuroGISettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroGISettings>();
	}
};
static_assert(alignof(UKuroGISettings) == 0x000008, "Wrong alignment on UKuroGISettings");
static_assert(sizeof(UKuroGISettings) == 0x0000B8, "Wrong size on UKuroGISettings");
static_assert(offsetof(UKuroGISettings, ThunderProfileNames) == 0x000048, "Member 'UKuroGISettings::ThunderProfileNames' has a wrong offset!");
static_assert(offsetof(UKuroGISettings, RainProfileNames) == 0x000058, "Member 'UKuroGISettings::RainProfileNames' has a wrong offset!");
static_assert(offsetof(UKuroGISettings, LensflareDatas) == 0x000068, "Member 'UKuroGISettings::LensflareDatas' has a wrong offset!");
static_assert(offsetof(UKuroGISettings, LandscapeParametersData) == 0x000078, "Member 'UKuroGISettings::LandscapeParametersData' has a wrong offset!");
static_assert(offsetof(UKuroGISettings, LensflareDatasLoaded) == 0x0000A8, "Member 'UKuroGISettings::LensflareDatasLoaded' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroGISystem
// 0x0498 (0x04D0 - 0x0038)
class alignas(0x10) UKuroGISystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_18EE[0x218];                                   // 0x0038(0x0218)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UObject*>             WeatherData;                                       // 0x0250(0x0050)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_18EF[0x138];                                   // 0x02A0(0x0138)(Fixing Size After Last Property [ Dumper-7 ])
	class UKuroWorldPartitionPreviewManager*      WorldPartitionPreviewManager;                      // 0x03D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKuroPostprocessMaterialManager        PostprocessMaterialManager;                        // 0x03E0(0x0030)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FKuroSceneEffectActorManager           SceneEffectActorManager;                           // 0x0410(0x0028)(NativeAccessSpecifierPublic)
	class UKuroRenderingPropertyDebugger*         PropertyDebugger;                                  // 0x0438(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18F0[0x50];                                    // 0x0440(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UKuroRainManager*                       RainManager;                                       // 0x0490(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_18F1[0x38];                                    // 0x0498(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UKuroGISystem* GetKuroGISystem(class UWorld* InWorld);

	bool End3DUISceneRendering();
	class AKuroGlobalGI* GetKuroGlobalGIActor();
	bool IsLastTickGIActor(class AKuroGlobalGI* Actor);
	bool IsUISceneRendering();
	bool Start3DUISceneRendering(const class FString& InLevelName);

	EKuroUI3DState GetUISceneRenderingState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroGISystem">();
	}
	static class UKuroGISystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroGISystem>();
	}
};
static_assert(alignof(UKuroGISystem) == 0x000010, "Wrong alignment on UKuroGISystem");
static_assert(sizeof(UKuroGISystem) == 0x0004D0, "Wrong size on UKuroGISystem");
static_assert(offsetof(UKuroGISystem, WeatherData) == 0x000250, "Member 'UKuroGISystem::WeatherData' has a wrong offset!");
static_assert(offsetof(UKuroGISystem, WorldPartitionPreviewManager) == 0x0003D8, "Member 'UKuroGISystem::WorldPartitionPreviewManager' has a wrong offset!");
static_assert(offsetof(UKuroGISystem, PostprocessMaterialManager) == 0x0003E0, "Member 'UKuroGISystem::PostprocessMaterialManager' has a wrong offset!");
static_assert(offsetof(UKuroGISystem, SceneEffectActorManager) == 0x000410, "Member 'UKuroGISystem::SceneEffectActorManager' has a wrong offset!");
static_assert(offsetof(UKuroGISystem, PropertyDebugger) == 0x000438, "Member 'UKuroGISystem::PropertyDebugger' has a wrong offset!");
static_assert(offsetof(UKuroGISystem, RainManager) == 0x000490, "Member 'UKuroGISystem::RainManager' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroGlobalColorSplitTextures
// 0x0050 (0x0088 - 0x0038)
class UKuroGlobalColorSplitTextures final : public UDataAsset
{
public:
	TMap<struct FWPCoord, TSoftObjectPtr<class UTexture2D>> CoordTexPair;                                      // 0x0038(0x0050)(Edit, BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroGlobalColorSplitTextures">();
	}
	static class UKuroGlobalColorSplitTextures* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroGlobalColorSplitTextures>();
	}
};
static_assert(alignof(UKuroGlobalColorSplitTextures) == 0x000008, "Wrong alignment on UKuroGlobalColorSplitTextures");
static_assert(sizeof(UKuroGlobalColorSplitTextures) == 0x000088, "Wrong size on UKuroGlobalColorSplitTextures");
static_assert(offsetof(UKuroGlobalColorSplitTextures, CoordTexPair) == 0x000038, "Member 'UKuroGlobalColorSplitTextures::CoordTexPair' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroGlobalColorMapComponent
// 0x0090 (0x0150 - 0x00C0)
class alignas(0x10) UKuroGlobalColorMapComponent final : public UActorComponent
{
public:
	class UKuroGlobalColorSplitTextures*          GlobalColorSplitTextures;                          // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ColorSplitTexturePlaceHolder;                      // 0x00C8(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SizePerCell;                                       // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18F4[0x54];                                    // 0x00FC(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateColorMap(const class UObject* WorldContextObject, const struct FVector& ViewLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroGlobalColorMapComponent">();
	}
	static class UKuroGlobalColorMapComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroGlobalColorMapComponent>();
	}
};
static_assert(alignof(UKuroGlobalColorMapComponent) == 0x000010, "Wrong alignment on UKuroGlobalColorMapComponent");
static_assert(sizeof(UKuroGlobalColorMapComponent) == 0x000150, "Wrong size on UKuroGlobalColorMapComponent");
static_assert(offsetof(UKuroGlobalColorMapComponent, GlobalColorSplitTextures) == 0x0000C0, "Member 'UKuroGlobalColorMapComponent::GlobalColorSplitTextures' has a wrong offset!");
static_assert(offsetof(UKuroGlobalColorMapComponent, ColorSplitTexturePlaceHolder) == 0x0000C8, "Member 'UKuroGlobalColorMapComponent::ColorSplitTexturePlaceHolder' has a wrong offset!");
static_assert(offsetof(UKuroGlobalColorMapComponent, SizePerCell) == 0x0000F8, "Member 'UKuroGlobalColorMapComponent::SizePerCell' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroGlobalGI
// 0x1DC8 (0x2070 - 0x02A8)
class AKuroGlobalGI : public AActor
{
public:
	bool                                          TickInEditor;                                      // 0x02A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPersistentLevelGI;                               // 0x02A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPostProcessVolumeChanged;                         // 0x02AA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18F6[0x1];                                     // 0x02AB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TickDeltaTime;                                     // 0x02AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ViewLocation;                                      // 0x02B0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SunHorizonAngle;                                   // 0x02BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SunVerticalAngle;                                  // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18F7[0xC];                                     // 0x02C4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroGISetting                         LerpGISetting;                                     // 0x02D0(0x0990)(Edit, BlueprintVisible, Transient, EditConst, NativeAccessSpecifierPublic)
	struct FKuroGISetting                         TempGISetting;                                     // 0x0C60(0x0990)(Edit, BlueprintVisible, Transient, EditConst, NativeAccessSpecifierPublic)
	struct FPostProcessSettings                   LerpPostProcessSetting;                            // 0x15F0(0x06D0)(Edit, BlueprintVisible, Transient, EditConst, NativeAccessSpecifierPublic)
	float                                         CurTimeAfterLerp;                                  // 0x1CC0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpSunHorizonAngle;                               // 0x1CC4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpSunVerticalAngle;                              // 0x1CC8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlobalWindSpeed;                                   // 0x1CCC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlobalWindPower;                                   // 0x1CD0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GlobalWindForwardDrection;                         // 0x1CD4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WindTextureOffset;                                 // 0x1CE0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDayTime;                                        // 0x1CEC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDayNightEmssiveFactor;                            // 0x1CED(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18F8[0x2];                                     // 0x1CEE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DayNightEmssiveSmoothFactor;                       // 0x1CF0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TODNightLightLoadingTime;                          // 0x1CF4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TODDayLightLoadingTime;                            // 0x1CF8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NowGlobalLightIntensity;                           // 0x1CFC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18F9[0x4];                                     // 0x1D00(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RainDensityStepSpeed;                              // 0x1D04(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinalRainDensityValue;                             // 0x1D08(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RainGravityStepSpeed;                              // 0x1D0C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinalRainGravityValue;                             // 0x1D10(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RainWindPowerStepSpeed;                            // 0x1D14(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharLightHorizontal;                               // 0x1D18(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CharDebugLightDirection;                           // 0x1D1C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CharDebugLightDirectionZero;                       // 0x1D28(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               AtmosphereSunRotation;                             // 0x1D34(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                AtmosphereSunForward;                              // 0x1D40(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               AtmosphereMoonRotation;                            // 0x1D4C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                AtmosphereMoonForward;                             // 0x1D58(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KuroViewCenterPlayerIndex;                         // 0x1D64(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KuroViewCenterHeightOffset;                        // 0x1D68(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCustomKuroViewCenter;                       // 0x1D6C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18FA[0x3];                                     // 0x1D6D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CustomKuroViewCenter;                              // 0x1D70(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurrentKuroViewCenter;                             // 0x1D7C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KuroTrailSystemEnable;                             // 0x1D88(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18FB[0x4];                                     // 0x1D8C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             KuroTrailNoiseTexutre;                             // 0x1D90(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpdatePostProcessDataThreshold;                    // 0x1D98(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18FC[0x4];                                     // 0x1D9C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureCube*                           KuroSkyLightCubemap1;                              // 0x1DA0(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureCube*                           KuroSkyLightCubemap2;                              // 0x1DA8(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureCube*                           KuroSkyLightCubemap3;                              // 0x1DB0(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KuroCubemapBlend12;                                // 0x1DB8(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KuroCubemapBlend23;                                // 0x1DBC(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KuroGlobalGIIndex;                                 // 0x1DC0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, DuplicateTransient, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GIID;                                              // 0x1DC4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, DuplicateTransient, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsKuroInit;                                        // 0x1DC8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, DuplicateTransient, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18FD[0x7];                                     // 0x1DC9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollection*           GIMPC;                                             // 0x1DD0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18FE[0x20];                                    // 0x1DD8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        FogTime;                                           // 0x1DF8(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class UClusteredStuffDataAsset*, class AKuroRuntimeTransientActor*> ClusteredStuffTransientActors;                     // 0x1E88(0x0050)(Transient, NativeAccessSpecifierPublic)
	TSet<class UClusteredStuffDataAsset*>         ClusteredStuffActive;                              // 0x1ED8(0x0050)(Transient, NativeAccessSpecifierPublic)
	TArray<class UClusteredStuffDataAsset*>       AdditionalClusteredStuff;                          // 0x1F28(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class UClusteredStuffDataAsset*               DefaultAutoGrassData;                              // 0x1F38(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18FF[0x8];                                     // 0x1F40(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USunLensFlareConfig*                    DefaultSunLensflareConfig;                         // 0x1F48(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               StarsMat;                                          // 0x1F50(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               MilkyWayMat;                                       // 0x1F58(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               SkyBoxMat;                                         // 0x1F60(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerInCave;                                     // 0x1F68(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerInGrass;                                    // 0x1F69(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1900[0x2];                                     // 0x1F6A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FinalRoughnessDensity;                             // 0x1F6C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1901[0x10];                                    // 0x1F70(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UKuroPointCloudStreamingConfig*         GlobalPointCloudStreamingConfig;                   // 0x1F80(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlobalPointCloudStreamingDistance;                 // 0x1F88(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1902[0x4];                                     // 0x1F8C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UKuroTODData*                           TODDataAsset;                                      // 0x1F90(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UKuroGISystem>           CachedGISystem;                                    // 0x1F98(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1903[0x18];                                    // 0x1FA0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               LightFunctionMap_Texture;                          // 0x1FB8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1904[0xB0];                                    // 0x1FC0(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplayShadowTintRampOffset(class USkyLightComponent* SkyLight);
	void Apply3DUISceneSkyLight(class USkyLightComponent* SkyLight);
	void ApplyAndUpdateDayNightDataLayer(float TimeOfDay, float TODLightLoadingWait);
	void ApplyClusteredStuff();
	void ApplyGIMPC();
	void ApplyGlobalGIRenderQuality(class UMaterialInstanceDynamic* DynamicMaterial);
	void ApplyKuroSkyLight(class USkyLightComponent* SkyLight, float TimeOfDay, float DefaultShadowSupplement, float DefaultReflectionAddIntensity);
	void ApplyLensflare(float DeltaTime, const struct FVector& SunForward, class UMaterialParameterCollection* Collection);
	void ApplyLightFunctionSetting(class UMaterialInstanceDynamic* DynamicMaterial, class UTexture* DefaultLightFucntionTexture);
	void ApplyMilkyWayParameters(class UMaterialInstance* MilkyWayMaterial, class UStaticMeshComponent* MilkyWayMeshComponent);
	void ApplyRainOverrider(class AKuroWorldRainGlobalOverrider* Overrider);
	void ApplySkyBoxSetting(const class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, class UMaterialInstance* SkyBoxMaterial, class UStaticMeshComponent* SkyBoxMeshComponent);
	void ApplyStarsParameters(class UMaterialInstance* StarMaterial, class UStaticMeshComponent* StarMeshComponent);
	void CalLightDirectionWithLimit(float Time, float LightAngleLimit, struct FRotator* LightRotation);
	class UKuroGISystem* GetCachedGISystem();
	float GetGITime();
	void OnKuroEndUI();
	void OnKuroEndUiScene();
	void OnKuroInit();
	void OnKuroRuntimeDestroy();
	void OnKuroSetRuntimeTime(float CurrentTime);
	void OnKuroStartUI(const class FString& InName, class ULevel* InUILevel);
	void OnKuroStartUiScene(const class FString& InName, class ULevel* InUILevel);
	void OnKuroTick(float DeltaTime);
	void OnKuroTickEditor(float DeltaTime);
	void SetGITime(float Time);
	void SetSunLensflareEnabled(bool bEnable);
	void UpdateAndApplyWeather();
	void UpdateAndApplyWind(const class UObject* WorldContextObject, class UMaterialParameterCollection* Collection);
	void UpdateCharLightHorizontal(const class UObject* WorldContextObject, const struct FRotator& SceneLightRot, class UMaterialParameterCollection* Collection, bool bDebugCharLightHorizontal, float DebugCharLightHorizontal, float DebugCharLightVertical);
	void UpdateKuroTrailSystem(const class UObject* WorldContextObject, class UMaterialParameterCollection* Collection);
	void UpdateLightDirection(const class UObject* WorldContextObject, class UDirectionalLightComponent* AtmoSunLight, class UDirectionalLightComponent* AtmoMoonLight);
	void UpdateLightEnableCastShadow(const class UObject* WorldContextObject, class UDirectionalLightComponent* SceneLight);
	void UpdatePostProcessSettingData(const class UObject* WorldContextObject, float CurTime, bool bSkipLerpData);
	void UpdateTODData(const class UObject* WorldContextObject, const struct FVector& WorldPosition, float TimeSecnod);

	void ApplyCloudCardSetting(const class UObject* WorldContextObject, class UMaterialParameterCollection* Collection) const;
	void ApplyFog(const class UObject* WorldContextObject, class UExponentialHeightFogComponent* HeightFog, class UMaterialParameterCollection* Collection, float WorldZOffset, class UStaticMeshComponent* CloudOcean) const;
	void ApplyGlobalShaderParameters(const class UObject* WorldContextObject, class UMaterialParameterCollection* Collection) const;
	void ApplyLightParameters(const class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, class UDirectionalLightComponent* SceneLight) const;
	void ApplyLightShaft(class UDirectionalLightComponent* SceneLight) const;
	void ApplySkyEffectsParameters(const class UObject* WorldContextObject, class UMaterialParameterCollection* Collection) const;
	float CalcTODTimeFactor(float StartTime, float EndTime, float CurrTime) const;
	bool K2_IsInPersistentLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroGlobalGI">();
	}
	static class AKuroGlobalGI* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroGlobalGI>();
	}
};
static_assert(alignof(AKuroGlobalGI) == 0x000010, "Wrong alignment on AKuroGlobalGI");
static_assert(sizeof(AKuroGlobalGI) == 0x002070, "Wrong size on AKuroGlobalGI");
static_assert(offsetof(AKuroGlobalGI, TickInEditor) == 0x0002A8, "Member 'AKuroGlobalGI::TickInEditor' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, IsPersistentLevelGI) == 0x0002A9, "Member 'AKuroGlobalGI::IsPersistentLevelGI' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, bPostProcessVolumeChanged) == 0x0002AA, "Member 'AKuroGlobalGI::bPostProcessVolumeChanged' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, TickDeltaTime) == 0x0002AC, "Member 'AKuroGlobalGI::TickDeltaTime' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, ViewLocation) == 0x0002B0, "Member 'AKuroGlobalGI::ViewLocation' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, SunHorizonAngle) == 0x0002BC, "Member 'AKuroGlobalGI::SunHorizonAngle' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, SunVerticalAngle) == 0x0002C0, "Member 'AKuroGlobalGI::SunVerticalAngle' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, LerpGISetting) == 0x0002D0, "Member 'AKuroGlobalGI::LerpGISetting' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, TempGISetting) == 0x000C60, "Member 'AKuroGlobalGI::TempGISetting' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, LerpPostProcessSetting) == 0x0015F0, "Member 'AKuroGlobalGI::LerpPostProcessSetting' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, CurTimeAfterLerp) == 0x001CC0, "Member 'AKuroGlobalGI::CurTimeAfterLerp' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, LerpSunHorizonAngle) == 0x001CC4, "Member 'AKuroGlobalGI::LerpSunHorizonAngle' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, LerpSunVerticalAngle) == 0x001CC8, "Member 'AKuroGlobalGI::LerpSunVerticalAngle' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, GlobalWindSpeed) == 0x001CCC, "Member 'AKuroGlobalGI::GlobalWindSpeed' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, GlobalWindPower) == 0x001CD0, "Member 'AKuroGlobalGI::GlobalWindPower' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, GlobalWindForwardDrection) == 0x001CD4, "Member 'AKuroGlobalGI::GlobalWindForwardDrection' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, WindTextureOffset) == 0x001CE0, "Member 'AKuroGlobalGI::WindTextureOffset' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, bIsDayTime) == 0x001CEC, "Member 'AKuroGlobalGI::bIsDayTime' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, bDayNightEmssiveFactor) == 0x001CED, "Member 'AKuroGlobalGI::bDayNightEmssiveFactor' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, DayNightEmssiveSmoothFactor) == 0x001CF0, "Member 'AKuroGlobalGI::DayNightEmssiveSmoothFactor' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, TODNightLightLoadingTime) == 0x001CF4, "Member 'AKuroGlobalGI::TODNightLightLoadingTime' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, TODDayLightLoadingTime) == 0x001CF8, "Member 'AKuroGlobalGI::TODDayLightLoadingTime' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, NowGlobalLightIntensity) == 0x001CFC, "Member 'AKuroGlobalGI::NowGlobalLightIntensity' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, RainDensityStepSpeed) == 0x001D04, "Member 'AKuroGlobalGI::RainDensityStepSpeed' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, FinalRainDensityValue) == 0x001D08, "Member 'AKuroGlobalGI::FinalRainDensityValue' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, RainGravityStepSpeed) == 0x001D0C, "Member 'AKuroGlobalGI::RainGravityStepSpeed' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, FinalRainGravityValue) == 0x001D10, "Member 'AKuroGlobalGI::FinalRainGravityValue' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, RainWindPowerStepSpeed) == 0x001D14, "Member 'AKuroGlobalGI::RainWindPowerStepSpeed' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, CharLightHorizontal) == 0x001D18, "Member 'AKuroGlobalGI::CharLightHorizontal' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, CharDebugLightDirection) == 0x001D1C, "Member 'AKuroGlobalGI::CharDebugLightDirection' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, CharDebugLightDirectionZero) == 0x001D28, "Member 'AKuroGlobalGI::CharDebugLightDirectionZero' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, AtmosphereSunRotation) == 0x001D34, "Member 'AKuroGlobalGI::AtmosphereSunRotation' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, AtmosphereSunForward) == 0x001D40, "Member 'AKuroGlobalGI::AtmosphereSunForward' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, AtmosphereMoonRotation) == 0x001D4C, "Member 'AKuroGlobalGI::AtmosphereMoonRotation' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, AtmosphereMoonForward) == 0x001D58, "Member 'AKuroGlobalGI::AtmosphereMoonForward' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, KuroViewCenterPlayerIndex) == 0x001D64, "Member 'AKuroGlobalGI::KuroViewCenterPlayerIndex' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, KuroViewCenterHeightOffset) == 0x001D68, "Member 'AKuroGlobalGI::KuroViewCenterHeightOffset' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, bEnableCustomKuroViewCenter) == 0x001D6C, "Member 'AKuroGlobalGI::bEnableCustomKuroViewCenter' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, CustomKuroViewCenter) == 0x001D70, "Member 'AKuroGlobalGI::CustomKuroViewCenter' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, CurrentKuroViewCenter) == 0x001D7C, "Member 'AKuroGlobalGI::CurrentKuroViewCenter' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, KuroTrailSystemEnable) == 0x001D88, "Member 'AKuroGlobalGI::KuroTrailSystemEnable' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, KuroTrailNoiseTexutre) == 0x001D90, "Member 'AKuroGlobalGI::KuroTrailNoiseTexutre' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, UpdatePostProcessDataThreshold) == 0x001D98, "Member 'AKuroGlobalGI::UpdatePostProcessDataThreshold' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, KuroSkyLightCubemap1) == 0x001DA0, "Member 'AKuroGlobalGI::KuroSkyLightCubemap1' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, KuroSkyLightCubemap2) == 0x001DA8, "Member 'AKuroGlobalGI::KuroSkyLightCubemap2' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, KuroSkyLightCubemap3) == 0x001DB0, "Member 'AKuroGlobalGI::KuroSkyLightCubemap3' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, KuroCubemapBlend12) == 0x001DB8, "Member 'AKuroGlobalGI::KuroCubemapBlend12' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, KuroCubemapBlend23) == 0x001DBC, "Member 'AKuroGlobalGI::KuroCubemapBlend23' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, KuroGlobalGIIndex) == 0x001DC0, "Member 'AKuroGlobalGI::KuroGlobalGIIndex' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, GIID) == 0x001DC4, "Member 'AKuroGlobalGI::GIID' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, IsKuroInit) == 0x001DC8, "Member 'AKuroGlobalGI::IsKuroInit' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, GIMPC) == 0x001DD0, "Member 'AKuroGlobalGI::GIMPC' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, FogTime) == 0x001DF8, "Member 'AKuroGlobalGI::FogTime' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, ClusteredStuffTransientActors) == 0x001E88, "Member 'AKuroGlobalGI::ClusteredStuffTransientActors' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, ClusteredStuffActive) == 0x001ED8, "Member 'AKuroGlobalGI::ClusteredStuffActive' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, AdditionalClusteredStuff) == 0x001F28, "Member 'AKuroGlobalGI::AdditionalClusteredStuff' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, DefaultAutoGrassData) == 0x001F38, "Member 'AKuroGlobalGI::DefaultAutoGrassData' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, DefaultSunLensflareConfig) == 0x001F48, "Member 'AKuroGlobalGI::DefaultSunLensflareConfig' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, StarsMat) == 0x001F50, "Member 'AKuroGlobalGI::StarsMat' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, MilkyWayMat) == 0x001F58, "Member 'AKuroGlobalGI::MilkyWayMat' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, SkyBoxMat) == 0x001F60, "Member 'AKuroGlobalGI::SkyBoxMat' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, bPlayerInCave) == 0x001F68, "Member 'AKuroGlobalGI::bPlayerInCave' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, bPlayerInGrass) == 0x001F69, "Member 'AKuroGlobalGI::bPlayerInGrass' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, FinalRoughnessDensity) == 0x001F6C, "Member 'AKuroGlobalGI::FinalRoughnessDensity' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, GlobalPointCloudStreamingConfig) == 0x001F80, "Member 'AKuroGlobalGI::GlobalPointCloudStreamingConfig' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, GlobalPointCloudStreamingDistance) == 0x001F88, "Member 'AKuroGlobalGI::GlobalPointCloudStreamingDistance' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, TODDataAsset) == 0x001F90, "Member 'AKuroGlobalGI::TODDataAsset' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, CachedGISystem) == 0x001F98, "Member 'AKuroGlobalGI::CachedGISystem' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, LightFunctionMap_Texture) == 0x001FB8, "Member 'AKuroGlobalGI::LightFunctionMap_Texture' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroHeightMapSettings
// 0x0010 (0x0048 - 0x0038)
class UKuroHeightMapSettings final : public UPrimaryDataAsset
{
public:
	class UKuroSplitTextureStreamerSettings*      StreamerSettings;                                  // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShotHeight;                                        // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_190B[0x4];                                     // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroHeightMapSettings">();
	}
	static class UKuroHeightMapSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroHeightMapSettings>();
	}
};
static_assert(alignof(UKuroHeightMapSettings) == 0x000008, "Wrong alignment on UKuroHeightMapSettings");
static_assert(sizeof(UKuroHeightMapSettings) == 0x000048, "Wrong size on UKuroHeightMapSettings");
static_assert(offsetof(UKuroHeightMapSettings, StreamerSettings) == 0x000038, "Member 'UKuroHeightMapSettings::StreamerSettings' has a wrong offset!");
static_assert(offsetof(UKuroHeightMapSettings, ShotHeight) == 0x000040, "Member 'UKuroHeightMapSettings::ShotHeight' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroGlobalHeightMapComponent
// 0x0080 (0x0140 - 0x00C0)
class alignas(0x10) UKuroGlobalHeightMapComponent final : public UActorComponent
{
public:
	class UKuroHeightMapSettings*                 HeightMapSettings;                                 // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoadNumPerSidePc;                                  // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoadNumPerSideMobile;                              // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        LoadedTextures;                                    // 0x00D0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_190C[0x60];                                    // 0x00E0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Update();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroGlobalHeightMapComponent">();
	}
	static class UKuroGlobalHeightMapComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroGlobalHeightMapComponent>();
	}
};
static_assert(alignof(UKuroGlobalHeightMapComponent) == 0x000010, "Wrong alignment on UKuroGlobalHeightMapComponent");
static_assert(sizeof(UKuroGlobalHeightMapComponent) == 0x000140, "Wrong size on UKuroGlobalHeightMapComponent");
static_assert(offsetof(UKuroGlobalHeightMapComponent, HeightMapSettings) == 0x0000C0, "Member 'UKuroGlobalHeightMapComponent::HeightMapSettings' has a wrong offset!");
static_assert(offsetof(UKuroGlobalHeightMapComponent, LoadNumPerSidePc) == 0x0000C8, "Member 'UKuroGlobalHeightMapComponent::LoadNumPerSidePc' has a wrong offset!");
static_assert(offsetof(UKuroGlobalHeightMapComponent, LoadNumPerSideMobile) == 0x0000CC, "Member 'UKuroGlobalHeightMapComponent::LoadNumPerSideMobile' has a wrong offset!");
static_assert(offsetof(UKuroGlobalHeightMapComponent, LoadedTextures) == 0x0000D0, "Member 'UKuroGlobalHeightMapComponent::LoadedTextures' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroGPUParticleActor
// 0x0010 (0x02B8 - 0x02A8)
class AKuroGPUParticleActor final : public AActor
{
public:
	int32                                         KuroIndex;                                         // 0x02A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, DuplicateTransient, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_190D[0x4];                                     // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UKuroGPUParticleComponent*              GPUParticleComponent;                              // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroGPUParticleActor">();
	}
	static class AKuroGPUParticleActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroGPUParticleActor>();
	}
};
static_assert(alignof(AKuroGPUParticleActor) == 0x000008, "Wrong alignment on AKuroGPUParticleActor");
static_assert(sizeof(AKuroGPUParticleActor) == 0x0002B8, "Wrong size on AKuroGPUParticleActor");
static_assert(offsetof(AKuroGPUParticleActor, KuroIndex) == 0x0002A8, "Member 'AKuroGPUParticleActor::KuroIndex' has a wrong offset!");
static_assert(offsetof(AKuroGPUParticleActor, GPUParticleComponent) == 0x0002B0, "Member 'AKuroGPUParticleActor::GPUParticleComponent' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroGPUParticleComponent
// 0x00F0 (0x0680 - 0x0590)
class UKuroGPUParticleComponent final : public UStaticMeshComponent
{
public:
	class UKuroGPUParticleDA*                     GPUParticleDataAsset;                              // 0x0590(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ClickReplay;                                       // 0x0598(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopAtFinalFrame;                                  // 0x0599(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoUpdate;                                        // 0x059A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_190E[0x1];                                     // 0x059B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SimulateFramerate;                                 // 0x059C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Loop;                                              // 0x05A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Reverse;                                           // 0x05A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_190F[0x2];                                     // 0x05A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LoopIntervalTime;                                  // 0x05A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkipFrameCount;                                    // 0x05A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartWaitTime;                                     // 0x05AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseCustomTimeScaleCurve;                           // 0x05B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnablePingPong;                                    // 0x05B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1910[0x2];                                     // 0x05B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PingPongTime;                                      // 0x05B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        CustomTimeScaleCurve;                              // 0x05B8(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_1911[0x38];                                    // 0x0648(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoTick(float DeltaTime);
	void ResetParticle();
	void SetGPUData(class UKuroGPUParticleDA* TargetData);
	void SetupParticle(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroGPUParticleComponent">();
	}
	static class UKuroGPUParticleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroGPUParticleComponent>();
	}
};
static_assert(alignof(UKuroGPUParticleComponent) == 0x000010, "Wrong alignment on UKuroGPUParticleComponent");
static_assert(sizeof(UKuroGPUParticleComponent) == 0x000680, "Wrong size on UKuroGPUParticleComponent");
static_assert(offsetof(UKuroGPUParticleComponent, GPUParticleDataAsset) == 0x000590, "Member 'UKuroGPUParticleComponent::GPUParticleDataAsset' has a wrong offset!");
static_assert(offsetof(UKuroGPUParticleComponent, ClickReplay) == 0x000598, "Member 'UKuroGPUParticleComponent::ClickReplay' has a wrong offset!");
static_assert(offsetof(UKuroGPUParticleComponent, StopAtFinalFrame) == 0x000599, "Member 'UKuroGPUParticleComponent::StopAtFinalFrame' has a wrong offset!");
static_assert(offsetof(UKuroGPUParticleComponent, AutoUpdate) == 0x00059A, "Member 'UKuroGPUParticleComponent::AutoUpdate' has a wrong offset!");
static_assert(offsetof(UKuroGPUParticleComponent, SimulateFramerate) == 0x00059C, "Member 'UKuroGPUParticleComponent::SimulateFramerate' has a wrong offset!");
static_assert(offsetof(UKuroGPUParticleComponent, Loop) == 0x0005A0, "Member 'UKuroGPUParticleComponent::Loop' has a wrong offset!");
static_assert(offsetof(UKuroGPUParticleComponent, Reverse) == 0x0005A1, "Member 'UKuroGPUParticleComponent::Reverse' has a wrong offset!");
static_assert(offsetof(UKuroGPUParticleComponent, LoopIntervalTime) == 0x0005A4, "Member 'UKuroGPUParticleComponent::LoopIntervalTime' has a wrong offset!");
static_assert(offsetof(UKuroGPUParticleComponent, SkipFrameCount) == 0x0005A8, "Member 'UKuroGPUParticleComponent::SkipFrameCount' has a wrong offset!");
static_assert(offsetof(UKuroGPUParticleComponent, StartWaitTime) == 0x0005AC, "Member 'UKuroGPUParticleComponent::StartWaitTime' has a wrong offset!");
static_assert(offsetof(UKuroGPUParticleComponent, UseCustomTimeScaleCurve) == 0x0005B0, "Member 'UKuroGPUParticleComponent::UseCustomTimeScaleCurve' has a wrong offset!");
static_assert(offsetof(UKuroGPUParticleComponent, EnablePingPong) == 0x0005B1, "Member 'UKuroGPUParticleComponent::EnablePingPong' has a wrong offset!");
static_assert(offsetof(UKuroGPUParticleComponent, PingPongTime) == 0x0005B4, "Member 'UKuroGPUParticleComponent::PingPongTime' has a wrong offset!");
static_assert(offsetof(UKuroGPUParticleComponent, CustomTimeScaleCurve) == 0x0005B8, "Member 'UKuroGPUParticleComponent::CustomTimeScaleCurve' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroGPUParticleDA
// 0x0040 (0x0078 - 0x0038)
class UKuroGPUParticleDA final : public UDataAsset
{
public:
	class FString                                 JsonDataPath;                                      // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      GPUParticleMaterial;                               // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartFrame;                                        // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndFrame;                                          // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorIntensity;                                    // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityScale;                                     // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AspectRatio;                                       // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1912[0x4];                                     // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKuroGPUParticleMeshInfo>       AllParticleInfos;                                  // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroGPUParticleDA">();
	}
	static class UKuroGPUParticleDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroGPUParticleDA>();
	}
};
static_assert(alignof(UKuroGPUParticleDA) == 0x000008, "Wrong alignment on UKuroGPUParticleDA");
static_assert(sizeof(UKuroGPUParticleDA) == 0x000078, "Wrong size on UKuroGPUParticleDA");
static_assert(offsetof(UKuroGPUParticleDA, JsonDataPath) == 0x000038, "Member 'UKuroGPUParticleDA::JsonDataPath' has a wrong offset!");
static_assert(offsetof(UKuroGPUParticleDA, GPUParticleMaterial) == 0x000048, "Member 'UKuroGPUParticleDA::GPUParticleMaterial' has a wrong offset!");
static_assert(offsetof(UKuroGPUParticleDA, StartFrame) == 0x000050, "Member 'UKuroGPUParticleDA::StartFrame' has a wrong offset!");
static_assert(offsetof(UKuroGPUParticleDA, EndFrame) == 0x000054, "Member 'UKuroGPUParticleDA::EndFrame' has a wrong offset!");
static_assert(offsetof(UKuroGPUParticleDA, ColorIntensity) == 0x000058, "Member 'UKuroGPUParticleDA::ColorIntensity' has a wrong offset!");
static_assert(offsetof(UKuroGPUParticleDA, VelocityScale) == 0x00005C, "Member 'UKuroGPUParticleDA::VelocityScale' has a wrong offset!");
static_assert(offsetof(UKuroGPUParticleDA, AspectRatio) == 0x000060, "Member 'UKuroGPUParticleDA::AspectRatio' has a wrong offset!");
static_assert(offsetof(UKuroGPUParticleDA, AllParticleInfos) == 0x000068, "Member 'UKuroGPUParticleDA::AllParticleInfos' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroGPUParticleSubsystem
// 0x0030 (0x0068 - 0x0038)
class UKuroGPUParticleSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_1913[0x30];                                    // 0x0038(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UKuroGPUParticleSubsystem* GetKuroGPUParticleSystem(class UWorld* InWorld);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroGPUParticleSubsystem">();
	}
	static class UKuroGPUParticleSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroGPUParticleSubsystem>();
	}
};
static_assert(alignof(UKuroGPUParticleSubsystem) == 0x000008, "Wrong alignment on UKuroGPUParticleSubsystem");
static_assert(sizeof(UKuroGPUParticleSubsystem) == 0x000068, "Wrong size on UKuroGPUParticleSubsystem");

// Class KuroRenderingRuntimeBPPlugin.KuroGrassInteractionSphereComponent
// 0x0000 (0x0220 - 0x0220)
class UKuroGrassInteractionSphereComponent final : public USceneComponent
{
public:
	float                                         Radius;                                            // 0x0218(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x021C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1914[0x3];                                     // 0x021D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroGrassInteractionSphereComponent">();
	}
	static class UKuroGrassInteractionSphereComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroGrassInteractionSphereComponent>();
	}
};
static_assert(alignof(UKuroGrassInteractionSphereComponent) == 0x000010, "Wrong alignment on UKuroGrassInteractionSphereComponent");
static_assert(sizeof(UKuroGrassInteractionSphereComponent) == 0x000220, "Wrong size on UKuroGrassInteractionSphereComponent");
static_assert(offsetof(UKuroGrassInteractionSphereComponent, Radius) == 0x000218, "Member 'UKuroGrassInteractionSphereComponent::Radius' has a wrong offset!");
static_assert(offsetof(UKuroGrassInteractionSphereComponent, bEnabled) == 0x00021C, "Member 'UKuroGrassInteractionSphereComponent::bEnabled' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroGrassInteractionWorldSubsystem
// 0x0008 (0x0040 - 0x0038)
class UKuroGrassInteractionWorldSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_1915[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroGrassInteractionWorldSubsystem">();
	}
	static class UKuroGrassInteractionWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroGrassInteractionWorldSubsystem>();
	}
};
static_assert(alignof(UKuroGrassInteractionWorldSubsystem) == 0x000008, "Wrong alignment on UKuroGrassInteractionWorldSubsystem");
static_assert(sizeof(UKuroGrassInteractionWorldSubsystem) == 0x000040, "Wrong size on UKuroGrassInteractionWorldSubsystem");

// Class KuroRenderingRuntimeBPPlugin.KuroHaloComponent
// 0x0030 (0x05C0 - 0x0590)
class UKuroHaloComponent final : public UStaticMeshComponent
{
public:
	FMulticastInlineDelegateProperty_             OnParameterChangedEvent;                           // 0x0590(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         HaloMinDrawDistance;                               // 0x05A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HaloMaxDrawDistance;                               // 0x05A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HaloMinDrawFadeRange;                              // 0x05A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HaloMaxDrawFadeRange;                              // 0x05AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightRadius;                                       // 0x05B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BoxExtent;                                         // 0x05B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1916[0x8];                                     // 0x05B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetRadius(float Radius);

	float GetLightRadius() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroHaloComponent">();
	}
	static class UKuroHaloComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroHaloComponent>();
	}
};
static_assert(alignof(UKuroHaloComponent) == 0x000010, "Wrong alignment on UKuroHaloComponent");
static_assert(sizeof(UKuroHaloComponent) == 0x0005C0, "Wrong size on UKuroHaloComponent");
static_assert(offsetof(UKuroHaloComponent, OnParameterChangedEvent) == 0x000590, "Member 'UKuroHaloComponent::OnParameterChangedEvent' has a wrong offset!");
static_assert(offsetof(UKuroHaloComponent, HaloMinDrawDistance) == 0x0005A0, "Member 'UKuroHaloComponent::HaloMinDrawDistance' has a wrong offset!");
static_assert(offsetof(UKuroHaloComponent, HaloMaxDrawDistance) == 0x0005A4, "Member 'UKuroHaloComponent::HaloMaxDrawDistance' has a wrong offset!");
static_assert(offsetof(UKuroHaloComponent, HaloMinDrawFadeRange) == 0x0005A8, "Member 'UKuroHaloComponent::HaloMinDrawFadeRange' has a wrong offset!");
static_assert(offsetof(UKuroHaloComponent, HaloMaxDrawFadeRange) == 0x0005AC, "Member 'UKuroHaloComponent::HaloMaxDrawFadeRange' has a wrong offset!");
static_assert(offsetof(UKuroHaloComponent, LightRadius) == 0x0005B0, "Member 'UKuroHaloComponent::LightRadius' has a wrong offset!");
static_assert(offsetof(UKuroHaloComponent, BoxExtent) == 0x0005B4, "Member 'UKuroHaloComponent::BoxExtent' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroHighResLandscapeActor
// 0x0008 (0x02B0 - 0x02A8)
class AKuroHighResLandscapeActor final : public AActor
{
public:
	bool                                          bIsEnable;                                         // 0x02A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseProxyEvent;                                    // 0x02A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1917[0x6];                                     // 0x02AA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetLandscapeComponentVisible(class ALandscapeStreamingProxy* Proxy, int32 ComponentIndex);
	bool IsEnabled();
	void OnHideLandscapeStreamingProxy(class ALandscapeStreamingProxy* Proxy);
	void OnProxyHide(class ALandscapeStreamingProxy* Proxy);
	void OnProxyShow(class ALandscapeStreamingProxy* Proxy);
	void OnShowLandscapeStreamingProxy(class ALandscapeStreamingProxy* Proxy);
	void SetLandscapeComponentVisible(class ALandscapeStreamingProxy* Proxy, int32 ComponentIndex, bool IsVisible);
	void UpdateLandscapeStatus(const TArray<class ALandscapeStreamingProxy*>& LowLandProxies, const TArray<class ALandscapeStreamingProxy*>& HighLandProxies);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroHighResLandscapeActor">();
	}
	static class AKuroHighResLandscapeActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroHighResLandscapeActor>();
	}
};
static_assert(alignof(AKuroHighResLandscapeActor) == 0x000008, "Wrong alignment on AKuroHighResLandscapeActor");
static_assert(sizeof(AKuroHighResLandscapeActor) == 0x0002B0, "Wrong size on AKuroHighResLandscapeActor");
static_assert(offsetof(AKuroHighResLandscapeActor, bIsEnable) == 0x0002A8, "Member 'AKuroHighResLandscapeActor::bIsEnable' has a wrong offset!");
static_assert(offsetof(AKuroHighResLandscapeActor, bUseProxyEvent) == 0x0002A9, "Member 'AKuroHighResLandscapeActor::bUseProxyEvent' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroLensFlare
// 0x0048 (0x0108 - 0x00C0)
class UKuroLensFlare final : public UActorComponent
{
public:
	TArray<struct FVector>                        Vertices;                                          // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 Triangles;                                         // 0x00D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector2D>                      UVs;                                               // 0x00E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLinearColor>                   VertexColor;                                       // 0x00F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UProceduralMeshComponent*               MeshComponent;                                     // 0x0100(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	struct FVector2D GetViewportSize();
	void Init(class UProceduralMeshComponent* InputMeshComponent);
	void InitVecticesData(int32 LensImageLengths);
	bool IsInit();
	bool IsViewportEnable();
	void SetVertsProperties(const struct FVector2D& ViewportScale, const int32 PrimityIndex, const struct FVector2D& UVCenter, const struct FVector2D& UVSize, const struct FVector2D& LensFlareScale, const float LensFlareOffset, const float LensFlareRotation, const struct FLinearColor& LensFlareTint, const struct FVector2D& LensFlareScreenPosition, const struct FVector2D& LensFlareDirection);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroLensFlare">();
	}
	static class UKuroLensFlare* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroLensFlare>();
	}
};
static_assert(alignof(UKuroLensFlare) == 0x000008, "Wrong alignment on UKuroLensFlare");
static_assert(sizeof(UKuroLensFlare) == 0x000108, "Wrong size on UKuroLensFlare");
static_assert(offsetof(UKuroLensFlare, Vertices) == 0x0000C0, "Member 'UKuroLensFlare::Vertices' has a wrong offset!");
static_assert(offsetof(UKuroLensFlare, Triangles) == 0x0000D0, "Member 'UKuroLensFlare::Triangles' has a wrong offset!");
static_assert(offsetof(UKuroLensFlare, UVs) == 0x0000E0, "Member 'UKuroLensFlare::UVs' has a wrong offset!");
static_assert(offsetof(UKuroLensFlare, VertexColor) == 0x0000F0, "Member 'UKuroLensFlare::VertexColor' has a wrong offset!");
static_assert(offsetof(UKuroLensFlare, MeshComponent) == 0x000100, "Member 'UKuroLensFlare::MeshComponent' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroLevelSequenceActor
// 0x0010 (0x0340 - 0x0330)
class AKuroLevelSequenceActor final : public ALevelSequenceActor
{
public:
	class FName                                   Key;                                               // 0x0330(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191A[0x4];                                     // 0x033C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroLevelSequenceActor">();
	}
	static class AKuroLevelSequenceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroLevelSequenceActor>();
	}
};
static_assert(alignof(AKuroLevelSequenceActor) == 0x000008, "Wrong alignment on AKuroLevelSequenceActor");
static_assert(sizeof(AKuroLevelSequenceActor) == 0x000340, "Wrong size on AKuroLevelSequenceActor");
static_assert(offsetof(AKuroLevelSequenceActor, Key) == 0x000330, "Member 'AKuroLevelSequenceActor::Key' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroLevelSequenceSubsystem
// 0x0070 (0x00A8 - 0x0038)
class UKuroLevelSequenceSubsystem final : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnLevelSequenceRegister;                           // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLevelSequenceUnRegister;                         // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_191B[0x50];                                    // 0x0058(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetAllLevelSequences(TArray<class AKuroLevelSequenceActor*>* InAllLevelSequences);
	class AKuroLevelSequenceActor* GetLevelSequence(const class FName& Key);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroLevelSequenceSubsystem">();
	}
	static class UKuroLevelSequenceSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroLevelSequenceSubsystem>();
	}
};
static_assert(alignof(UKuroLevelSequenceSubsystem) == 0x000008, "Wrong alignment on UKuroLevelSequenceSubsystem");
static_assert(sizeof(UKuroLevelSequenceSubsystem) == 0x0000A8, "Wrong size on UKuroLevelSequenceSubsystem");
static_assert(offsetof(UKuroLevelSequenceSubsystem, OnLevelSequenceRegister) == 0x000038, "Member 'UKuroLevelSequenceSubsystem::OnLevelSequenceRegister' has a wrong offset!");
static_assert(offsetof(UKuroLevelSequenceSubsystem, OnLevelSequenceUnRegister) == 0x000048, "Member 'UKuroLevelSequenceSubsystem::OnLevelSequenceUnRegister' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent
// 0x0028 (0x00E8 - 0x00C0)
class UKuroMaterialVariationComponent final : public UActorComponent
{
public:
	bool                                          bIsInitSuccess;                                    // 0x00C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSkeletalMeshType;                               // 0x00C1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191D[0x6];                                     // 0x00C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   ParentStaticMeshComp;                              // 0x00C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 ParentSkeletalMeshComp;                            // 0x00D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FKuroMaterialVariationRuntimeInfo> AllRuntimeMaterialInfo;                            // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	bool GetKeywordState(class FName PropertyName, int32 MaterialIndex);
	float GetMaterialFloat(class FName PropertyName, int32 MaterialIndex);
	struct FLinearColor GetMaterialLinearColor(class FName PropertyName, int32 MaterialIndex);
	class UTexture* GetMaterialTexture(class FName PropertyName, int32 MaterialIndex);
	bool InitWithSkeletalMeshComponent(class USkeletalMeshComponent* InSkeletalMeshComponent);
	bool InitWithStaticMeshComponent(class UStaticMeshComponent* InStaticMeshComponent);
	bool IsComponentValid();
	bool IsMaterialVariationDataValid(class UMeshComponent* CheckMeshComponent, const TArray<class UKuroMaterialVariationCollection*>& CheckCollection);
	void ReplaceMaterial(class UMaterialInterface* MatToReplace, int32 MaterialIndex);
	void RevertMaterial(int32 MaterialIndex);
	void RevertMaterialFloat(class FName PropertyName, int32 MaterialIndex);
	void RevertMaterialFloatAll(class FName PropertyName);
	void RevertMaterialLinearColor(class FName PropertyName, int32 MaterialIndex);
	void RevertMaterialLinearColorAll(class FName PropertyName);
	void RevertMaterialTexture(class FName PropertyName, int32 MaterialIndex);
	void RevertMaterialTextureAll(class FName PropertyName);
	void SetKeywordState(class FName Keyword, bool InIsEnable, int32 MaterialIndex);
	void SetKeywordStateAll(class FName Keyword, bool InIsEnable);
	void SetMaterialFloat(class FName PropertyName, float InValue, int32 MaterialIndex);
	void SetMaterialFloatAll(class FName PropertyName, float InValue);
	void SetMaterialLinearColor(class FName PropertyName, const struct FLinearColor& InValue, int32 MaterialIndex);
	void SetMaterialLinearColorAll(class FName PropertyName, const struct FLinearColor& InValue);
	void SetMaterialTexture(class FName PropertyName, class UTexture* InValue, int32 MaterialIndex);
	void SetMaterialTextureAll(class FName PropertyName, class UTexture* InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroMaterialVariationComponent">();
	}
	static class UKuroMaterialVariationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroMaterialVariationComponent>();
	}
};
static_assert(alignof(UKuroMaterialVariationComponent) == 0x000008, "Wrong alignment on UKuroMaterialVariationComponent");
static_assert(sizeof(UKuroMaterialVariationComponent) == 0x0000E8, "Wrong size on UKuroMaterialVariationComponent");
static_assert(offsetof(UKuroMaterialVariationComponent, bIsInitSuccess) == 0x0000C0, "Member 'UKuroMaterialVariationComponent::bIsInitSuccess' has a wrong offset!");
static_assert(offsetof(UKuroMaterialVariationComponent, bIsSkeletalMeshType) == 0x0000C1, "Member 'UKuroMaterialVariationComponent::bIsSkeletalMeshType' has a wrong offset!");
static_assert(offsetof(UKuroMaterialVariationComponent, ParentStaticMeshComp) == 0x0000C8, "Member 'UKuroMaterialVariationComponent::ParentStaticMeshComp' has a wrong offset!");
static_assert(offsetof(UKuroMaterialVariationComponent, ParentSkeletalMeshComp) == 0x0000D0, "Member 'UKuroMaterialVariationComponent::ParentSkeletalMeshComp' has a wrong offset!");
static_assert(offsetof(UKuroMaterialVariationComponent, AllRuntimeMaterialInfo) == 0x0000D8, "Member 'UKuroMaterialVariationComponent::AllRuntimeMaterialInfo' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroPDCloudPrefab
// 0x0140 (0x0178 - 0x0038)
class UKuroPDCloudPrefab : public UPrimaryDataAsset
{
public:
	struct FCloudParameters                       CloudTop;                                          // 0x0038(0x00C0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCloudCover                            CloudCover;                                        // 0x00F8(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPOICloudParameters                    CloudBigShape;                                     // 0x0100(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FMountainParameters                    Mountain;                                          // 0x0138(0x0001)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1928[0x7];                                     // 0x0139(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnomaliesParameters                   CloudAnomalies;                                    // 0x0140(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroPDCloudPrefab">();
	}
	static class UKuroPDCloudPrefab* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroPDCloudPrefab>();
	}
};
static_assert(alignof(UKuroPDCloudPrefab) == 0x000008, "Wrong alignment on UKuroPDCloudPrefab");
static_assert(sizeof(UKuroPDCloudPrefab) == 0x000178, "Wrong size on UKuroPDCloudPrefab");
static_assert(offsetof(UKuroPDCloudPrefab, CloudTop) == 0x000038, "Member 'UKuroPDCloudPrefab::CloudTop' has a wrong offset!");
static_assert(offsetof(UKuroPDCloudPrefab, CloudCover) == 0x0000F8, "Member 'UKuroPDCloudPrefab::CloudCover' has a wrong offset!");
static_assert(offsetof(UKuroPDCloudPrefab, CloudBigShape) == 0x000100, "Member 'UKuroPDCloudPrefab::CloudBigShape' has a wrong offset!");
static_assert(offsetof(UKuroPDCloudPrefab, Mountain) == 0x000138, "Member 'UKuroPDCloudPrefab::Mountain' has a wrong offset!");
static_assert(offsetof(UKuroPDCloudPrefab, CloudAnomalies) == 0x000140, "Member 'UKuroPDCloudPrefab::CloudAnomalies' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroPlayerPrefsSystem
// 0x0008 (0x0040 - 0x0038)
class UKuroPlayerPrefsSystem final : public UWorldSubsystem
{
public:
	class UKuroSaveGame*                          KuroSaveGame;                                      // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void DeleteAll();
	void DeleteKey(const class FString& Key);
	float GetFloat(const class FString& Key, float DefaultValue);
	int32 GetInt(const class FString& Key, int32 DefaultValue);
	class FString GetString(const class FString& Key, const class FString& DefaultValue);
	bool HasKey(const class FString& Key);
	void Save();
	void SetFloat(const class FString& Key, float Value);
	void SetInt(const class FString& Key, int32 Value);
	void SetString(const class FString& Key, const class FString& Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroPlayerPrefsSystem">();
	}
	static class UKuroPlayerPrefsSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroPlayerPrefsSystem>();
	}
};
static_assert(alignof(UKuroPlayerPrefsSystem) == 0x000008, "Wrong alignment on UKuroPlayerPrefsSystem");
static_assert(sizeof(UKuroPlayerPrefsSystem) == 0x000040, "Wrong size on UKuroPlayerPrefsSystem");
static_assert(offsetof(UKuroPlayerPrefsSystem, KuroSaveGame) == 0x000038, "Member 'UKuroPlayerPrefsSystem::KuroSaveGame' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroPostProcessComponent
// 0x09D0 (0x12E0 - 0x0910)
class UKuroPostProcessComponent final : public UPostProcessComponent
{
public:
	class UKuroWeatherDataAsset*                  WeatherDataAsset;                                  // 0x0908(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKuroTODData*                           PPTODDataAsset;                                    // 0x0910(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_192C[0x8];                                     // 0x0918(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroGISetting                         GISetting;                                         // 0x0920(0x0990)(Edit, BlueprintVisible, Interp, NativeAccessSpecifierPublic)
	class AVolume*                                ReferencedVolumeActor;                             // 0x12B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_192D[0x28];                                    // 0x12B8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PostModify();
	void SetPPTODDataAsset(class UKuroTODData* InPPTODDataAsset);
	void SetReferencedVolumeActor(class AVolume* InReferencedVolumeActor);
	void SetWeatherDataAsset(class UKuroWeatherDataAsset* InWeatherDataAsset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroPostProcessComponent">();
	}
	static class UKuroPostProcessComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroPostProcessComponent>();
	}
};
static_assert(alignof(UKuroPostProcessComponent) == 0x000010, "Wrong alignment on UKuroPostProcessComponent");
static_assert(sizeof(UKuroPostProcessComponent) == 0x0012E0, "Wrong size on UKuroPostProcessComponent");
static_assert(offsetof(UKuroPostProcessComponent, WeatherDataAsset) == 0x000908, "Member 'UKuroPostProcessComponent::WeatherDataAsset' has a wrong offset!");
static_assert(offsetof(UKuroPostProcessComponent, PPTODDataAsset) == 0x000910, "Member 'UKuroPostProcessComponent::PPTODDataAsset' has a wrong offset!");
static_assert(offsetof(UKuroPostProcessComponent, GISetting) == 0x000920, "Member 'UKuroPostProcessComponent::GISetting' has a wrong offset!");
static_assert(offsetof(UKuroPostProcessComponent, ReferencedVolumeActor) == 0x0012B0, "Member 'UKuroPostProcessComponent::ReferencedVolumeActor' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroPostProcessVolume
// 0x09C0 (0x13A0 - 0x09E0)
class AKuroPostProcessVolume final : public APostProcessVolume
{
public:
	class UKuroWeatherDataAsset*                  WeatherDataAsset;                                  // 0x09D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKuroTODData*                           PPTODDataAsset;                                    // 0x09E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_192E[0x8];                                     // 0x09E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroGISetting                         GISetting;                                         // 0x09F0(0x0990)(Edit, BlueprintVisible, Interp, NativeAccessSpecifierPublic)
	uint8                                         Pad_192F[0x20];                                    // 0x1380(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PostModify();
	void SetPPTODDataAsset(class UKuroTODData* InPPTODDataAsset);
	void SetWeatherDataAsset(class UKuroWeatherDataAsset* InWeatherDataAsset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroPostProcessVolume">();
	}
	static class AKuroPostProcessVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroPostProcessVolume>();
	}
};
static_assert(alignof(AKuroPostProcessVolume) == 0x000010, "Wrong alignment on AKuroPostProcessVolume");
static_assert(sizeof(AKuroPostProcessVolume) == 0x0013A0, "Wrong size on AKuroPostProcessVolume");
static_assert(offsetof(AKuroPostProcessVolume, WeatherDataAsset) == 0x0009D8, "Member 'AKuroPostProcessVolume::WeatherDataAsset' has a wrong offset!");
static_assert(offsetof(AKuroPostProcessVolume, PPTODDataAsset) == 0x0009E0, "Member 'AKuroPostProcessVolume::PPTODDataAsset' has a wrong offset!");
static_assert(offsetof(AKuroPostProcessVolume, GISetting) == 0x0009F0, "Member 'AKuroPostProcessVolume::GISetting' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroRainSettings
// 0x02D0 (0x0308 - 0x0038)
class UKuroRainSettings final : public UPrimaryDataAsset
{
public:
	struct FVector                                RainBoxSize;                                       // 0x0038(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1930[0x4];                                     // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            RainMesh;                                          // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             BoxCountPositive;                                  // 0x0050(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             BoxCountNegative;                                  // 0x005C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraOffsetSize;                                  // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleCameraOffsetY;                                // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        GravityWeightCurve;                                // 0x0070(0x0090)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        WindWeightCurve;                                   // 0x0100(0x0090)(Edit, NativeAccessSpecifierPublic)
	bool                                          RainDropSizeUseSpeed;                              // 0x0190(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1931[0x7];                                     // 0x0191(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveVector2D                     RaindropSizeCurve;                                 // 0x0198(0x0120)(Edit, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Material;                                          // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FKuroRainMaterialFloatParameter> MaterialFloatParameters_Density;                   // 0x02C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKuroRainMaterialColorParameter> MaterialColorParameters_Density;                   // 0x02D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKuroRainMaterialFloatParameter> MaterialFloatParameters_Speed;                     // 0x02E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKuroRainMaterialColorParameter> MaterialColorParameters_Speed;                     // 0x02F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         FramesIntervalUpdateParameters;                    // 0x0300(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FramesIntervalFixRainBoxes;                        // 0x0304(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroRainSettings">();
	}
	static class UKuroRainSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroRainSettings>();
	}
};
static_assert(alignof(UKuroRainSettings) == 0x000008, "Wrong alignment on UKuroRainSettings");
static_assert(sizeof(UKuroRainSettings) == 0x000308, "Wrong size on UKuroRainSettings");
static_assert(offsetof(UKuroRainSettings, RainBoxSize) == 0x000038, "Member 'UKuroRainSettings::RainBoxSize' has a wrong offset!");
static_assert(offsetof(UKuroRainSettings, RainMesh) == 0x000048, "Member 'UKuroRainSettings::RainMesh' has a wrong offset!");
static_assert(offsetof(UKuroRainSettings, BoxCountPositive) == 0x000050, "Member 'UKuroRainSettings::BoxCountPositive' has a wrong offset!");
static_assert(offsetof(UKuroRainSettings, BoxCountNegative) == 0x00005C, "Member 'UKuroRainSettings::BoxCountNegative' has a wrong offset!");
static_assert(offsetof(UKuroRainSettings, CameraOffsetSize) == 0x000068, "Member 'UKuroRainSettings::CameraOffsetSize' has a wrong offset!");
static_assert(offsetof(UKuroRainSettings, ScaleCameraOffsetY) == 0x00006C, "Member 'UKuroRainSettings::ScaleCameraOffsetY' has a wrong offset!");
static_assert(offsetof(UKuroRainSettings, GravityWeightCurve) == 0x000070, "Member 'UKuroRainSettings::GravityWeightCurve' has a wrong offset!");
static_assert(offsetof(UKuroRainSettings, WindWeightCurve) == 0x000100, "Member 'UKuroRainSettings::WindWeightCurve' has a wrong offset!");
static_assert(offsetof(UKuroRainSettings, RainDropSizeUseSpeed) == 0x000190, "Member 'UKuroRainSettings::RainDropSizeUseSpeed' has a wrong offset!");
static_assert(offsetof(UKuroRainSettings, RaindropSizeCurve) == 0x000198, "Member 'UKuroRainSettings::RaindropSizeCurve' has a wrong offset!");
static_assert(offsetof(UKuroRainSettings, Material) == 0x0002B8, "Member 'UKuroRainSettings::Material' has a wrong offset!");
static_assert(offsetof(UKuroRainSettings, MaterialFloatParameters_Density) == 0x0002C0, "Member 'UKuroRainSettings::MaterialFloatParameters_Density' has a wrong offset!");
static_assert(offsetof(UKuroRainSettings, MaterialColorParameters_Density) == 0x0002D0, "Member 'UKuroRainSettings::MaterialColorParameters_Density' has a wrong offset!");
static_assert(offsetof(UKuroRainSettings, MaterialFloatParameters_Speed) == 0x0002E0, "Member 'UKuroRainSettings::MaterialFloatParameters_Speed' has a wrong offset!");
static_assert(offsetof(UKuroRainSettings, MaterialColorParameters_Speed) == 0x0002F0, "Member 'UKuroRainSettings::MaterialColorParameters_Speed' has a wrong offset!");
static_assert(offsetof(UKuroRainSettings, FramesIntervalUpdateParameters) == 0x000300, "Member 'UKuroRainSettings::FramesIntervalUpdateParameters' has a wrong offset!");
static_assert(offsetof(UKuroRainSettings, FramesIntervalFixRainBoxes) == 0x000304, "Member 'UKuroRainSettings::FramesIntervalFixRainBoxes' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroRainActor
// 0x0190 (0x0438 - 0x02A8)
class AKuroRainActor final : public AActor
{
public:
	class UKuroRainSettings*                      Settings;                                          // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BasicGravity;                                      // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1932[0xD4];                                    // 0x02B4(0x00D4)(Fixing Size After Last Property [ Dumper-7 ])
	class UInstancedStaticMeshComponent*          MeshComp;                                          // 0x0388(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               DynamicMaterial;                                   // 0x0390(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, float>                      MaterialParameterOverrideFloat;                    // 0x0398(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FLinearColor>        MaterialParameterOverrideColor;                    // 0x03E8(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	class UMaterialInstanceDynamic* GetDynamicMaterial();
	bool GetIsInit();
	void SetCurrentRain(float InDensity, float InGravity, float InWindX, float InWindY, float InWindZ);
	void SetMaterialParameterOverrideColor(class FName Param_Name, const struct FLinearColor& Value);
	void SetMaterialParameterOverrideFloat(class FName Param_Name, float Value);
	void SetupRainConfig();
	void Update(float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroRainActor">();
	}
	static class AKuroRainActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroRainActor>();
	}
};
static_assert(alignof(AKuroRainActor) == 0x000008, "Wrong alignment on AKuroRainActor");
static_assert(sizeof(AKuroRainActor) == 0x000438, "Wrong size on AKuroRainActor");
static_assert(offsetof(AKuroRainActor, Settings) == 0x0002A8, "Member 'AKuroRainActor::Settings' has a wrong offset!");
static_assert(offsetof(AKuroRainActor, BasicGravity) == 0x0002B0, "Member 'AKuroRainActor::BasicGravity' has a wrong offset!");
static_assert(offsetof(AKuroRainActor, MeshComp) == 0x000388, "Member 'AKuroRainActor::MeshComp' has a wrong offset!");
static_assert(offsetof(AKuroRainActor, DynamicMaterial) == 0x000390, "Member 'AKuroRainActor::DynamicMaterial' has a wrong offset!");
static_assert(offsetof(AKuroRainActor, MaterialParameterOverrideFloat) == 0x000398, "Member 'AKuroRainActor::MaterialParameterOverrideFloat' has a wrong offset!");
static_assert(offsetof(AKuroRainActor, MaterialParameterOverrideColor) == 0x0003E8, "Member 'AKuroRainActor::MaterialParameterOverrideColor' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroRainActorV2
// 0x0008 (0x02C0 - 0x02B8)
class AKuroRainActorV2 final : public AKuroEditorTickActor
{
public:
	uint8                                         Pad_1933[0x8];                                     // 0x02B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UKuroRainComponent* AddRainComponent(TSubclassOf<class UKuroRainComponent> ClassType);
	void DisableRain();
	void EnableRain();
	void GetPlayerOrEditorCameraLocation(struct FVector* OutLocation);
	void RemoveRainComponent(class UKuroRainComponent* Comp);
	void SetCameraFrustum(class UKuroRainComponent* Comp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroRainActorV2">();
	}
	static class AKuroRainActorV2* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroRainActorV2>();
	}
};
static_assert(alignof(AKuroRainActorV2) == 0x000008, "Wrong alignment on AKuroRainActorV2");
static_assert(sizeof(AKuroRainActorV2) == 0x0002C0, "Wrong size on AKuroRainActorV2");

// Class KuroRenderingRuntimeBPPlugin.KuroRainComponent
// 0x0010 (0x0230 - 0x0220)
#pragma pack(push, 0x1)
class alignas(0x10) UKuroRainComponent : public USceneComponent
{
public:
	uint8                                         Pad_1934[0x9];                                     // 0x0218(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAutoPlay;                                         // 0x0221(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1935[0x6];                                     // 0x0222(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 AddArraySpawner(int32 RenderIndex);
	int32 AddCustomRandomByNormalizedAgeProcessor(const struct FKuroCurveFloat& Curve, int32 Param_Index);
	int32 AddCustomRandomByVelocityProcessor(const struct FKuroCurveFloat& Curve, int32 Param_Index);
	int32 AddCustomRandomSetProcessor(float Value, int32 Param_Index);
	int32 AddCycleBoxProcessor(const struct FVector& Min, const struct FVector& Max, bool bKillOnZ);
	int32 AddDragProcessor(float DragSize);
	int32 AddLinearForceProcessor(const struct FVector& Force);
	int32 AddRandomSpawner(int32 RenderIndex);
	int32 AddVectorFieldForceProcessor(class UVectorFieldStatic* InVectorField, const struct FVector& InPosScale, const struct FVector& InMoveSpeed, float InForceSize);
	int32 AddWindProcessor(const struct FVector& WindVelocity);
	struct FVector GetCycleBoxProcessor_Max(int32 ProcessorID);
	struct FVector GetCycleBoxProcessor_Min(int32 ProcessorID);
	float GetDragProcessor_DragSize(int32 ProcessorID);
	int32 GetEmitterDataNum();
	bool GetIsPlaying();
	struct FVector GetLinearForceProcessor_Force(int32 ProcessorID);
	struct FVector GetWindProcessor_WindVelocity(int32 ProcessorID);
	void Init();
	void PreSolveRainParticles(float DeltaSeconds);
	void SetArraySpawnerBasic(int32 SpawnerID, int32 ArraySize, float ArrayLength, float SpawnTimeWiggle, float SpawnPositionWiggle, float LifeTimeMin, float LifeTimeMax, float ScaleMin, float ScaleMax, float BaseMassMin, float BaseMassMax);
	void SetArraySpawnerRuntime(int32 SpawnerID, const struct FVector& SpawnCenter, float SpawnRate, const struct FVector& VelocityMin, const struct FVector& VelocityMax);
	void SetCustomRandomByNormalizedAgeProcessor(int32 ProcessorID, const struct FKuroCurveFloat& Curve, int32 Param_Index);
	void SetCustomRandomByVelocityProcessor(int32 ProcessorID, const struct FKuroCurveFloat& Curve, int32 Param_Index);
	void SetCustomRandomSetProcessor(int32 ProcessorID, float Value, int32 Param_Index);
	void SetCycleBoxProcessor(int32 ProcessorID, const struct FVector& Min, const struct FVector& Max);
	void SetDragProcessor(int32 ProcessorID, float DragSize);
	void SetLifeTimeDilation(float Dilation);
	void SetLinearForceProcessor(int32 ProcessorID, const struct FVector& Force);
	void SetRandomSpawnerBasic(int32 SpawnerID, float SpawnInnerRadius, float SpawnOuterRadius, float LifeTimeMin, float LifeTimeMax, float ScaleMin, float ScaleMax, float BaseMassMin, float BaseMassMax);
	void SetRandomSpawnerRuntime(int32 SpawnerID, const struct FVector& SpawnCenter, float SpawnRate, const struct FVector& VelocityMin, const struct FVector& VelocityMax);
	void SetTimeDilation(float Dilation);
	void Setup(const TArray<class UStaticMesh*>& Meshes, const TArray<class UMaterialInterface*>& Materials);
	void SetupRainEmitters();
	void SetVectorFieldForceProcessor_Others(int32 ProcessorID, const struct FVector& InPosScale, const struct FVector& InMoveSpeed, float InForceSize);
	void SetVectorFieldForceProcessor_VectorField(int32 ProcessorID, class UVectorFieldStatic* InVectorField);
	void SetWindProcessor(int32 ProcessorID, const struct FVector& WindVelocity);
	void Start();
	void Stop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroRainComponent">();
	}
	static class UKuroRainComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroRainComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UKuroRainComponent) == 0x000010, "Wrong alignment on UKuroRainComponent");
static_assert(sizeof(UKuroRainComponent) == 0x000230, "Wrong size on UKuroRainComponent");
static_assert(offsetof(UKuroRainComponent, bAutoPlay) == 0x000221, "Member 'UKuroRainComponent::bAutoPlay' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroRainManager
// 0x00C0 (0x00F0 - 0x0030)
class UKuroRainManager final : public UObject
{
public:
	uint8                                         Pad_193C[0xC0];                                    // 0x0030(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroRainManager">();
	}
	static class UKuroRainManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroRainManager>();
	}
};
static_assert(alignof(UKuroRainManager) == 0x000008, "Wrong alignment on UKuroRainManager");
static_assert(sizeof(UKuroRainManager) == 0x0000F0, "Wrong size on UKuroRainManager");

// Class KuroRenderingRuntimeBPPlugin.KuroRenderingAsyncTaskSystem
// 0x0058 (0x0090 - 0x0038)
class UKuroRenderingAsyncTaskSystem final : public UEngineSubsystem
{
public:
	uint8                                         Pad_193D[0x58];                                    // 0x0038(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroRenderingAsyncTaskSystem">();
	}
	static class UKuroRenderingAsyncTaskSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroRenderingAsyncTaskSystem>();
	}
};
static_assert(alignof(UKuroRenderingAsyncTaskSystem) == 0x000008, "Wrong alignment on UKuroRenderingAsyncTaskSystem");
static_assert(sizeof(UKuroRenderingAsyncTaskSystem) == 0x000090, "Wrong size on UKuroRenderingAsyncTaskSystem");

// Class KuroRenderingRuntimeBPPlugin.KuroRenderingPropertyDebugger
// 0x0048 (0x0078 - 0x0030)
class UKuroRenderingPropertyDebugger final : public UObject
{
public:
	class UWorld*                                 World;                                             // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UObject*>                        ObjectRefs;                                        // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_193E[0x30];                                    // 0x0048(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroRenderingPropertyDebugger">();
	}
	static class UKuroRenderingPropertyDebugger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroRenderingPropertyDebugger>();
	}
};
static_assert(alignof(UKuroRenderingPropertyDebugger) == 0x000008, "Wrong alignment on UKuroRenderingPropertyDebugger");
static_assert(sizeof(UKuroRenderingPropertyDebugger) == 0x000078, "Wrong size on UKuroRenderingPropertyDebugger");
static_assert(offsetof(UKuroRenderingPropertyDebugger, World) == 0x000030, "Member 'UKuroRenderingPropertyDebugger::World' has a wrong offset!");
static_assert(offsetof(UKuroRenderingPropertyDebugger, ObjectRefs) == 0x000038, "Member 'UKuroRenderingPropertyDebugger::ObjectRefs' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroRenderingRuntimeBPPluginBPLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddAdditionalClusteredStuff(class UObject* WorldContextObject, class UClusteredStuffDataAsset* Asset);
	static int32 AddPostprocessMaterial(class UObject* WorldContextObject, class UMaterialInterface* Material, float Priority);
	static bool AddWeatherDataType(class UObject* WorldContextObject, class FName Identifier, class UClass* ClassType);
	static void ClearObjectFlags(class UObject* Object, int32 Param_Flags);
	static void ClipboardCopy_EditorOnly(const class FString& Str);
	static void ClipboardPaste_EditorOnly(class FString* Dest);
	static void CopyKuroCharColorGroupArray(const TArray<struct FKuroCharMaterialControllerColorGroup>& Target, const TArray<struct FKuroCurveLinearColor>& Start, const TArray<struct FKuroCurveLinearColor>& Loop, const TArray<struct FKuroCurveLinearColor>& End);
	static void CopyKuroCharColorParameter(struct FKuroCharMaterialControllerColorParameter* Target, const class FName& ParameterName, const struct FKuroCurveLinearColor& ParameterValue);
	static void CopyKuroCharFloatGroup(struct FKuroCharMaterialControllerFloatGroup* Target, const struct FKuroCurveFloat& Start, const struct FKuroCurveFloat& Loop, const struct FKuroCurveFloat& End);
	static void CopyKuroCharFloatGroupArray(const TArray<struct FKuroCharMaterialControllerFloatGroup>& Target, const TArray<struct FKuroCurveFloat>& Start, const TArray<struct FKuroCurveFloat>& Loop, const TArray<struct FKuroCurveFloat>& End);
	static void CopyKuroCharFloatParameter(struct FKuroCharMaterialControllerFloatParameter* Target, const class FName& ParameterName, const struct FKuroCurveFloat& ParameterValue);
	static void CopyKuroCharLinearColorGroup(struct FKuroCharMaterialControllerColorGroup* Target, const struct FKuroCurveLinearColor& Start, const struct FKuroCurveLinearColor& Loop, const struct FKuroCurveLinearColor& End);
	static class AActor* CreateGITransientActor(class UObject* WorldContextObject, class FName IdName, bool bAttachToPlayer, bool bAttachToEditorCamera, class FName EditorFolderPath);
	static void DeleteAll(const class UObject* WorldContextObject);
	static void DeleteKey(const class UObject* WorldContextObject, const class FString& Key);
	static void DestroyGITransientActor(class UObject* WorldContextObject, class FName IdName);
	static void FreezeWorldLevelStreaming(const class UObject* WorldContextObject);
	static void GetActorForwardVectorRef(class AActor* Actor, struct FVector* RefForwardVector);
	static void GetActorForwardVectorRefXYZ(class AActor* Actor, float* X, float* Y, float* Z);
	static void GetActorLocationRef(class AActor* Actor, struct FVector* RefLocation);
	static void GetActorLocationRefXYZ(class AActor* Actor, float* X, float* Y, float* Z);
	static class AActor* GetActorOfClass(const class UObject* WorldContextObject, const TSubclassOf<class AActor> ActorClass);
	static void GetActorsInLevel(const class ULevel* InLevel, TSubclassOf<class AActor> ActorClass, TArray<class AActor*>* OutActors);
	static float GetAndAddCurveFloatSampleTask(int64 LastFrameHandle, const struct FKuroCurveFloat& Curve, float Time, float Default, int64* OutHandle);
	static struct FVector2D GetAndroidRawResolution();
	static TArray<struct FAssetData> GetAssetsByPath(class FName PackagePath, bool bRecursive, bool bIncludeOnlyOnDiskAssets);
	static struct FQuat GetBoneDirection(class USkeletalMeshComponent* SkeletalMeshComponent, class FName BoneName);
	static void GetCacheCameraInfo(class APlayerCameraManager* Owner, struct FMinimalViewInfo* Inout);
	static bool GetCaveOrRoomState(const class UObject* WorldContextObject, class FString* EnClosetDataLayer, class FString* EnCloseSubDataLayer, ECaveOrRoomLoadType* OutLoadType, float* OutLoadCoef);
	static int32 GetCharacterSectionCount(class USkeletalMesh* Mesh);
	static TArray<int32> GetCharacterSectionInfo(class USkeletalMesh* Mesh, int32 SectionIndex);
	static int32 GetCharacterSectionMaterialIndex(class USkeletalMesh* SkeletalMesh, int32 SectionIndex);
	static struct FLinearColor GetColorFromGroup(struct FKuroCharMaterialControllerColorGroup* Target, const float Factor, const int32 Type);
	static class UPhysicalMaterial* GetComponentPhysicalMaterial(class UPrimitiveComponent* Component);
	static class FString GetCPUBrand();
	static int32 GetCPUCores();
	static int32 GetCPUCoresIncludingHyperthreads();
	static int32 GetCPUFrequency();
	static float GetCVarFloat(const class FString& CVarKey);
	static int32 GetDeviceHardwareLevel();
	static class FString GetDeviceProfileBaseProfileName();
	static int32 GetDeviceProfileDeviceScore();
	static class FString GetDeviceProfileDeviceType();
	static class FString GetDeviceProfileProfileName();
	static float GetFloat(const class UObject* WorldContextObject, const class FString& Key, float DefaultValue);
	static float GetFloatGromGroup(struct FKuroCharMaterialControllerFloatGroup* Target, const float Factor, const int32 Type);
	static struct FVector2D GetGameResolution();
	static struct FVector2D GetGameViewportSize();
	static class AActor* GetGITransientActor(class UObject* WorldContextObject, class FName IdName);
	static class AActor* GetGlobalGIActor(const class UObject* WorldContextObject);
	static int32 GetInt(const class UObject* WorldContextObject, const class FString& Key, int32 DefaultValue);
	static class UKuroLandscapeParametersData* GetKuroLandscapeParametersDataAsset();
	static class ULevel* GetLevel(const class UWorld* World);
	static TArray<class AActor*> GetLevelActors(class ULevel* InLevel);
	static bool GetLevelEditorCameraLocationAndForward(const class UObject* WorldContextObject, struct FVector* Position, struct FRotator* Rotation);
	static bool GetLevelEditorViewPortSize(const class UObject* WorldContextObject, struct FVector2D* ViewPortSize);
	static void GetNiagaraParticleCount(class UNiagaraComponent* NiagaraComponent, int32* ActiveEmitters, int32* ActiveParticles);
	static int32 GetObjectMaskedFlags(class UObject* Object, int32 Mask);
	static int32 GetOverlappingBoxCountForAllFoliageActors(const class UObject* WorldContextObject, const class UFoliageType* FoliageType, const struct FBox& Box, int32 Max);
	static void GetPcLightCullParameters(class ULightComponent* LightComponent, float* LightMinDistance, float* LightMaxDistance, float* LightMinFade, float* LightMaxFade);
	static int32 GetPhysicalGBRam();
	static bool GetPostProcessGIDataDebugInfo(const class UObject* WorldContextObject, const struct FVector& WorldPosition, TArray<struct FPostprocessGIDebugInfo>* OutDAResult, TArray<struct FPostprocessGIDebugInfo>* OutOverrideResult);
	static bool GetPostProcessGIDataDebugNames(const class UObject* WorldContextObject, TArray<class FName>* OutDANames);
	static bool GetPostProcessGIDataNames(const class UObject* WorldContextObject, const struct FVector& WorldPosition, TArray<class FString>* OutDANames);
	static class FString GetRHIDeviceName();
	static class FString GetRHIDriverDate();
	static class FString GetRHIDriverVersion();
	static class FString GetRHIName();
	static class FString GetRHIVendorName();
	static void GetSceneColorContainLGUIShotNow();
	static void GetSceneColorShotNow();
	static class AActor* GetSceneInteractionLevelActor(class ULevel* InLevel);
	static int32 GetSkeletalMaterialCount(class USkeletalMesh* Skel);
	static class UMaterialInterface* GetSkeletalMaterialInterface(class USkeletalMesh* Skel, int32 MaterialIndex);
	static class FString GetSkeletalMaterialSlotName(class USkeletalMesh* Skel, int32 MaterialIndex);
	static bool GetSpaceStateByPosition(const class UObject* WorldContextObject, const struct FVector& InPoisition, ECaveOrRoom* OutSpaceType, class FString* OutEnClosetDataLayer, class FString* OutEnCloseSubDataLayer);
	static bool GetStreamingCells(const class UObject* WorldContextObject, const struct FWorldPartitionStreamingQuerySource& QuerySource, TArray<struct FWorldPartitionRuntimeSpatialHashCell>* OutCells);
	static class FString GetString(const class UObject* WorldContextObject, const class FString& Key, const class FString& DefaultValue);
	static class UWorldSubsystem* GetSubsystem(const class UObject* WorldContextObject, TSubclassOf<class UWorldSubsystem> WorldSubsystemClass);
	static void GetVectorParameterValueRef(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, class FName ParameterName, struct FLinearColor* RefLinearColor);
	static void GetVectorParameterValueRefRGBA(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, class FName ParameterName, float* RefLinearColorR, float* RefLinearColorG, float* RefLinearColorB, float* RefLinearColorA);
	static class UObject* GetWeatherDataRef(class UObject* WorldContextObject, class FName Identifier);
	static class UWorld* GetWorld(const class UObject* WorldContextObject);
	static EKuroFeatureLevel GetWorldFeatureLevel(const class UObject* WorldContextObject);
	static class UWorldPartition* GetWorldPartition(const class UObject* WorldContextObject);
	static TArray<class FString> GetWorldPartitionAllDataLayerNames(const class UObject* WorldContextObject);
	static void GetWorldPartitionDataLayerNameByLabel(const class UObject* WorldContextObject, const class FName& InDataLayerLabel, class FName* OutDataLayerNamme);
	static struct FVector GetWorldRebaseAbsoluePos(const class UObject* WorldContextObject, const struct FVector& InCurPos);
	static struct FVector GetWorldRebaseRelativePos(const class UObject* WorldContextObject, const struct FVector& InCurPos);
	static class AWorldSettings* GetWorldSetting(const class UObject* WorldContextObject);
	static EBP_EWorldType GetWorldType(const class UObject* WorldContextObject);
	static void GetWpWorldBound(const class UObject* WorldContextObject, struct FVector* BoundMin, struct FVector* BoundMax);
	static void HasAllObjectFlags(class UObject* Object, int32 Param_Flags);
	static void HasAnyObjectFlags(class UObject* Object, int32 Param_Flags);
	static bool HasKey(const class UObject* WorldContextObject, const class FString& Key);
	static struct FLinearColor HSP2RGB(const struct FLinearColor& Hsp);
	static bool IsCurrentPlatformPC(class AActor* Actor);
	static bool IsDistanceCull(const class UObject* WorldContextObject, class UNiagaraEffectType* EffectType, const struct FVector& Location);
	static bool IsEditorOnlyActor(const class AActor* Actor);
	static bool IsNiagaraComplete(class UNiagaraComponent* NiagaraComponent);
	static bool IsParticleComplete(class UParticleSystemComponent* ParticleSystemComponent);
	static bool IsPositionInCaveOrRoom(const class UObject* WorldContextObject, const struct FVector& InPoisition);
	static bool IsPostprocessMaterialActive(class UObject* WorldContextObject, int32 Handle);
	static bool IsSupportsMetalFx();
	static bool IsUsingNotSeparateCache();
	static bool IsUsingParallaxCorrect();
	static bool IsWorldPartitionDataLayerEnable(const class UObject* WorldContextObject, class FName DataLayerName);
	static bool IsWorldPartitionWorld(class UObject* WorldContextObject);
	static bool IsWpPlayerInCaveOrRoom(const class UObject* WorldContextObject);
	static void KuroMarkPackageDirty(class UObject* Object);
	static class UActorSequencePlayer* MakeSequencePlayer(class UActorSequenceComponent* SequenceComponent, const struct FMovieSceneSequencePlaybackSettings& PlaybackSettings);
	static bool MaterialHasParameter_EditorOnly(class UMaterialInterface* MaterialInterface, const class FString& ParameterName);
	static void MessageNotify_EditorOnly(const class FText& Message, const class FName Tile);
	static void MoveCurveColorValueToOtherTime(class UCurveLinearColor* Curve, float SrcTime, float TargetTime);
	static void MoveCurveFloatValueToOtherTime(class UCurveFloat* Curve, float SrcTime, float TargetTime);
	static struct FVector2D PackLinearColorRGBToVector2D(const struct FLinearColor& Color);
	static bool ProjectWorldToScreenWithLevelEditorViewPort(const class UObject* WorldContextObject, const struct FVector& WorldPosition, struct FVector4* Result);
	static bool ProjectWorldToScreenWithLevelEditorViewPortFloatRef(const class UObject* WorldContextObject, const struct FVector& WorldPosition, float* ResultX, float* ResultY, float* ResultZ, float* ResultW);
	static void ReleaseGetSceneColorShotBefore();
	static void RemoveAdditionalClusteredStuff(class UObject* WorldContextObject, class UClusteredStuffDataAsset* Asset);
	static void RemovePostprocessMaterial(class UObject* WorldContextObject, int32 Handle);
	static void RerunConstructionScripts(class AActor* Actor);
	static void ResetParticleSystem(class UParticleSystemComponent* ParticleSystemComponent);
	static void ResumeSomeWeatherAfterTeleport(class UObject* WorldContextObject);
	static struct FLinearColor RGB2HSP(const struct FLinearColor& Rgb);
	static void Save(const class UObject* WorldContextObject);
	static void SetActorUISceneRendering(class AActor* Actor, bool IsUISceneRendering);
	static void SetClusteredStuffVisible(class UObject* WorldContextObject, bool Visible);
	static void SetCVarFloat(const class FString& CVarKey, float Value);
	static void SetCVarInt32(const class FString& CVarKey, int32 Value);
	static void SetFloat(const class UObject* WorldContextObject, const class FString& Key, float Value);
	static void SetGITransientActorAttachment(class UObject* WorldContextObject, class FName IdName, bool bAttachToPlayer, bool bAttachToEditorCamera);
	static bool SetGlobalGITime(const class UObject* WorldContextObject, float Time);
	static void SetInt(const class UObject* WorldContextObject, const class FString& Key, int32 Value);
	static void SetIntsDataToRenderTarget(class UTextureRenderTarget2D* TextureRenderTarget, const TArray<int32>& WriteData);
	static void SetIsUsingInCaveOrIndoorShadow(const class UObject* WorldContextObject, bool IsUsing, float MobileCSMDistanceInCave, float MobileCSMDistanceOutCave);
	static bool SetLevelEditorCameraLocation(const class UObject* WorldContextObject, const struct FVector& Position);
	static void SetNiagaraSkeletalMeshComponentWithoutWarning(class UNiagaraComponent* NiagaraSystem, const class FString& OverrideName, class USkeletalMeshComponent* SkeletalMeshComponent);
	static void SetNiagaraSplineComponent(class UNiagaraComponent* NiagaraSystem, const class FString& OverrideName, class USplineComponent* SplineComponent);
	static void SetObjectFlags(class UObject* Object, int32 Param_Flags);
	static void SetSceneKuroMainPlayerLocation(const class UObject* WorldContextObject, int32 PlayerIndex);
	static void SetSceneKuroViewCenter(const class UObject* WorldContextObject, const struct FVector& Location);
	static void SetSceneRenderingState(class UObject* WorldContextObject, bool bSceneVisible);
	static void SetString(const class UObject* WorldContextObject, const class FString& Key, const class FString& Value);
	static void SetSunLensflareEnabled(class UObject* WorldContextObject, bool bEnabled);
	static void SetTransformLocationInArray(TArray<struct FTransform>* TransformArray, int32 Param_Index, const struct FVector& Location);
	static void SetupVolumeSize(class AVolume* Volume, const struct FBox& Bounds);
	static void SetUsingInCaveOrIndoorShadow(class UDirectionalLightComponent* LightComp, bool IsUsing, float MobileCSMDistanceOld, float MobileCSMDistanceNew);
	static void SetVectorParameterValueRef(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, class FName ParameterName, struct FLinearColor* RefLinearColor);
	static void SetWorldOrgin(const class UObject* WorldContextObject, const struct FVector& InNewOrigin);
	static void SetWorldPartitionDataLayerState(const class UObject* WorldContextObject, class FName DataLayerName, bool IsActivate);
	static void SetWorldPartitionStreamingEnable(const class UObject* WorldContextObject, bool bStreamingEnable);
	static void SortStringArray(const TArray<class FString>& InStringArray, const ESearchCase SearchCase, const bool Descending);
	static class AActor* SpawnActorFromClass(const class UObject* WorldContextObject, const TSubclassOf<class AActor> ActorClass, const struct FTransform& SpawnTransform, ESpawnActorCollisionHandlingMethod CollisionHandlingOverride, class AActor* Owner, class APawn* Instigator, bool bTemporaryEditorActor);
	static class AActor* SpawnTransientActor(class UObject* WorldContextObject, const class FName& Param_Name, const class FName& FolderPath);
	static void StopSomeWeatherBeforeTeleport(class UObject* WorldContextObject);
	static void UnFreezeWorldLevelStreaming(const class UObject* WorldContextObject);
	static struct FLinearColor UnpackVector2DToLinearColorRGB(const struct FVector2D& Vector2D);
	static void UpdateEffectTransform(const bool ForceUpdate, class USceneComponent* SceneComponent, const struct FKuroCurveVector& LocationCurve, const struct FKuroCurveVector& RotationCurve, const struct FKuroCurveVector& ScaleCurve, const float Time);
	static void UpdateEffectTransformLocation(const bool ForceUpdate, class USceneComponent* SceneComponent, const struct FKuroCurveVector& LocationCurve, const float Time);
	static void UpdateFoliageDataLayer(const class UObject* WorldContextObject, const int32 InMobileLevel);
	static void UpdateOrAddCurveColorValue(class UCurveLinearColor* Curve, float InTime, const struct FLinearColor& InValue);
	static void UpdateOrAddCurveFloatValue(class UCurveFloat* Curve, float InTime, float InValue);
	static void WpBeginAdjustLoadRange(const class UObject* WorldContextObject, float InAdjustValue, ECaveOrRoomLoadType InLoadType, bool bUseCustomCoef);
	static void WpBeginEnterCaveOrRoom(const class UObject* WorldContextObject, const class FName& EncloseDataLayer, const class FName& EncloseSubDataLayer);
	static void WpBeginLeaveCaveOrRoom(const class UObject* WorldContextObject, const class FName& EncloseDataLayer, const class FName& EncloseSubDataLayer);
	static void WpCancelAdjustLoadRange(const class UObject* WorldContextObject);
	static void WpEnterCaveOrRoom(const class UObject* WorldContextObject, const class FName& EncloseDataLayer, const class FName& EncloseSubDataLayer, float InAdjustValue, ECaveOrRoomLoadType LoadType, bool bUseCustomCoef);
	static void WpLeaveCaveOrRoom(const class UObject* WorldContextObject, const class FName& EncloseDataLayer, const class FName& EncloseSubDataLayer);
	static void WpPEnterCaveOrRoom(const class UObject* WorldContextObject, const class FName& EncloseDataLayer, const class FName& EncloseSubDataLayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroRenderingRuntimeBPPluginBPLibrary">();
	}
	static class UKuroRenderingRuntimeBPPluginBPLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroRenderingRuntimeBPPluginBPLibrary>();
	}
};
static_assert(alignof(UKuroRenderingRuntimeBPPluginBPLibrary) == 0x000008, "Wrong alignment on UKuroRenderingRuntimeBPPluginBPLibrary");
static_assert(sizeof(UKuroRenderingRuntimeBPPluginBPLibrary) == 0x000030, "Wrong size on UKuroRenderingRuntimeBPPluginBPLibrary");

// Class KuroRenderingRuntimeBPPlugin.KuroRenderQualitySettingVolume
// 0x0030 (0x0310 - 0x02E0)
class AKuroRenderQualitySettingVolume final : public AVolume
{
public:
	uint8                                         Pad_19A0[0x28];                                    // 0x02E0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UKuroLocalRenderQualitySetting*         LocalRenderQualitySettingDataAsset;                // 0x0308(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroRenderQualitySettingVolume">();
	}
	static class AKuroRenderQualitySettingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroRenderQualitySettingVolume>();
	}
};
static_assert(alignof(AKuroRenderQualitySettingVolume) == 0x000008, "Wrong alignment on AKuroRenderQualitySettingVolume");
static_assert(sizeof(AKuroRenderQualitySettingVolume) == 0x000310, "Wrong size on AKuroRenderQualitySettingVolume");
static_assert(offsetof(AKuroRenderQualitySettingVolume, LocalRenderQualitySettingDataAsset) == 0x000308, "Member 'AKuroRenderQualitySettingVolume::LocalRenderQualitySettingDataAsset' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroLocalRenderQualitySetting
// 0x0030 (0x0068 - 0x0038)
class UKuroLocalRenderQualitySetting final : public UDataAsset
{
public:
	uint8                                         bOverride_MobileLocalRenderSettingIndexLowest : 1; // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MobileLocalRenderSettingIndexLow : 1;    // 0x0038(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MobileLocalRenderSettingIndexMedium : 1; // 0x0038(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MobileLocalRenderSettingIndexHigh : 1;   // 0x0038(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19A1[0x3];                                     // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          EnableResetLocalRenderSettingMobile;               // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19A2[0x3];                                     // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MobileLocalRenderSettingIndexLowest;               // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MobileLocalRenderSettingIndexLow;                  // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MobileLocalRenderSettingIndexMedium;               // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MobileLocalRenderSettingIndexHigh;                 // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_PCLocalRenderSettingIndexLowest : 1;     // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_PCLocalRenderSettingIndexLow : 1;        // 0x0050(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_PCLocalRenderSettingIndexMedium : 1;     // 0x0050(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_PCLocalRenderSettingIndexHigh : 1;       // 0x0050(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19A3[0x3];                                     // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          EnableResetLocalRenderSettingPC;                   // 0x0054(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19A4[0x3];                                     // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PCLocalRenderSettingIndexLowest;                   // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PCLocalRenderSettingIndexLow;                      // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PCLocalRenderSettingIndexMedium;                   // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PCLocalRenderSettingIndexHigh;                     // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroLocalRenderQualitySetting">();
	}
	static class UKuroLocalRenderQualitySetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroLocalRenderQualitySetting>();
	}
};
static_assert(alignof(UKuroLocalRenderQualitySetting) == 0x000008, "Wrong alignment on UKuroLocalRenderQualitySetting");
static_assert(sizeof(UKuroLocalRenderQualitySetting) == 0x000068, "Wrong size on UKuroLocalRenderQualitySetting");
static_assert(offsetof(UKuroLocalRenderQualitySetting, EnableResetLocalRenderSettingMobile) == 0x00003C, "Member 'UKuroLocalRenderQualitySetting::EnableResetLocalRenderSettingMobile' has a wrong offset!");
static_assert(offsetof(UKuroLocalRenderQualitySetting, MobileLocalRenderSettingIndexLowest) == 0x000040, "Member 'UKuroLocalRenderQualitySetting::MobileLocalRenderSettingIndexLowest' has a wrong offset!");
static_assert(offsetof(UKuroLocalRenderQualitySetting, MobileLocalRenderSettingIndexLow) == 0x000044, "Member 'UKuroLocalRenderQualitySetting::MobileLocalRenderSettingIndexLow' has a wrong offset!");
static_assert(offsetof(UKuroLocalRenderQualitySetting, MobileLocalRenderSettingIndexMedium) == 0x000048, "Member 'UKuroLocalRenderQualitySetting::MobileLocalRenderSettingIndexMedium' has a wrong offset!");
static_assert(offsetof(UKuroLocalRenderQualitySetting, MobileLocalRenderSettingIndexHigh) == 0x00004C, "Member 'UKuroLocalRenderQualitySetting::MobileLocalRenderSettingIndexHigh' has a wrong offset!");
static_assert(offsetof(UKuroLocalRenderQualitySetting, EnableResetLocalRenderSettingPC) == 0x000054, "Member 'UKuroLocalRenderQualitySetting::EnableResetLocalRenderSettingPC' has a wrong offset!");
static_assert(offsetof(UKuroLocalRenderQualitySetting, PCLocalRenderSettingIndexLowest) == 0x000058, "Member 'UKuroLocalRenderQualitySetting::PCLocalRenderSettingIndexLowest' has a wrong offset!");
static_assert(offsetof(UKuroLocalRenderQualitySetting, PCLocalRenderSettingIndexLow) == 0x00005C, "Member 'UKuroLocalRenderQualitySetting::PCLocalRenderSettingIndexLow' has a wrong offset!");
static_assert(offsetof(UKuroLocalRenderQualitySetting, PCLocalRenderSettingIndexMedium) == 0x000060, "Member 'UKuroLocalRenderQualitySetting::PCLocalRenderSettingIndexMedium' has a wrong offset!");
static_assert(offsetof(UKuroLocalRenderQualitySetting, PCLocalRenderSettingIndexHigh) == 0x000064, "Member 'UKuroLocalRenderQualitySetting::PCLocalRenderSettingIndexHigh' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroSceneInteractionActor
// 0x0000 (0x02A8 - 0x02A8)
class AKuroSceneInteractionActor final : public AActor
{
public:
	void OnSetState(EKuroSceneInteractionState TargetState, const bool NeedTransition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroSceneInteractionActor">();
	}
	static class AKuroSceneInteractionActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroSceneInteractionActor>();
	}
};
static_assert(alignof(AKuroSceneInteractionActor) == 0x000008, "Wrong alignment on AKuroSceneInteractionActor");
static_assert(sizeof(AKuroSceneInteractionActor) == 0x0002A8, "Wrong size on AKuroSceneInteractionActor");

// Class KuroRenderingRuntimeBPPlugin.KuroSceneInteractionInfo
// 0x0048 (0x0078 - 0x0030)
class UKuroSceneInteractionInfo final : public UObject
{
public:
	struct FVector                                Location;                                          // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x003C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 LevelName;                                         // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HandleId;                                          // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroSceneInteractionState                    CurrentState;                                      // 0x005C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LoadingLevelComplete;                              // 0x005D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19A5[0x2];                                     // 0x005E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class AKuroSceneInteractionActor*             InteractionActor;                                  // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelStreamingDynamic*                 LevelStreaming;                                    // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19A6[0x8];                                     // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelShown();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroSceneInteractionInfo">();
	}
	static class UKuroSceneInteractionInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroSceneInteractionInfo>();
	}
};
static_assert(alignof(UKuroSceneInteractionInfo) == 0x000008, "Wrong alignment on UKuroSceneInteractionInfo");
static_assert(sizeof(UKuroSceneInteractionInfo) == 0x000078, "Wrong size on UKuroSceneInteractionInfo");
static_assert(offsetof(UKuroSceneInteractionInfo, Location) == 0x000030, "Member 'UKuroSceneInteractionInfo::Location' has a wrong offset!");
static_assert(offsetof(UKuroSceneInteractionInfo, Rotation) == 0x00003C, "Member 'UKuroSceneInteractionInfo::Rotation' has a wrong offset!");
static_assert(offsetof(UKuroSceneInteractionInfo, LevelName) == 0x000048, "Member 'UKuroSceneInteractionInfo::LevelName' has a wrong offset!");
static_assert(offsetof(UKuroSceneInteractionInfo, HandleId) == 0x000058, "Member 'UKuroSceneInteractionInfo::HandleId' has a wrong offset!");
static_assert(offsetof(UKuroSceneInteractionInfo, CurrentState) == 0x00005C, "Member 'UKuroSceneInteractionInfo::CurrentState' has a wrong offset!");
static_assert(offsetof(UKuroSceneInteractionInfo, LoadingLevelComplete) == 0x00005D, "Member 'UKuroSceneInteractionInfo::LoadingLevelComplete' has a wrong offset!");
static_assert(offsetof(UKuroSceneInteractionInfo, InteractionActor) == 0x000060, "Member 'UKuroSceneInteractionInfo::InteractionActor' has a wrong offset!");
static_assert(offsetof(UKuroSceneInteractionInfo, LevelStreaming) == 0x000068, "Member 'UKuroSceneInteractionInfo::LevelStreaming' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroSplitTextureStreamerSettings
// 0x0020 (0x0058 - 0x0038)
class UKuroSplitTextureStreamerSettings final : public UPrimaryDataAsset
{
public:
	TArray<TSoftObjectPtr<class UTexture2D>>      SplitTextureReferences;                            // 0x0038(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         SideCellNum;                                       // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SizePerCell;                                       // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              StartWorldPosition;                                // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroSplitTextureStreamerSettings">();
	}
	static class UKuroSplitTextureStreamerSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroSplitTextureStreamerSettings>();
	}
};
static_assert(alignof(UKuroSplitTextureStreamerSettings) == 0x000008, "Wrong alignment on UKuroSplitTextureStreamerSettings");
static_assert(sizeof(UKuroSplitTextureStreamerSettings) == 0x000058, "Wrong size on UKuroSplitTextureStreamerSettings");
static_assert(offsetof(UKuroSplitTextureStreamerSettings, SplitTextureReferences) == 0x000038, "Member 'UKuroSplitTextureStreamerSettings::SplitTextureReferences' has a wrong offset!");
static_assert(offsetof(UKuroSplitTextureStreamerSettings, SideCellNum) == 0x000048, "Member 'UKuroSplitTextureStreamerSettings::SideCellNum' has a wrong offset!");
static_assert(offsetof(UKuroSplitTextureStreamerSettings, SizePerCell) == 0x00004C, "Member 'UKuroSplitTextureStreamerSettings::SizePerCell' has a wrong offset!");
static_assert(offsetof(UKuroSplitTextureStreamerSettings, StartWorldPosition) == 0x000050, "Member 'UKuroSplitTextureStreamerSettings::StartWorldPosition' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.SplitTextureStreamerDebugActor
// 0x0070 (0x0318 - 0x02A8)
class ASplitTextureStreamerDebugActor final : public AActor
{
public:
	class USceneComponent*                        SceneComponent;                                    // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKuroSplitTextureStreamerSettings*      StreamerSettings;                                  // 0x02B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoadNumPerSide;                                    // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19A7[0x4];                                     // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        LoadedTextures;                                    // 0x02C0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_19A8[0x48];                                    // 0x02D0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SplitTextureStreamerDebugActor">();
	}
	static class ASplitTextureStreamerDebugActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASplitTextureStreamerDebugActor>();
	}
};
static_assert(alignof(ASplitTextureStreamerDebugActor) == 0x000008, "Wrong alignment on ASplitTextureStreamerDebugActor");
static_assert(sizeof(ASplitTextureStreamerDebugActor) == 0x000318, "Wrong size on ASplitTextureStreamerDebugActor");
static_assert(offsetof(ASplitTextureStreamerDebugActor, SceneComponent) == 0x0002A8, "Member 'ASplitTextureStreamerDebugActor::SceneComponent' has a wrong offset!");
static_assert(offsetof(ASplitTextureStreamerDebugActor, StreamerSettings) == 0x0002B0, "Member 'ASplitTextureStreamerDebugActor::StreamerSettings' has a wrong offset!");
static_assert(offsetof(ASplitTextureStreamerDebugActor, LoadNumPerSide) == 0x0002B8, "Member 'ASplitTextureStreamerDebugActor::LoadNumPerSide' has a wrong offset!");
static_assert(offsetof(ASplitTextureStreamerDebugActor, LoadedTextures) == 0x0002C0, "Member 'ASplitTextureStreamerDebugActor::LoadedTextures' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.SunLensFlareConfig
// 0x0030 (0x0068 - 0x0038)
class USunLensFlareConfig : public UPrimaryDataAsset
{
public:
	class UStaticMesh*                            StaticMeshGhost;                                   // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     MaterialGhost;                                     // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            StaticMeshHalo;                                    // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     MaterialHalo;                                      // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            StaticMeshGlare;                                   // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     MaterialGlare;                                     // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SunLensFlareConfig">();
	}
	static class USunLensFlareConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<USunLensFlareConfig>();
	}
};
static_assert(alignof(USunLensFlareConfig) == 0x000008, "Wrong alignment on USunLensFlareConfig");
static_assert(sizeof(USunLensFlareConfig) == 0x000068, "Wrong size on USunLensFlareConfig");
static_assert(offsetof(USunLensFlareConfig, StaticMeshGhost) == 0x000038, "Member 'USunLensFlareConfig::StaticMeshGhost' has a wrong offset!");
static_assert(offsetof(USunLensFlareConfig, MaterialGhost) == 0x000040, "Member 'USunLensFlareConfig::MaterialGhost' has a wrong offset!");
static_assert(offsetof(USunLensFlareConfig, StaticMeshHalo) == 0x000048, "Member 'USunLensFlareConfig::StaticMeshHalo' has a wrong offset!");
static_assert(offsetof(USunLensFlareConfig, MaterialHalo) == 0x000050, "Member 'USunLensFlareConfig::MaterialHalo' has a wrong offset!");
static_assert(offsetof(USunLensFlareConfig, StaticMeshGlare) == 0x000058, "Member 'USunLensFlareConfig::StaticMeshGlare' has a wrong offset!");
static_assert(offsetof(USunLensFlareConfig, MaterialGlare) == 0x000060, "Member 'USunLensFlareConfig::MaterialGlare' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroSuperFarFogConfig
// 0x0020 (0x0058 - 0x0038)
class UKuroSuperFarFogConfig final : public UPrimaryDataAsset
{
public:
	TArray<struct FKuroSuperFarFogLayer>          Layers;                                            // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         MinDistance;                                       // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MobileDistanceScale;                               // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19A9[0x4];                                     // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroSuperFarFogConfig">();
	}
	static class UKuroSuperFarFogConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroSuperFarFogConfig>();
	}
};
static_assert(alignof(UKuroSuperFarFogConfig) == 0x000008, "Wrong alignment on UKuroSuperFarFogConfig");
static_assert(sizeof(UKuroSuperFarFogConfig) == 0x000058, "Wrong size on UKuroSuperFarFogConfig");
static_assert(offsetof(UKuroSuperFarFogConfig, Layers) == 0x000038, "Member 'UKuroSuperFarFogConfig::Layers' has a wrong offset!");
static_assert(offsetof(UKuroSuperFarFogConfig, MinDistance) == 0x000048, "Member 'UKuroSuperFarFogConfig::MinDistance' has a wrong offset!");
static_assert(offsetof(UKuroSuperFarFogConfig, MaxDistance) == 0x00004C, "Member 'UKuroSuperFarFogConfig::MaxDistance' has a wrong offset!");
static_assert(offsetof(UKuroSuperFarFogConfig, MobileDistanceScale) == 0x000050, "Member 'UKuroSuperFarFogConfig::MobileDistanceScale' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroSuperFarFog
// 0x0020 (0x02C8 - 0x02A8)
class AKuroSuperFarFog final : public AActor
{
public:
	class UStaticMeshComponent*                   FogMeshComponent;                                  // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UKuroSuperFarFogConfig*                 Config;                                            // 0x02B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19AA[0x10];                                    // 0x02B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Update(float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroSuperFarFog">();
	}
	static class AKuroSuperFarFog* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroSuperFarFog>();
	}
};
static_assert(alignof(AKuroSuperFarFog) == 0x000008, "Wrong alignment on AKuroSuperFarFog");
static_assert(sizeof(AKuroSuperFarFog) == 0x0002C8, "Wrong size on AKuroSuperFarFog");
static_assert(offsetof(AKuroSuperFarFog, FogMeshComponent) == 0x0002A8, "Member 'AKuroSuperFarFog::FogMeshComponent' has a wrong offset!");
static_assert(offsetof(AKuroSuperFarFog, Config) == 0x0002B0, "Member 'AKuroSuperFarFog::Config' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroTrailDrawerComponent
// 0x0000 (0x0220 - 0x0220)
class UKuroTrailDrawerComponent final : public USceneComponent
{
public:
	int32                                         KuroIndex;                                         // 0x0218(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, DuplicateTransient, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShouldTick;                                        // 0x021C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnDrawerBegin();
	void OnDrawerEnd(const EEndPlayReason EndPlayReason);
	void OnDrawerTick(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroTrailDrawerComponent">();
	}
	static class UKuroTrailDrawerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroTrailDrawerComponent>();
	}
};
static_assert(alignof(UKuroTrailDrawerComponent) == 0x000010, "Wrong alignment on UKuroTrailDrawerComponent");
static_assert(sizeof(UKuroTrailDrawerComponent) == 0x000220, "Wrong size on UKuroTrailDrawerComponent");
static_assert(offsetof(UKuroTrailDrawerComponent, KuroIndex) == 0x000218, "Member 'UKuroTrailDrawerComponent::KuroIndex' has a wrong offset!");
static_assert(offsetof(UKuroTrailDrawerComponent, ShouldTick) == 0x00021C, "Member 'UKuroTrailDrawerComponent::ShouldTick' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroTrailSensorComponent
// 0x0010 (0x0230 - 0x0220)
class UKuroTrailSensorComponent final : public USceneComponent
{
public:
	float                                         TickTimeInterval;                                  // 0x0218(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KuroIndex;                                         // 0x021C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, DuplicateTransient, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19AB[0x10];                                    // 0x0220(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSensorBegin();
	void OnSensorEnd(const EEndPlayReason EndPlayReason);
	void OnSensorTick(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroTrailSensorComponent">();
	}
	static class UKuroTrailSensorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroTrailSensorComponent>();
	}
};
static_assert(alignof(UKuroTrailSensorComponent) == 0x000010, "Wrong alignment on UKuroTrailSensorComponent");
static_assert(sizeof(UKuroTrailSensorComponent) == 0x000230, "Wrong size on UKuroTrailSensorComponent");
static_assert(offsetof(UKuroTrailSensorComponent, TickTimeInterval) == 0x000218, "Member 'UKuroTrailSensorComponent::TickTimeInterval' has a wrong offset!");
static_assert(offsetof(UKuroTrailSensorComponent, KuroIndex) == 0x00021C, "Member 'UKuroTrailSensorComponent::KuroIndex' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroTrailSystem
// 0x0050 (0x0088 - 0x0038)
class UKuroTrailSystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_19AC[0x8];                                     // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bTickEnabled : 1;                                  // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19AD[0x47];                                    // 0x0041(0x0047)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UKuroTrailSystem* GetKuroTrailSystem(class UWorld* InWorld);

	TArray<class UKuroTrailDrawerComponent*> GetTrailDrawerInRadius(const struct FVector& InWorldPosition, float Radius);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroTrailSystem">();
	}
	static class UKuroTrailSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroTrailSystem>();
	}
};
static_assert(alignof(UKuroTrailSystem) == 0x000008, "Wrong alignment on UKuroTrailSystem");
static_assert(sizeof(UKuroTrailSystem) == 0x000088, "Wrong size on UKuroTrailSystem");

// Class KuroRenderingRuntimeBPPlugin.KuroUiSceneRootActor
// 0x0000 (0x02A8 - 0x02A8)
class AKuroUiSceneRootActor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroUiSceneRootActor">();
	}
	static class AKuroUiSceneRootActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroUiSceneRootActor>();
	}
};
static_assert(alignof(AKuroUiSceneRootActor) == 0x000008, "Wrong alignment on AKuroUiSceneRootActor");
static_assert(sizeof(AKuroUiSceneRootActor) == 0x0002A8, "Wrong size on AKuroUiSceneRootActor");

// Class KuroRenderingRuntimeBPPlugin.KuroUiSceneInfo
// 0x0050 (0x0080 - 0x0030)
class UKuroUiSceneInfo final : public UObject
{
public:
	struct FVector                                Location;                                          // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19AE[0x4];                                     // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LevelName;                                         // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OptionalLevelName;                                 // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLoaded;                                          // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsVisible;                                         // 0x0061(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroUiSceneLoadingState                      CurrentState;                                      // 0x0062(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19AF[0x5];                                     // 0x0063(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class AKuroUiSceneRootActor*                  RootActor;                                         // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelStreamingDynamic*                 LevelStreaming;                                    // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWorld*                                 World;                                             // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Destroy();
	void Init(class ULevelStreamingDynamic* InLevelStreaming, class FString* InLevelName, class FString* OptionalName, struct FVector* InLocation, class UWorld* InWorld);
	void OnLevelInVisible();
	void OnLevelLoad();
	void OnLevelVisible();
	void SetLevelVisible(bool InIsVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroUiSceneInfo">();
	}
	static class UKuroUiSceneInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroUiSceneInfo>();
	}
};
static_assert(alignof(UKuroUiSceneInfo) == 0x000008, "Wrong alignment on UKuroUiSceneInfo");
static_assert(sizeof(UKuroUiSceneInfo) == 0x000080, "Wrong size on UKuroUiSceneInfo");
static_assert(offsetof(UKuroUiSceneInfo, Location) == 0x000030, "Member 'UKuroUiSceneInfo::Location' has a wrong offset!");
static_assert(offsetof(UKuroUiSceneInfo, LevelName) == 0x000040, "Member 'UKuroUiSceneInfo::LevelName' has a wrong offset!");
static_assert(offsetof(UKuroUiSceneInfo, OptionalLevelName) == 0x000050, "Member 'UKuroUiSceneInfo::OptionalLevelName' has a wrong offset!");
static_assert(offsetof(UKuroUiSceneInfo, IsLoaded) == 0x000060, "Member 'UKuroUiSceneInfo::IsLoaded' has a wrong offset!");
static_assert(offsetof(UKuroUiSceneInfo, IsVisible) == 0x000061, "Member 'UKuroUiSceneInfo::IsVisible' has a wrong offset!");
static_assert(offsetof(UKuroUiSceneInfo, CurrentState) == 0x000062, "Member 'UKuroUiSceneInfo::CurrentState' has a wrong offset!");
static_assert(offsetof(UKuroUiSceneInfo, RootActor) == 0x000068, "Member 'UKuroUiSceneInfo::RootActor' has a wrong offset!");
static_assert(offsetof(UKuroUiSceneInfo, LevelStreaming) == 0x000070, "Member 'UKuroUiSceneInfo::LevelStreaming' has a wrong offset!");
static_assert(offsetof(UKuroUiSceneInfo, World) == 0x000078, "Member 'UKuroUiSceneInfo::World' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroUiSceneSystem
// 0x0110 (0x0148 - 0x0038)
class UKuroUiSceneSystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_19B1[0x8];                                     // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(const class FString& ScenePath)> OnKuroUiSceneLoadComplete;                         // 0x0040(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(const class FString& ScenePath)> OnKuroUiSceneUnLoadComplete;                       // 0x0068(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(const class FString& ScenePath)> OnKuroUiSceneVisibleComplete;                      // 0x0090(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(const class FString& ScenePath)> OnKuroUiSceneInVisibleComplete;                    // 0x00B8(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TMap<class FString, class UKuroUiSceneInfo*>  AllStreamingLevelInfo;                             // 0x00E0(0x0050)(Edit, NativeAccessSpecifierPrivate)
	class FString                                 CurrentShowScenePath;                              // 0x0130(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         LevelLoadingCount;                                 // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         LastGlobalGiActorId;                               // 0x0144(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UKuroUiSceneSystem* GetKuroUiSceneSystem(class UWorld* InWorld);

	bool EndUiSceneRendering();
	class FString GetCurrentUiSceneRenderingSceneName();
	EKuroUiSceneLoadingState GetUiSceneLoadingState(const class FString& ScenePath);
	class AKuroUiSceneRootActor* GetUiSceneRootActor(const class FString& ScenePath);
	TMap<class FString, EKuroUiSceneLoadingState> GetUiSceneStates();
	struct FVector GetUiSceneWorldPositionOffset(const class FString& ScenePath);
	void InvokeSceneVisible(const class FString& ScenePath);
	void PreloadUiScene(const class FString& ScenePath, const struct FVector& WorldPositionOffset);
	bool StartUiSceneRendering(const class FString& ScenePath);
	bool UnloadUiScene(const class FString& ScenePath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroUiSceneSystem">();
	}
	static class UKuroUiSceneSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroUiSceneSystem>();
	}
};
static_assert(alignof(UKuroUiSceneSystem) == 0x000008, "Wrong alignment on UKuroUiSceneSystem");
static_assert(sizeof(UKuroUiSceneSystem) == 0x000148, "Wrong size on UKuroUiSceneSystem");
static_assert(offsetof(UKuroUiSceneSystem, OnKuroUiSceneLoadComplete) == 0x000040, "Member 'UKuroUiSceneSystem::OnKuroUiSceneLoadComplete' has a wrong offset!");
static_assert(offsetof(UKuroUiSceneSystem, OnKuroUiSceneUnLoadComplete) == 0x000068, "Member 'UKuroUiSceneSystem::OnKuroUiSceneUnLoadComplete' has a wrong offset!");
static_assert(offsetof(UKuroUiSceneSystem, OnKuroUiSceneVisibleComplete) == 0x000090, "Member 'UKuroUiSceneSystem::OnKuroUiSceneVisibleComplete' has a wrong offset!");
static_assert(offsetof(UKuroUiSceneSystem, OnKuroUiSceneInVisibleComplete) == 0x0000B8, "Member 'UKuroUiSceneSystem::OnKuroUiSceneInVisibleComplete' has a wrong offset!");
static_assert(offsetof(UKuroUiSceneSystem, AllStreamingLevelInfo) == 0x0000E0, "Member 'UKuroUiSceneSystem::AllStreamingLevelInfo' has a wrong offset!");
static_assert(offsetof(UKuroUiSceneSystem, CurrentShowScenePath) == 0x000130, "Member 'UKuroUiSceneSystem::CurrentShowScenePath' has a wrong offset!");
static_assert(offsetof(UKuroUiSceneSystem, LevelLoadingCount) == 0x000140, "Member 'UKuroUiSceneSystem::LevelLoadingCount' has a wrong offset!");
static_assert(offsetof(UKuroUiSceneSystem, LastGlobalGiActorId) == 0x000144, "Member 'UKuroUiSceneSystem::LastGlobalGiActorId' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroWorldInfo
// 0x0070 (0x0318 - 0x02A8)
class AKuroWorldInfo final : public AInfo
{
public:
	struct FKuroLandscapeInfo                     M_LandscapeInfo;                                   // 0x02A8(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_19B7[0x8];                                     // 0x0300(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKuroStreamingLevelInfo>        M_StreamingLevelInfoList;                          // 0x0308(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	static class AKuroWorldInfo* BP_GetInstance(const class UObject* WorldContextObject, bool AutoCreate);

	int32 GetSLInfo(const class FName& PackageName, struct FKuroStreamingLevelInfo* LandscapeInfo);

	void GetLandscapeInfo(struct FKuroLandscapeInfo* LandscapeInfo) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroWorldInfo">();
	}
	static class AKuroWorldInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroWorldInfo>();
	}
};
static_assert(alignof(AKuroWorldInfo) == 0x000008, "Wrong alignment on AKuroWorldInfo");
static_assert(sizeof(AKuroWorldInfo) == 0x000318, "Wrong size on AKuroWorldInfo");
static_assert(offsetof(AKuroWorldInfo, M_LandscapeInfo) == 0x0002A8, "Member 'AKuroWorldInfo::M_LandscapeInfo' has a wrong offset!");
static_assert(offsetof(AKuroWorldInfo, M_StreamingLevelInfoList) == 0x000308, "Member 'AKuroWorldInfo::M_StreamingLevelInfoList' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroWorldPartitionPreviewManager
// 0x0000 (0x0030 - 0x0030)
class UKuroWorldPartitionPreviewManager final : public UObject
{
public:
	void AddPreviewActorType(TSubclassOf<class AActor> Param_Class);
	void RemovePreviewActorType(TSubclassOf<class AActor> Param_Class);
	void SetPreviewMobile(bool PreviewMobile);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroWorldPartitionPreviewManager">();
	}
	static class UKuroWorldPartitionPreviewManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroWorldPartitionPreviewManager>();
	}
};
static_assert(alignof(UKuroWorldPartitionPreviewManager) == 0x000008, "Wrong alignment on UKuroWorldPartitionPreviewManager");
static_assert(sizeof(UKuroWorldPartitionPreviewManager) == 0x000030, "Wrong size on UKuroWorldPartitionPreviewManager");

// Class KuroRenderingRuntimeBPPlugin.KuroWorldRainComponentSpawnConfig
// 0x0010 (0x0048 - 0x0038)
class UKuroWorldRainComponentSpawnConfig final : public UPrimaryDataAsset
{
public:
	TArray<struct FKuroWorldRainSpawnInfo>        Spawners;                                          // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroWorldRainComponentSpawnConfig">();
	}
	static class UKuroWorldRainComponentSpawnConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroWorldRainComponentSpawnConfig>();
	}
};
static_assert(alignof(UKuroWorldRainComponentSpawnConfig) == 0x000008, "Wrong alignment on UKuroWorldRainComponentSpawnConfig");
static_assert(sizeof(UKuroWorldRainComponentSpawnConfig) == 0x000048, "Wrong size on UKuroWorldRainComponentSpawnConfig");
static_assert(offsetof(UKuroWorldRainComponentSpawnConfig, Spawners) == 0x000038, "Member 'UKuroWorldRainComponentSpawnConfig::Spawners' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroWorldRainComponentPhysicsConfig
// 0x0450 (0x0488 - 0x0038)
class UKuroWorldRainComponentPhysicsConfig final : public UPrimaryDataAsset
{
public:
	struct FKuroCurveFloat                        SpawnScaleCurve;                                   // 0x0038(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         BaseWindSize;                                      // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19B9[0x4];                                     // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        WindCurve;                                         // 0x00D0(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVector                                BaseGravitySize;                                   // 0x0160(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19BA[0x4];                                     // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        GravityCurve;                                      // 0x0170(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         BaseDragSize;                                      // 0x0200(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19BB[0x4];                                     // 0x0204(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        DragCurve;                                         // 0x0208(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UVectorFieldStatic*                     VectorField;                                       // 0x0298(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VectorFieldBaseSize;                               // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19BC[0x4];                                     // 0x02A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        VectorFieldCurve;                                  // 0x02A8(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVector                                VectorFieldScale;                                  // 0x0338(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VectorFieldMoveDirection;                          // 0x0344(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        VectorFieldMoveSpeedCurve;                         // 0x0350(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVector                                CycleBoxHalfSize;                                  // 0x03E0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CycleBoxZBias;                                     // 0x03EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        TimeDilationCurve;                                 // 0x03F0(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         LifeTimeDilationOnDeath;                           // 0x0480(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19BD[0x4];                                     // 0x0484(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroWorldRainComponentPhysicsConfig">();
	}
	static class UKuroWorldRainComponentPhysicsConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroWorldRainComponentPhysicsConfig>();
	}
};
static_assert(alignof(UKuroWorldRainComponentPhysicsConfig) == 0x000008, "Wrong alignment on UKuroWorldRainComponentPhysicsConfig");
static_assert(sizeof(UKuroWorldRainComponentPhysicsConfig) == 0x000488, "Wrong size on UKuroWorldRainComponentPhysicsConfig");
static_assert(offsetof(UKuroWorldRainComponentPhysicsConfig, SpawnScaleCurve) == 0x000038, "Member 'UKuroWorldRainComponentPhysicsConfig::SpawnScaleCurve' has a wrong offset!");
static_assert(offsetof(UKuroWorldRainComponentPhysicsConfig, BaseWindSize) == 0x0000C8, "Member 'UKuroWorldRainComponentPhysicsConfig::BaseWindSize' has a wrong offset!");
static_assert(offsetof(UKuroWorldRainComponentPhysicsConfig, WindCurve) == 0x0000D0, "Member 'UKuroWorldRainComponentPhysicsConfig::WindCurve' has a wrong offset!");
static_assert(offsetof(UKuroWorldRainComponentPhysicsConfig, BaseGravitySize) == 0x000160, "Member 'UKuroWorldRainComponentPhysicsConfig::BaseGravitySize' has a wrong offset!");
static_assert(offsetof(UKuroWorldRainComponentPhysicsConfig, GravityCurve) == 0x000170, "Member 'UKuroWorldRainComponentPhysicsConfig::GravityCurve' has a wrong offset!");
static_assert(offsetof(UKuroWorldRainComponentPhysicsConfig, BaseDragSize) == 0x000200, "Member 'UKuroWorldRainComponentPhysicsConfig::BaseDragSize' has a wrong offset!");
static_assert(offsetof(UKuroWorldRainComponentPhysicsConfig, DragCurve) == 0x000208, "Member 'UKuroWorldRainComponentPhysicsConfig::DragCurve' has a wrong offset!");
static_assert(offsetof(UKuroWorldRainComponentPhysicsConfig, VectorField) == 0x000298, "Member 'UKuroWorldRainComponentPhysicsConfig::VectorField' has a wrong offset!");
static_assert(offsetof(UKuroWorldRainComponentPhysicsConfig, VectorFieldBaseSize) == 0x0002A0, "Member 'UKuroWorldRainComponentPhysicsConfig::VectorFieldBaseSize' has a wrong offset!");
static_assert(offsetof(UKuroWorldRainComponentPhysicsConfig, VectorFieldCurve) == 0x0002A8, "Member 'UKuroWorldRainComponentPhysicsConfig::VectorFieldCurve' has a wrong offset!");
static_assert(offsetof(UKuroWorldRainComponentPhysicsConfig, VectorFieldScale) == 0x000338, "Member 'UKuroWorldRainComponentPhysicsConfig::VectorFieldScale' has a wrong offset!");
static_assert(offsetof(UKuroWorldRainComponentPhysicsConfig, VectorFieldMoveDirection) == 0x000344, "Member 'UKuroWorldRainComponentPhysicsConfig::VectorFieldMoveDirection' has a wrong offset!");
static_assert(offsetof(UKuroWorldRainComponentPhysicsConfig, VectorFieldMoveSpeedCurve) == 0x000350, "Member 'UKuroWorldRainComponentPhysicsConfig::VectorFieldMoveSpeedCurve' has a wrong offset!");
static_assert(offsetof(UKuroWorldRainComponentPhysicsConfig, CycleBoxHalfSize) == 0x0003E0, "Member 'UKuroWorldRainComponentPhysicsConfig::CycleBoxHalfSize' has a wrong offset!");
static_assert(offsetof(UKuroWorldRainComponentPhysicsConfig, CycleBoxZBias) == 0x0003EC, "Member 'UKuroWorldRainComponentPhysicsConfig::CycleBoxZBias' has a wrong offset!");
static_assert(offsetof(UKuroWorldRainComponentPhysicsConfig, TimeDilationCurve) == 0x0003F0, "Member 'UKuroWorldRainComponentPhysicsConfig::TimeDilationCurve' has a wrong offset!");
static_assert(offsetof(UKuroWorldRainComponentPhysicsConfig, LifeTimeDilationOnDeath) == 0x000480, "Member 'UKuroWorldRainComponentPhysicsConfig::LifeTimeDilationOnDeath' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroWorldRainComponentCustomDataConfig
// 0x0010 (0x0048 - 0x0038)
class UKuroWorldRainComponentCustomDataConfig final : public UPrimaryDataAsset
{
public:
	TArray<struct FKuroWorldRainCustomData>       CustomRandoms;                                     // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroWorldRainComponentCustomDataConfig">();
	}
	static class UKuroWorldRainComponentCustomDataConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroWorldRainComponentCustomDataConfig>();
	}
};
static_assert(alignof(UKuroWorldRainComponentCustomDataConfig) == 0x000008, "Wrong alignment on UKuroWorldRainComponentCustomDataConfig");
static_assert(sizeof(UKuroWorldRainComponentCustomDataConfig) == 0x000048, "Wrong size on UKuroWorldRainComponentCustomDataConfig");
static_assert(offsetof(UKuroWorldRainComponentCustomDataConfig, CustomRandoms) == 0x000038, "Member 'UKuroWorldRainComponentCustomDataConfig::CustomRandoms' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroWorldRainComponent
// 0x00C0 (0x02F0 - 0x0230)
class UKuroWorldRainComponent final : public UKuroRainComponent
{
public:
	class UKuroWorldRainComponentSpawnConfig*     SpawnConfig;                                       // 0x0228(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKuroWorldRainComponentPhysicsConfig*   PhysicsConfig;                                     // 0x0230(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKuroWorldRainComponentCustomDataConfig* CustomDataConfig;                                  // 0x0238(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverridePhysics : 1;                              // 0x0240(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19BE[0x3];                                     // 0x0241(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WindSizeOverride;                                  // 0x0244(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GravityOverride;                                   // 0x0248(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DragOverride;                                      // 0x0254(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnScaleOverride;                                // 0x0258(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeDilationOverride;                              // 0x025C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PassTime;                                          // 0x0260(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_19BF[0x4];                                     // 0x0264(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseSpawnScale;                                    // 0x0268(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                GlobalWind;                                        // 0x026C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Center;                                            // 0x0278(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_19C0[0x6C];                                    // 0x0284(0x006C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DeactivateRain();
	bool GetIsRainActive();
	bool GetIsRainPlaying();
	void OnReceiveDeactivateRain();
	void OnReceiveStartRain();
	void OnReceiveStopRain();
	void SetBaseSpawnScale(float SpawnScale);
	void SetCenter(const struct FVector& InCenter);
	void SetGlobalWind(const struct FVector& InGlobalWind);
	void StartRain();
	void StopRain();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroWorldRainComponent">();
	}
	static class UKuroWorldRainComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroWorldRainComponent>();
	}
};
static_assert(alignof(UKuroWorldRainComponent) == 0x000010, "Wrong alignment on UKuroWorldRainComponent");
static_assert(sizeof(UKuroWorldRainComponent) == 0x0002F0, "Wrong size on UKuroWorldRainComponent");
static_assert(offsetof(UKuroWorldRainComponent, SpawnConfig) == 0x000228, "Member 'UKuroWorldRainComponent::SpawnConfig' has a wrong offset!");
static_assert(offsetof(UKuroWorldRainComponent, PhysicsConfig) == 0x000230, "Member 'UKuroWorldRainComponent::PhysicsConfig' has a wrong offset!");
static_assert(offsetof(UKuroWorldRainComponent, CustomDataConfig) == 0x000238, "Member 'UKuroWorldRainComponent::CustomDataConfig' has a wrong offset!");
static_assert(offsetof(UKuroWorldRainComponent, WindSizeOverride) == 0x000244, "Member 'UKuroWorldRainComponent::WindSizeOverride' has a wrong offset!");
static_assert(offsetof(UKuroWorldRainComponent, GravityOverride) == 0x000248, "Member 'UKuroWorldRainComponent::GravityOverride' has a wrong offset!");
static_assert(offsetof(UKuroWorldRainComponent, DragOverride) == 0x000254, "Member 'UKuroWorldRainComponent::DragOverride' has a wrong offset!");
static_assert(offsetof(UKuroWorldRainComponent, SpawnScaleOverride) == 0x000258, "Member 'UKuroWorldRainComponent::SpawnScaleOverride' has a wrong offset!");
static_assert(offsetof(UKuroWorldRainComponent, TimeDilationOverride) == 0x00025C, "Member 'UKuroWorldRainComponent::TimeDilationOverride' has a wrong offset!");
static_assert(offsetof(UKuroWorldRainComponent, PassTime) == 0x000260, "Member 'UKuroWorldRainComponent::PassTime' has a wrong offset!");
static_assert(offsetof(UKuroWorldRainComponent, BaseSpawnScale) == 0x000268, "Member 'UKuroWorldRainComponent::BaseSpawnScale' has a wrong offset!");
static_assert(offsetof(UKuroWorldRainComponent, GlobalWind) == 0x00026C, "Member 'UKuroWorldRainComponent::GlobalWind' has a wrong offset!");
static_assert(offsetof(UKuroWorldRainComponent, Center) == 0x000278, "Member 'UKuroWorldRainComponent::Center' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroWorldRainGlobalOverrider
// 0x0038 (0x02E0 - 0x02A8)
class AKuroWorldRainGlobalOverrider final : public AActor
{
public:
	class USceneComponent*                        SceneComponent;                                    // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverrideWindSize : 1;                             // 0x02B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19C1[0x3];                                     // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WindSizeOverride;                                  // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverrideGravity : 1;                              // 0x02B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19C2[0x3];                                     // 0x02B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                GravityOverride;                                   // 0x02BC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverrideDrag : 1;                                 // 0x02C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19C3[0x3];                                     // 0x02C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DragOverride;                                      // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverrideTimeDilation : 1;                         // 0x02D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19C4[0x3];                                     // 0x02D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeDilationOverride;                              // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x02D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19C5[0x4];                                     // 0x02DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroWorldRainGlobalOverrider">();
	}
	static class AKuroWorldRainGlobalOverrider* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroWorldRainGlobalOverrider>();
	}
};
static_assert(alignof(AKuroWorldRainGlobalOverrider) == 0x000008, "Wrong alignment on AKuroWorldRainGlobalOverrider");
static_assert(sizeof(AKuroWorldRainGlobalOverrider) == 0x0002E0, "Wrong size on AKuroWorldRainGlobalOverrider");
static_assert(offsetof(AKuroWorldRainGlobalOverrider, SceneComponent) == 0x0002A8, "Member 'AKuroWorldRainGlobalOverrider::SceneComponent' has a wrong offset!");
static_assert(offsetof(AKuroWorldRainGlobalOverrider, WindSizeOverride) == 0x0002B4, "Member 'AKuroWorldRainGlobalOverrider::WindSizeOverride' has a wrong offset!");
static_assert(offsetof(AKuroWorldRainGlobalOverrider, GravityOverride) == 0x0002BC, "Member 'AKuroWorldRainGlobalOverrider::GravityOverride' has a wrong offset!");
static_assert(offsetof(AKuroWorldRainGlobalOverrider, DragOverride) == 0x0002CC, "Member 'AKuroWorldRainGlobalOverrider::DragOverride' has a wrong offset!");
static_assert(offsetof(AKuroWorldRainGlobalOverrider, TimeDilationOverride) == 0x0002D4, "Member 'AKuroWorldRainGlobalOverrider::TimeDilationOverride' has a wrong offset!");
static_assert(offsetof(AKuroWorldRainGlobalOverrider, Priority) == 0x0002D8, "Member 'AKuroWorldRainGlobalOverrider::Priority' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroWuYinQuActorBase
// 0x0010 (0x02B8 - 0x02A8)
class AKuroWuYinQuActorBase final : public AActor
{
public:
	class FName                                   Key;                                               // 0x02A8(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19C6[0x4];                                     // 0x02B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroWuYinQuActorBase">();
	}
	static class AKuroWuYinQuActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroWuYinQuActorBase>();
	}
};
static_assert(alignof(AKuroWuYinQuActorBase) == 0x000008, "Wrong alignment on AKuroWuYinQuActorBase");
static_assert(sizeof(AKuroWuYinQuActorBase) == 0x0002B8, "Wrong size on AKuroWuYinQuActorBase");
static_assert(offsetof(AKuroWuYinQuActorBase, Key) == 0x0002A8, "Member 'AKuroWuYinQuActorBase::Key' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.LensflareSamplerActor
// 0x00A8 (0x0350 - 0x02A8)
class ALensflareSamplerActor final : public AActor
{
public:
	float                                         VisibleRadius;                                     // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OccludeRadius;                                     // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrightnessThreshold;                               // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrightnessThresholdRange;                          // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USunLensFlareConfig*                    Config;                                            // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverrideGhost : 1;                                // 0x02C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19C7[0x7];                                     // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            GhostMeshOverride;                                 // 0x02C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     GhostMaterialOverride;                             // 0x02D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverrideHalo : 1;                                 // 0x02D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19C8[0x7];                                     // 0x02D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            HaloMeshOverride;                                  // 0x02E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     HaloMaterialOverride;                              // 0x02E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverrideGlare : 1;                                // 0x02F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19C9[0x7];                                     // 0x02F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            GlareMeshOverride;                                 // 0x02F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     GlareMaterialOverride;                             // 0x0300(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     FinalGhostMaterial;                                // 0x0308(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     FinalHaloMaterial;                                 // 0x0310(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     FinalGlareMaterial;                                // 0x0318(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentSceneSampleIndex;                           // 0x0320(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentDistanceFactor;                             // 0x0324(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        SceneComponent;                                    // 0x0328(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   LensflareGhostComponent;                           // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   LensflareGlareComponent;                           // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   LensflareHaloComponent;                            // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_19CA[0x8];                                     // 0x0348(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyDynamicMaterialGhost(class UMaterialInstanceDynamic* DynMaterial);
	void ApplyDynamicMaterialGlare(class UMaterialInstanceDynamic* DynMaterial);
	void ApplyDynamicMaterialHalo(class UMaterialInstanceDynamic* DynMaterial);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LensflareSamplerActor">();
	}
	static class ALensflareSamplerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALensflareSamplerActor>();
	}
};
static_assert(alignof(ALensflareSamplerActor) == 0x000008, "Wrong alignment on ALensflareSamplerActor");
static_assert(sizeof(ALensflareSamplerActor) == 0x000350, "Wrong size on ALensflareSamplerActor");
static_assert(offsetof(ALensflareSamplerActor, VisibleRadius) == 0x0002A8, "Member 'ALensflareSamplerActor::VisibleRadius' has a wrong offset!");
static_assert(offsetof(ALensflareSamplerActor, OccludeRadius) == 0x0002AC, "Member 'ALensflareSamplerActor::OccludeRadius' has a wrong offset!");
static_assert(offsetof(ALensflareSamplerActor, BrightnessThreshold) == 0x0002B0, "Member 'ALensflareSamplerActor::BrightnessThreshold' has a wrong offset!");
static_assert(offsetof(ALensflareSamplerActor, BrightnessThresholdRange) == 0x0002B4, "Member 'ALensflareSamplerActor::BrightnessThresholdRange' has a wrong offset!");
static_assert(offsetof(ALensflareSamplerActor, Config) == 0x0002B8, "Member 'ALensflareSamplerActor::Config' has a wrong offset!");
static_assert(offsetof(ALensflareSamplerActor, GhostMeshOverride) == 0x0002C8, "Member 'ALensflareSamplerActor::GhostMeshOverride' has a wrong offset!");
static_assert(offsetof(ALensflareSamplerActor, GhostMaterialOverride) == 0x0002D0, "Member 'ALensflareSamplerActor::GhostMaterialOverride' has a wrong offset!");
static_assert(offsetof(ALensflareSamplerActor, HaloMeshOverride) == 0x0002E0, "Member 'ALensflareSamplerActor::HaloMeshOverride' has a wrong offset!");
static_assert(offsetof(ALensflareSamplerActor, HaloMaterialOverride) == 0x0002E8, "Member 'ALensflareSamplerActor::HaloMaterialOverride' has a wrong offset!");
static_assert(offsetof(ALensflareSamplerActor, GlareMeshOverride) == 0x0002F8, "Member 'ALensflareSamplerActor::GlareMeshOverride' has a wrong offset!");
static_assert(offsetof(ALensflareSamplerActor, GlareMaterialOverride) == 0x000300, "Member 'ALensflareSamplerActor::GlareMaterialOverride' has a wrong offset!");
static_assert(offsetof(ALensflareSamplerActor, FinalGhostMaterial) == 0x000308, "Member 'ALensflareSamplerActor::FinalGhostMaterial' has a wrong offset!");
static_assert(offsetof(ALensflareSamplerActor, FinalHaloMaterial) == 0x000310, "Member 'ALensflareSamplerActor::FinalHaloMaterial' has a wrong offset!");
static_assert(offsetof(ALensflareSamplerActor, FinalGlareMaterial) == 0x000318, "Member 'ALensflareSamplerActor::FinalGlareMaterial' has a wrong offset!");
static_assert(offsetof(ALensflareSamplerActor, CurrentSceneSampleIndex) == 0x000320, "Member 'ALensflareSamplerActor::CurrentSceneSampleIndex' has a wrong offset!");
static_assert(offsetof(ALensflareSamplerActor, CurrentDistanceFactor) == 0x000324, "Member 'ALensflareSamplerActor::CurrentDistanceFactor' has a wrong offset!");
static_assert(offsetof(ALensflareSamplerActor, SceneComponent) == 0x000328, "Member 'ALensflareSamplerActor::SceneComponent' has a wrong offset!");
static_assert(offsetof(ALensflareSamplerActor, LensflareGhostComponent) == 0x000330, "Member 'ALensflareSamplerActor::LensflareGhostComponent' has a wrong offset!");
static_assert(offsetof(ALensflareSamplerActor, LensflareGlareComponent) == 0x000338, "Member 'ALensflareSamplerActor::LensflareGlareComponent' has a wrong offset!");
static_assert(offsetof(ALensflareSamplerActor, LensflareHaloComponent) == 0x000340, "Member 'ALensflareSamplerActor::LensflareHaloComponent' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.NiagaraDataInterfaceKuroRendering
// 0x0010 (0x0050 - 0x0040)
class UNiagaraDataInterfaceKuroRendering final : public UNiagaraDataInterface
{
public:
	class FName                                   NiagaraCollectionName;                             // 0x0040(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_19CB[0x4];                                     // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiagaraDataInterfaceKuroRendering">();
	}
	static class UNiagaraDataInterfaceKuroRendering* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiagaraDataInterfaceKuroRendering>();
	}
};
static_assert(alignof(UNiagaraDataInterfaceKuroRendering) == 0x000008, "Wrong alignment on UNiagaraDataInterfaceKuroRendering");
static_assert(sizeof(UNiagaraDataInterfaceKuroRendering) == 0x000050, "Wrong size on UNiagaraDataInterfaceKuroRendering");
static_assert(offsetof(UNiagaraDataInterfaceKuroRendering, NiagaraCollectionName) == 0x000040, "Member 'UNiagaraDataInterfaceKuroRendering::NiagaraCollectionName' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.NiagaraKuroParameterSystem
// 0x00D0 (0x0108 - 0x0038)
class UNiagaraKuroParameterSystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_19CC[0xD0];                                    // 0x0038(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetParameterFloat(class FName Collection, class FName Param_Name, float Default);
	struct FLinearColor GetParameterLinearColor(class FName Collection, class FName Param_Name, const struct FLinearColor& Default);
	struct FVector GetParameterVector(class FName Collection, class FName Param_Name, const struct FVector& Default);
	void RemoveCollection(class FName Collection);
	void RemoveParameterFloat(class FName Collection, class FName Param_Name);
	void RemoveParameterLinearColor(class FName Collection, class FName Param_Name);
	void RemoveParameterVector(class FName Collection, class FName Param_Name);
	void SetParameterFloat(class FName Collection, class FName Param_Name, float Val);
	void SetParameterLinearColor(class FName Collection, class FName Param_Name, const struct FLinearColor& Val);
	void SetParameterVector(class FName Collection, class FName Param_Name, const struct FVector& Val);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiagaraKuroParameterSystem">();
	}
	static class UNiagaraKuroParameterSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiagaraKuroParameterSystem>();
	}
};
static_assert(alignof(UNiagaraKuroParameterSystem) == 0x000008, "Wrong alignment on UNiagaraKuroParameterSystem");
static_assert(sizeof(UNiagaraKuroParameterSystem) == 0x000108, "Wrong size on UNiagaraKuroParameterSystem");

// Class KuroRenderingRuntimeBPPlugin.ThunderGenerator
// 0x0250 (0x04F8 - 0x02A8)
class AThunderGenerator final : public AActor
{
public:
	float                                         PointLightHeight;                                  // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19CD[0x4];                                     // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UKuroWeatherDataAsset*                  WeatherDataAsset;                                  // 0x02B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceHeightMin;                                    // 0x02B8(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TraceHeightMax;                                    // 0x02BC(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistributionFactor;                                // 0x02C0(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GenerateIntervalMin;                               // 0x02C4(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GenerateIntervalMax;                               // 0x02C8(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GenerateChance;                                    // 0x02CC(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThunderPlayInnerRange;                             // 0x02D0(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThunderPlayRange;                                  // 0x02D4(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaseThunderAttackChance;                           // 0x02D8(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_19CE[0x4];                                     // 0x02DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        PointLightCurve;                                   // 0x02E0(0x0090)(BlueprintVisible, Transient, Protected, NativeAccessSpecifierProtected)
	struct FKuroCurveFloat                        PointLightRadiusCurve;                             // 0x0370(0x0090)(BlueprintVisible, Transient, Protected, NativeAccessSpecifierProtected)
	struct FKuroCurveFloat                        PostProcessCurve;                                  // 0x0400(0x0090)(BlueprintVisible, Transient, Protected, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         NiagaraSystem;                                     // 0x0490(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      NiagaraComponent;                                  // 0x0498(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPointLightComponent*                   PointLightComponent;                               // 0x04A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UKuroPostProcessComponent*              KuroPostProcessComponent;                          // 0x04A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AKuroGlobalGI*                          CachedGlobalGI;                                    // 0x04B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UKuroGISystem*                          CachedGISystem;                                    // 0x04B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThunderAge;                                        // 0x04C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AttackAge;                                         // 0x04C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bThunderActive;                                    // 0x04C8(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EKuroThunderType                              CurrentThunderType;                                // 0x04C9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_19CF[0x2];                                     // 0x04CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FinalThunderGenerateChance;                        // 0x04CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FinalThunderAttackChance;                          // 0x04D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThunderCloudIntensity;                             // 0x04D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThunderPostProcessIntensity;                       // 0x04D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_19D0[0x1C];                                    // 0x04DC(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void SpawnThunderInWorld(class UObject* WorldContextObject, const struct FVector& Location, bool bAttack);

	bool CalculateThunderPosition(const struct FTransform& CameraTransform, struct FVector* OutPosition, bool bAttack);
	void DisableThunder();
	void EnableThunder();
	void OnReceiveThunderAttack(const struct FVector& Location, bool bAttack);
	void OnThunderTypeChanged();
	void OnUpdateThunderEffect(float DeltaSeconds);
	void SpawnThunder(const struct FVector& HitLocation, bool bAttack);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThunderGenerator">();
	}
	static class AThunderGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AThunderGenerator>();
	}
};
static_assert(alignof(AThunderGenerator) == 0x000008, "Wrong alignment on AThunderGenerator");
static_assert(sizeof(AThunderGenerator) == 0x0004F8, "Wrong size on AThunderGenerator");
static_assert(offsetof(AThunderGenerator, PointLightHeight) == 0x0002A8, "Member 'AThunderGenerator::PointLightHeight' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, WeatherDataAsset) == 0x0002B0, "Member 'AThunderGenerator::WeatherDataAsset' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, TraceHeightMin) == 0x0002B8, "Member 'AThunderGenerator::TraceHeightMin' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, TraceHeightMax) == 0x0002BC, "Member 'AThunderGenerator::TraceHeightMax' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, DistributionFactor) == 0x0002C0, "Member 'AThunderGenerator::DistributionFactor' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, GenerateIntervalMin) == 0x0002C4, "Member 'AThunderGenerator::GenerateIntervalMin' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, GenerateIntervalMax) == 0x0002C8, "Member 'AThunderGenerator::GenerateIntervalMax' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, GenerateChance) == 0x0002CC, "Member 'AThunderGenerator::GenerateChance' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, ThunderPlayInnerRange) == 0x0002D0, "Member 'AThunderGenerator::ThunderPlayInnerRange' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, ThunderPlayRange) == 0x0002D4, "Member 'AThunderGenerator::ThunderPlayRange' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, BaseThunderAttackChance) == 0x0002D8, "Member 'AThunderGenerator::BaseThunderAttackChance' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, PointLightCurve) == 0x0002E0, "Member 'AThunderGenerator::PointLightCurve' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, PointLightRadiusCurve) == 0x000370, "Member 'AThunderGenerator::PointLightRadiusCurve' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, PostProcessCurve) == 0x000400, "Member 'AThunderGenerator::PostProcessCurve' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, NiagaraSystem) == 0x000490, "Member 'AThunderGenerator::NiagaraSystem' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, NiagaraComponent) == 0x000498, "Member 'AThunderGenerator::NiagaraComponent' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, PointLightComponent) == 0x0004A0, "Member 'AThunderGenerator::PointLightComponent' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, KuroPostProcessComponent) == 0x0004A8, "Member 'AThunderGenerator::KuroPostProcessComponent' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, CachedGlobalGI) == 0x0004B0, "Member 'AThunderGenerator::CachedGlobalGI' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, CachedGISystem) == 0x0004B8, "Member 'AThunderGenerator::CachedGISystem' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, ThunderAge) == 0x0004C0, "Member 'AThunderGenerator::ThunderAge' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, AttackAge) == 0x0004C4, "Member 'AThunderGenerator::AttackAge' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, bThunderActive) == 0x0004C8, "Member 'AThunderGenerator::bThunderActive' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, CurrentThunderType) == 0x0004C9, "Member 'AThunderGenerator::CurrentThunderType' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, FinalThunderGenerateChance) == 0x0004CC, "Member 'AThunderGenerator::FinalThunderGenerateChance' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, FinalThunderAttackChance) == 0x0004D0, "Member 'AThunderGenerator::FinalThunderAttackChance' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, ThunderCloudIntensity) == 0x0004D4, "Member 'AThunderGenerator::ThunderCloudIntensity' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, ThunderPostProcessIntensity) == 0x0004D8, "Member 'AThunderGenerator::ThunderPostProcessIntensity' has a wrong offset!");

}

