#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroGAS

#include "Basic.hpp"

#include "KuroGAS_classes.hpp"
#include "KuroGAS_parameters.hpp"


namespace SDK
{

// Function KuroGAS.AsyncTaskAnyAttributeChanged.ListenForAnyAttributeChange
// (Final, Native, Static, Public)
// Parameters:
// class UAbilitySystemComponent*          AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncTaskAnyAttributeChanged*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncTaskAnyAttributeChanged* UAsyncTaskAnyAttributeChanged::ListenForAnyAttributeChange(class UAbilitySystemComponent* AbilitySystemComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncTaskAnyAttributeChanged", "ListenForAnyAttributeChange");

	Params::AsyncTaskAnyAttributeChanged_ListenForAnyAttributeChange Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.AsyncTaskAnyAttributeChanged.EndTask
// (Final, Native, Public)

void UAsyncTaskAnyAttributeChanged::EndTask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncTaskAnyAttributeChanged", "EndTask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.AsyncTaskAnyEffectInhibitionChanged.ListenForAnyEffectInhibitionChanged
// (Final, Native, Static, Private)
// Parameters:
// class UAbilitySystemComponent*          AbilityComp_0                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncTaskAnyEffectInhibitionChanged*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncTaskAnyEffectInhibitionChanged* UAsyncTaskAnyEffectInhibitionChanged::ListenForAnyEffectInhibitionChanged(class UAbilitySystemComponent* AbilityComp_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncTaskAnyEffectInhibitionChanged", "ListenForAnyEffectInhibitionChanged");

	Params::AsyncTaskAnyEffectInhibitionChanged_ListenForAnyEffectInhibitionChanged Parms{};

	Parms.AbilityComp_0 = AbilityComp_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.AsyncTaskAnyEffectInhibitionChanged.EndTask
// (Final, Native, Private)

void UAsyncTaskAnyEffectInhibitionChanged::EndTask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncTaskAnyEffectInhibitionChanged", "EndTask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.AsyncTaskAnyEffectRemoved.ListenForAnyEffectRemoved
// (Final, Native, Static, Private)
// Parameters:
// class UAbilitySystemComponent*          AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncTaskAnyEffectRemoved*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncTaskAnyEffectRemoved* UAsyncTaskAnyEffectRemoved::ListenForAnyEffectRemoved(class UAbilitySystemComponent* AbilitySystemComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncTaskAnyEffectRemoved", "ListenForAnyEffectRemoved");

	Params::AsyncTaskAnyEffectRemoved_ListenForAnyEffectRemoved Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.AsyncTaskAnyEffectRemoved.EndTask
// (Final, Native, Private)

void UAsyncTaskAnyEffectRemoved::EndTask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncTaskAnyEffectRemoved", "EndTask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.AsyncTaskAnyEffectStackChanged.ListenForAnyEffectStackChanged
// (Final, Native, Static, Private)
// Parameters:
// class UAbilitySystemComponent*          AbilityComp_0                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncTaskAnyEffectStackChanged*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncTaskAnyEffectStackChanged* UAsyncTaskAnyEffectStackChanged::ListenForAnyEffectStackChanged(class UAbilitySystemComponent* AbilityComp_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncTaskAnyEffectStackChanged", "ListenForAnyEffectStackChanged");

	Params::AsyncTaskAnyEffectStackChanged_ListenForAnyEffectStackChanged Parms{};

	Parms.AbilityComp_0 = AbilityComp_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.AsyncTaskAnyEffectStackChanged.EndTask
// (Final, Native, Private)

void UAsyncTaskAnyEffectStackChanged::EndTask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncTaskAnyEffectStackChanged", "EndTask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.AsyncTaskEffectApplied.ListenForEffectApplied
// (Final, Native, Static, Private)
// Parameters:
// class UAbilitySystemComponent*          AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     EffectGameplayTag                                      (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     IgnoreGameplayTag                                      (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncTaskEffectApplied*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncTaskEffectApplied* UAsyncTaskEffectApplied::ListenForEffectApplied(class UAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayTag& EffectGameplayTag, const struct FGameplayTag& IgnoreGameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncTaskEffectApplied", "ListenForEffectApplied");

	Params::AsyncTaskEffectApplied_ListenForEffectApplied Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;
	Parms.EffectGameplayTag = std::move(EffectGameplayTag);
	Parms.IgnoreGameplayTag = std::move(IgnoreGameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.AsyncTaskEffectApplied.EndTask
// (Final, Native, Private)

void UAsyncTaskEffectApplied::EndTask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncTaskEffectApplied", "EndTask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.AsyncTaskEffectDebugString.ListenForGameplayEffectExecutedDebugString
// (Final, Native, Static, Private)
// Parameters:
// class UAbilitySystemComponent*          AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncTaskEffectDebugString*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncTaskEffectDebugString* UAsyncTaskEffectDebugString::ListenForGameplayEffectExecutedDebugString(class UAbilitySystemComponent* AbilitySystemComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncTaskEffectDebugString", "ListenForGameplayEffectExecutedDebugString");

	Params::AsyncTaskEffectDebugString_ListenForGameplayEffectExecutedDebugString Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.AsyncTaskEffectDebugString.EndTask
// (Final, Native, Private, BlueprintCallable)

void UAsyncTaskEffectDebugString::EndTask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncTaskEffectDebugString", "EndTask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.AsyncTaskEffectInhibitionChanged.ListenForInhibitionChanged
// (Final, Native, Static, Public)
// Parameters:
// struct FActiveGameplayEffectHandle      Handle                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncTaskEffectInhibitionChanged*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncTaskEffectInhibitionChanged* UAsyncTaskEffectInhibitionChanged::ListenForInhibitionChanged(const struct FActiveGameplayEffectHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncTaskEffectInhibitionChanged", "ListenForInhibitionChanged");

	Params::AsyncTaskEffectInhibitionChanged_ListenForInhibitionChanged Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.AsyncTaskEffectInhibitionChanged.EndTask
// (Final, Native, Public)

void UAsyncTaskEffectInhibitionChanged::EndTask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncTaskEffectInhibitionChanged", "EndTask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.AsyncTaskEffectStackChanged.ListenForStackChanged
// (Final, Native, Static, Public)
// Parameters:
// struct FActiveGameplayEffectHandle      Handle                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncTaskEffectStackChanged*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncTaskEffectStackChanged* UAsyncTaskEffectStackChanged::ListenForStackChanged(const struct FActiveGameplayEffectHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncTaskEffectStackChanged", "ListenForStackChanged");

	Params::AsyncTaskEffectStackChanged_ListenForStackChanged Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.AsyncTaskEffectStackChanged.EndTask
// (Final, Native, Public)

void UAsyncTaskEffectStackChanged::EndTask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncTaskEffectStackChanged", "EndTask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.AsyncTaskGameplayCueNotify.ListenForGameplayCueNotify
// (Final, Native, Static, Private)
// Parameters:
// class UAbilitySystemComponent*          AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncTaskGameplayCueNotify*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncTaskGameplayCueNotify* UAsyncTaskGameplayCueNotify::ListenForGameplayCueNotify(class UAbilitySystemComponent* AbilitySystemComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncTaskGameplayCueNotify", "ListenForGameplayCueNotify");

	Params::AsyncTaskGameplayCueNotify_ListenForGameplayCueNotify Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.AsyncTaskGameplayCueNotify.EndTask
// (Final, Native, Private, BlueprintCallable)

void UAsyncTaskGameplayCueNotify::EndTask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncTaskGameplayCueNotify", "EndTask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.AsyncTaskPlayMontageAndWait.ListenForPlayMontage
// (Final, Native, Static, Private)
// Parameters:
// class UAnimInstance*                    AnimInstance_0                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     MontageToPlay_0                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlayRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartingPosition                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             StartingSection                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncTaskPlayMontageAndWait*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncTaskPlayMontageAndWait* UAsyncTaskPlayMontageAndWait::ListenForPlayMontage(class UAnimInstance* AnimInstance_0, class UAnimMontage* MontageToPlay_0, float PlayRate, float StartingPosition, class FName StartingSection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncTaskPlayMontageAndWait", "ListenForPlayMontage");

	Params::AsyncTaskPlayMontageAndWait_ListenForPlayMontage Parms{};

	Parms.AnimInstance_0 = AnimInstance_0;
	Parms.MontageToPlay_0 = MontageToPlay_0;
	Parms.PlayRate = PlayRate;
	Parms.StartingPosition = StartingPosition;
	Parms.StartingSection = StartingSection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.AsyncTaskPlayMontageAndWait.EndTask
// (Final, Native, Private, BlueprintCallable)

void UAsyncTaskPlayMontageAndWait::EndTask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncTaskPlayMontageAndWait", "EndTask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.AsyncTaskPlayMontageAndWait.StopMontage
// (Final, Native, Private, BlueprintCallable)

void UAsyncTaskPlayMontageAndWait::StopMontage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncTaskPlayMontageAndWait", "StopMontage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.AsyncTaskTagCountChanged.ListenForTagCountChanged
// (Final, Native, Static, Public)
// Parameters:
// class UAbilitySystemComponent*          AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncTaskTagCountChanged*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncTaskTagCountChanged* UAsyncTaskTagCountChanged::ListenForTagCountChanged(class UAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncTaskTagCountChanged", "ListenForTagCountChanged");

	Params::AsyncTaskTagCountChanged_ListenForTagCountChanged Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;
	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.AsyncTaskTagCountChanged.EndTask
// (Final, Native, Public)

void UAsyncTaskTagCountChanged::EndTask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncTaskTagCountChanged", "EndTask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.AsyncTaskTagSignificantChanged.ListenForTagSignificantChanged
// (Final, Native, Static, Public)
// Parameters:
// class UAbilitySystemComponent*          AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncTaskTagSignificantChanged*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncTaskTagSignificantChanged* UAsyncTaskTagSignificantChanged::ListenForTagSignificantChanged(class UAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncTaskTagSignificantChanged", "ListenForTagSignificantChanged");

	Params::AsyncTaskTagSignificantChanged_ListenForTagSignificantChanged Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;
	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.AsyncTaskTagSignificantChanged.EndTask
// (Final, Native, Public)

void UAsyncTaskTagSignificantChanged::EndTask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncTaskTagSignificantChanged", "EndTask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.AsyncTaskWaitGameplayEvent.ListenForGameplayEvent
// (Final, Native, Static, Private)
// Parameters:
// class UAbilitySystemComponent*          AbilitySystemComponent_0                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncTaskWaitGameplayEvent*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncTaskWaitGameplayEvent* UAsyncTaskWaitGameplayEvent::ListenForGameplayEvent(class UAbilitySystemComponent* AbilitySystemComponent_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncTaskWaitGameplayEvent", "ListenForGameplayEvent");

	Params::AsyncTaskWaitGameplayEvent_ListenForGameplayEvent Parms{};

	Parms.AbilitySystemComponent_0 = AbilitySystemComponent_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.AsyncTaskWaitGameplayEvent.EndTask
// (Final, Native, Private)

void UAsyncTaskWaitGameplayEvent::EndTask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncTaskWaitGameplayEvent", "EndTask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.BaseAbilitySystemComponent.ApplyGeToSelfById
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// int64                                   GameplayEffectId                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEffectContextHandle     Context                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ServerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActiveGameplayEffectHandle      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FActiveGameplayEffectHandle UBaseAbilitySystemComponent::ApplyGeToSelfById(int64 GameplayEffectId, const struct FGameplayEffectContextHandle& Context, float Level, int32 ServerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitySystemComponent", "ApplyGeToSelfById");

	Params::BaseAbilitySystemComponent_ApplyGeToSelfById Parms{};

	Parms.GameplayEffectId = GameplayEffectId;
	Parms.Context = std::move(Context);
	Parms.Level = Level;
	Parms.ServerId = ServerId;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function KuroGAS.BaseAbilitySystemComponent.BP_InitAbilityActorInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             AnimInstanceTag                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseAbilitySystemComponent::BP_InitAbilityActorInfo(class FName AnimInstanceTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitySystemComponent", "BP_InitAbilityActorInfo");

	Params::BaseAbilitySystemComponent_BP_InitAbilityActorInfo Parms{};

	Parms.AnimInstanceTag = AnimInstanceTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.BaseAbilitySystemComponent.DestroyDynamicGameplayEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameplayEffect*                  Ge                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseAbilitySystemComponent::DestroyDynamicGameplayEffect(class UGameplayEffect* Ge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitySystemComponent", "DestroyDynamicGameplayEffect");

	Params::BaseAbilitySystemComponent_DestroyDynamicGameplayEffect Parms{};

	Parms.Ge = Ge;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.BaseAbilitySystemComponent.GetAbility
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class UGameplayAbility>     Ability                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilitySpecHandle       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayAbilitySpecHandle UBaseAbilitySystemComponent::GetAbility(const TSubclassOf<class UGameplayAbility>& Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitySystemComponent", "GetAbility");

	Params::BaseAbilitySystemComponent_GetAbility Parms{};

	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.BaseAbilitySystemComponent.GetActiveEffectsByGrantedTags
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     Tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FActiveGameplayEffectHandle>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FActiveGameplayEffectHandle> UBaseAbilitySystemComponent::GetActiveEffectsByGrantedTags(const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitySystemComponent", "GetActiveEffectsByGrantedTags");

	Params::BaseAbilitySystemComponent_GetActiveEffectsByGrantedTags Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.BaseAbilitySystemComponent.GetActiveEffectsById
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int64                                   GeId                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FActiveGameplayEffectHandle>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FActiveGameplayEffectHandle> UBaseAbilitySystemComponent::GetActiveEffectsById(const int64 GeId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitySystemComponent", "GetActiveEffectsById");

	Params::BaseAbilitySystemComponent_GetActiveEffectsById Parms{};

	Parms.GeId = GeId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.BaseAbilitySystemComponent.GetGameplayEffectCountById
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int64                                   GameplayEffectId                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilitySystemComponent*          OptionalInstigatorFilterComponent                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnforceOnGoingCheck                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBaseAbilitySystemComponent::GetGameplayEffectCountById(int64 GameplayEffectId, class UAbilitySystemComponent* OptionalInstigatorFilterComponent, bool bEnforceOnGoingCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitySystemComponent", "GetGameplayEffectCountById");

	Params::BaseAbilitySystemComponent_GetGameplayEffectCountById Parms{};

	Parms.GameplayEffectId = GameplayEffectId;
	Parms.OptionalInstigatorFilterComponent = OptionalInstigatorFilterComponent;
	Parms.bEnforceOnGoingCheck = bEnforceOnGoingCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.BaseAbilitySystemComponent.InternalApplyModToAttribute
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   AttributeId                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayModOp                          ModifierOp                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ModifierMagnitude                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseAbilitySystemComponent::InternalApplyModToAttribute(const int32 AttributeId, EGameplayModOp ModifierOp, float ModifierMagnitude)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitySystemComponent", "InternalApplyModToAttribute");

	Params::BaseAbilitySystemComponent_InternalApplyModToAttribute Parms{};

	Parms.AttributeId = AttributeId;
	Parms.ModifierOp = ModifierOp;
	Parms.ModifierMagnitude = ModifierMagnitude;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.BaseAbilitySystemComponent.MakeDynamicGameplayEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             GeName                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   GeId                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayEffect*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayEffect* UBaseAbilitySystemComponent::MakeDynamicGameplayEffect(const class FName GeName, const int64 GeId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitySystemComponent", "MakeDynamicGameplayEffect");

	Params::BaseAbilitySystemComponent_MakeDynamicGameplayEffect Parms{};

	Parms.GeName = GeName;
	Parms.GeId = GeId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.BaseAbilitySystemComponent.OnAnyTagChangeInternal
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     GameplayTag                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewTagCount                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBaseAbilitySystemComponent::OnAnyTagChangeInternal(const struct FGameplayTag& GameplayTag, int32 NewTagCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitySystemComponent", "OnAnyTagChangeInternal");

	Params::BaseAbilitySystemComponent_OnAnyTagChangeInternal Parms{};

	Parms.GameplayTag = std::move(GameplayTag);
	Parms.NewTagCount = NewTagCount;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function KuroGAS.BaseAbilitySystemComponent.PauseActiveGameplayEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FActiveGameplayEffectHandle      Handle                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPause                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseAbilitySystemComponent::PauseActiveGameplayEffect(const struct FActiveGameplayEffectHandle& Handle, bool bPause)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitySystemComponent", "PauseActiveGameplayEffect");

	Params::BaseAbilitySystemComponent_PauseActiveGameplayEffect Parms{};

	Parms.Handle = std::move(Handle);
	Parms.bPause = bPause;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.BaseAbilitySystemComponent.PauseAllActiveGameplayEffects
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bPause                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseAbilitySystemComponent::PauseAllActiveGameplayEffects(bool bPause)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitySystemComponent", "PauseAllActiveGameplayEffects");

	Params::BaseAbilitySystemComponent_PauseAllActiveGameplayEffects Parms{};

	Parms.bPause = bPause;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.BaseAbilitySystemComponent.RemoveAbility
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayAbilitySpecHandle       Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseAbilitySystemComponent::RemoveAbility(const struct FGameplayAbilitySpecHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitySystemComponent", "RemoveAbility");

	Params::BaseAbilitySystemComponent_RemoveAbility Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.BaseAbilitySystemComponent.RemoveActiveEffectsById
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int64                                   GeId                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StackCount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBaseAbilitySystemComponent::RemoveActiveEffectsById(const int64 GeId, int32 StackCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitySystemComponent", "RemoveActiveEffectsById");

	Params::BaseAbilitySystemComponent_RemoveActiveEffectsById Parms{};

	Parms.GeId = GeId;
	Parms.StackCount = StackCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.BaseAbilitySystemComponent.RemoveActiveEffectsByUniqueServerId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   GameplayEffectSpecServerId                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseAbilitySystemComponent::RemoveActiveEffectsByUniqueServerId(const int32 GameplayEffectSpecServerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitySystemComponent", "RemoveActiveEffectsByUniqueServerId");

	Params::BaseAbilitySystemComponent_RemoveActiveEffectsByUniqueServerId Parms{};

	Parms.GameplayEffectSpecServerId = GameplayEffectSpecServerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.BaseAbilitySystemComponent.ResetDilationForActiveEffects
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TimeDilation                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseAbilitySystemComponent::ResetDilationForActiveEffects(const float TimeDilation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitySystemComponent", "ResetDilationForActiveEffects");

	Params::BaseAbilitySystemComponent_ResetDilationForActiveEffects Parms{};

	Parms.TimeDilation = TimeDilation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.BaseAbilitySystemComponent.UpdateActiveGameplayEffectDurationHandle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FActiveGameplayEffectHandle      Handle                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DurationModifyValue                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBaseAbilitySystemComponent::UpdateActiveGameplayEffectDurationHandle(const struct FActiveGameplayEffectHandle& Handle, const float DurationModifyValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitySystemComponent", "UpdateActiveGameplayEffectDurationHandle");

	Params::BaseAbilitySystemComponent_UpdateActiveGameplayEffectDurationHandle Parms{};

	Parms.Handle = std::move(Handle);
	Parms.DurationModifyValue = DurationModifyValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.BaseAbilitySystemComponent.AddGeGrantGa
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UGameplayEffect*                  Ge                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayAbility>     Ability                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayEffectGrantedAbilityRemovePolicyRemovalPolicy                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseAbilitySystemComponent::AddGeGrantGa(class UGameplayEffect* Ge, const TSubclassOf<class UGameplayAbility>& Ability, int32 Level, EGameplayEffectGrantedAbilityRemovePolicy RemovalPolicy) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitySystemComponent", "AddGeGrantGa");

	Params::BaseAbilitySystemComponent_AddGeGrantGa Parms{};

	Parms.Ge = Ge;
	Parms.Ability = Ability;
	Parms.Level = Level;
	Parms.RemovalPolicy = RemovalPolicy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.BaseAbilitySystemComponent.AddGeModifierByAttributeId
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UGameplayEffect*                  Ge                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ModifiedAttributeId                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttributeBasedFloatCalculationType     CalculationType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayModOp                          ModOp                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AttributeId                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     DataTag                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     DataTag2                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayEffectAttributeCaptureSource   InSource                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InSnapShot                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseAbilitySystemComponent::AddGeModifierByAttributeId(class UGameplayEffect* Ge, const int32 ModifiedAttributeId, EAttributeBasedFloatCalculationType CalculationType, const EGameplayModOp ModOp, const int32 AttributeId, const struct FGameplayTag& DataTag, const struct FGameplayTag& DataTag2, EGameplayEffectAttributeCaptureSource InSource, bool InSnapShot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitySystemComponent", "AddGeModifierByAttributeId");

	Params::BaseAbilitySystemComponent_AddGeModifierByAttributeId Parms{};

	Parms.Ge = Ge;
	Parms.ModifiedAttributeId = ModifiedAttributeId;
	Parms.CalculationType = CalculationType;
	Parms.ModOp = ModOp;
	Parms.AttributeId = AttributeId;
	Parms.DataTag = std::move(DataTag);
	Parms.DataTag2 = std::move(DataTag2);
	Parms.InSource = InSource;
	Parms.InSnapShot = InSnapShot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.BaseAbilitySystemComponent.AddGeModifierByKey
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class UGameplayEffect*                  Ge                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ModifiedAttributeId                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayModOp                          ModOp                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ModifierKey                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseAbilitySystemComponent::AddGeModifierByKey(class UGameplayEffect* Ge, int32 ModifiedAttributeId, const EGameplayModOp ModOp, const int32 ModifierKey) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitySystemComponent", "AddGeModifierByKey");

	Params::BaseAbilitySystemComponent_AddGeModifierByKey Parms{};

	Parms.Ge = Ge;
	Parms.ModifiedAttributeId = ModifiedAttributeId;
	Parms.ModOp = ModOp;
	Parms.ModifierKey = ModifierKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.BaseAbilitySystemComponent.AddGeModifierByMMC
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UGameplayEffect*                  Ge                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ModifiedAttributeId                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayModOp                          ModOp                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayModMagnitudeCalculation>CalculationClassMagnitude                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseAbilitySystemComponent::AddGeModifierByMMC(class UGameplayEffect* Ge, int32 ModifiedAttributeId, const EGameplayModOp ModOp, const TSubclassOf<class UGameplayModMagnitudeCalculation>& CalculationClassMagnitude) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitySystemComponent", "AddGeModifierByMMC");

	Params::BaseAbilitySystemComponent_AddGeModifierByMMC Parms{};

	Parms.Ge = Ge;
	Parms.ModifiedAttributeId = ModifiedAttributeId;
	Parms.ModOp = ModOp;
	Parms.CalculationClassMagnitude = CalculationClassMagnitude;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.BaseAbilitySystemComponent.AddGeModifierByTag
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UGameplayEffect*                  Ge                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ModifiedAttributeId                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayModOp                          ModOp                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ModifierTag                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseAbilitySystemComponent::AddGeModifierByTag(class UGameplayEffect* Ge, int32 ModifiedAttributeId, const EGameplayModOp ModOp, const struct FGameplayTag& ModifierTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitySystemComponent", "AddGeModifierByTag");

	Params::BaseAbilitySystemComponent_AddGeModifierByTag Parms{};

	Parms.Ge = Ge;
	Parms.ModifiedAttributeId = ModifiedAttributeId;
	Parms.ModOp = ModOp;
	Parms.ModifierTag = std::move(ModifierTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.BaseAbilitySystemComponent.HasAllGameplayTag
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTagContainer            GameplayTagContainer                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBaseAbilitySystemComponent::HasAllGameplayTag(const struct FGameplayTagContainer& GameplayTagContainer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitySystemComponent", "HasAllGameplayTag");

	Params::BaseAbilitySystemComponent_HasAllGameplayTag Parms{};

	Parms.GameplayTagContainer = std::move(GameplayTagContainer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.BaseAbilitySystemComponent.HasAnyGameplayTag
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTagContainer            GameplayTagContainer                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBaseAbilitySystemComponent::HasAnyGameplayTag(const struct FGameplayTagContainer& GameplayTagContainer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitySystemComponent", "HasAnyGameplayTag");

	Params::BaseAbilitySystemComponent_HasAnyGameplayTag Parms{};

	Parms.GameplayTagContainer = std::move(GameplayTagContainer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.BaseAbilitySystemComponent.HasGameplayTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     GameplayTag                                            (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBaseAbilitySystemComponent::HasGameplayTag(const struct FGameplayTag& GameplayTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitySystemComponent", "HasGameplayTag");

	Params::BaseAbilitySystemComponent_HasGameplayTag Parms{};

	Parms.GameplayTag = std::move(GameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.BaseAbilitySystemComponent.MakeDynamicOutgoingSpec
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UGameplayEffect*                  GameplayEffect                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEffectContextHandle     Context                                                (Parm, NativeAccessSpecifierPublic)
// int32                                   GameplayEffectServerId                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEffectSpecHandle        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayEffectSpecHandle UBaseAbilitySystemComponent::MakeDynamicOutgoingSpec(class UGameplayEffect* GameplayEffect, float Level, const struct FGameplayEffectContextHandle& Context, int32 GameplayEffectServerId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitySystemComponent", "MakeDynamicOutgoingSpec");

	Params::BaseAbilitySystemComponent_MakeDynamicOutgoingSpec Parms{};

	Parms.GameplayEffect = GameplayEffect;
	Parms.Level = Level;
	Parms.Context = std::move(Context);
	Parms.GameplayEffectServerId = GameplayEffectServerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.BaseAbilitySystemComponent.MakeRemoteDynamicOutgoingSpec
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UGameplayEffect*                  GameplayEffect                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEffectContextHandle     Context                                                (Parm, NativeAccessSpecifierPublic)
// int32                                   GameplayEffectServerId                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InGeHandleId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEffectSpecHandle        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayEffectSpecHandle UBaseAbilitySystemComponent::MakeRemoteDynamicOutgoingSpec(class UGameplayEffect* GameplayEffect, float Level, const struct FGameplayEffectContextHandle& Context, int32 GameplayEffectServerId, int32 InGeHandleId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitySystemComponent", "MakeRemoteDynamicOutgoingSpec");

	Params::BaseAbilitySystemComponent_MakeRemoteDynamicOutgoingSpec Parms{};

	Parms.GameplayEffect = GameplayEffect;
	Parms.Level = Level;
	Parms.Context = std::move(Context);
	Parms.GameplayEffectServerId = GameplayEffectServerId;
	Parms.InGeHandleId = InGeHandleId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.BaseAbilitySystemComponent.SetDurationMagnitudeByAttributeId
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UGameplayEffect*                  Ge                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttributeBasedFloatCalculationType     CalculationType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AttributeId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     DataTag                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     DataTag2                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayEffectAttributeCaptureSource   InSource                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InSnapShot                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseAbilitySystemComponent::SetDurationMagnitudeByAttributeId(class UGameplayEffect* Ge, EAttributeBasedFloatCalculationType CalculationType, int32 AttributeId, const struct FGameplayTag& DataTag, const struct FGameplayTag& DataTag2, EGameplayEffectAttributeCaptureSource InSource, bool InSnapShot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitySystemComponent", "SetDurationMagnitudeByAttributeId");

	Params::BaseAbilitySystemComponent_SetDurationMagnitudeByAttributeId Parms{};

	Parms.Ge = Ge;
	Parms.CalculationType = CalculationType;
	Parms.AttributeId = AttributeId;
	Parms.DataTag = std::move(DataTag);
	Parms.DataTag2 = std::move(DataTag2);
	Parms.InSource = InSource;
	Parms.InSnapShot = InSnapShot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.BaseAbilitySystemComponent.SetDurationMagnitudeByTag
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UGameplayEffect*                  Ge                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ModifierTag                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseAbilitySystemComponent::SetDurationMagnitudeByTag(class UGameplayEffect* Ge, const struct FGameplayTag& ModifierTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAbilitySystemComponent", "SetDurationMagnitudeByTag");

	Params::BaseAbilitySystemComponent_SetDurationMagnitudeByTag Parms{};

	Parms.Ge = Ge;
	Parms.ModifierTag = std::move(ModifierTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.BaseAttributeSet.SetAttackSpeedMax
// (Final, Native, Static, Public)
// Parameters:
// float                                   InMaxSpeed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseAttributeSet::SetAttackSpeedMax(float InMaxSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BaseAttributeSet", "SetAttackSpeedMax");

	Params::BaseAttributeSet_SetAttackSpeedMax Parms{};

	Parms.InMaxSpeed = InMaxSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.BaseAttributeSet.SetElementPowerMax
// (Final, Native, Static, Public)
// Parameters:
// float                                   InElementPowerMax                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseAttributeSet::SetElementPowerMax(float InElementPowerMax)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BaseAttributeSet", "SetElementPowerMax");

	Params::BaseAttributeSet_SetElementPowerMax Parms{};

	Parms.InElementPowerMax = InElementPowerMax;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.BaseAttributeSet.SetReduceMax
// (Final, Native, Static, Public)
// Parameters:
// float                                   InReduceMax                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseAttributeSet::SetReduceMax(float InReduceMax)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BaseAttributeSet", "SetReduceMax");

	Params::BaseAttributeSet_SetReduceMax Parms{};

	Parms.InReduceMax = InReduceMax;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.BaseAttributeSet.CopyAllAttribute
// (Final, Native, Public)
// Parameters:
// class UBaseAttributeSet*                AttributeSet                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBaseAttributeSet::CopyAllAttribute(class UBaseAttributeSet* AttributeSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAttributeSet", "CopyAllAttribute");

	Params::BaseAttributeSet_CopyAllAttribute Parms{};

	Parms.AttributeSet = AttributeSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.BaseAttributeSet.GetAttributeBaseValueById
// (Final, Native, Public)
// Parameters:
// int32                                   AttributeType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBaseAttributeSet::GetAttributeBaseValueById(int32 AttributeType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAttributeSet", "GetAttributeBaseValueById");

	Params::BaseAttributeSet_GetAttributeBaseValueById Parms{};

	Parms.AttributeType = AttributeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.BaseAttributeSet.GetAttributeCurrentValueById
// (Final, Native, Public)
// Parameters:
// int32                                   AttributeType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBaseAttributeSet::GetAttributeCurrentValueById(int32 AttributeType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAttributeSet", "GetAttributeCurrentValueById");

	Params::BaseAttributeSet_GetAttributeCurrentValueById Parms{};

	Parms.AttributeType = AttributeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.BaseAttributeSet.GetAttributeData
// (Final, Native, Public, HasOutParams)
// Parameters:
// int32                                   AttributeType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           AttributeData                                          (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBaseAttributeSet::GetAttributeData(int32 AttributeType, struct FGameplayAttributeData* AttributeData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAttributeSet", "GetAttributeData");

	Params::BaseAttributeSet_GetAttributeData Parms{};

	Parms.AttributeType = AttributeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AttributeData != nullptr)
		*AttributeData = std::move(Parms.AttributeData);

	return Parms.ReturnValue;
}


// Function KuroGAS.BaseAttributeSet.SetAttributeIntervalLock
// (Final, Native, Public)
// Parameters:
// int32                                   AttributeId                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EIntervalLockType                       LockType                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   UpperBoundPercentage                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   UpperBoundOffset                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LowerBoundPercentage                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LowerBoundOffset                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseAttributeSet::SetAttributeIntervalLock(const int32 AttributeId, const EIntervalLockType LockType, float UpperBoundPercentage, float UpperBoundOffset, float LowerBoundPercentage, float LowerBoundOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAttributeSet", "SetAttributeIntervalLock");

	Params::BaseAttributeSet_SetAttributeIntervalLock Parms{};

	Parms.AttributeId = AttributeId;
	Parms.LockType = LockType;
	Parms.UpperBoundPercentage = UpperBoundPercentage;
	Parms.UpperBoundOffset = UpperBoundOffset;
	Parms.LowerBoundPercentage = LowerBoundPercentage;
	Parms.LowerBoundOffset = LowerBoundOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.BaseAttributeSet.SetAttributeValue
// (Final, Native, Public)
// Parameters:
// int32                                   AttributeType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CurrentValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseAttributeSet::SetAttributeValue(int32 AttributeType, float BaseValue, float CurrentValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAttributeSet", "SetAttributeValue");

	Params::BaseAttributeSet_SetAttributeValue Parms{};

	Parms.AttributeType = AttributeType;
	Parms.BaseValue = BaseValue;
	Parms.CurrentValue = CurrentValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.BaseCharacter.CreateAttribute
// (Final, Native, Public, BlueprintCallable)

void ABaseCharacter::CreateAttribute()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseCharacter", "CreateAttribute");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.BaseCharacter.InitializeAttributeSet
// (Final, Native, Public, BlueprintCallable)

void ABaseCharacter::InitializeAttributeSet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseCharacter", "InitializeAttributeSet");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.BaseCharacter.PreInit
// (Final, Native, Public, BlueprintCallable)

void ABaseCharacter::PreInit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseCharacter", "PreInit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.BaseCharacter.RefreshCachedTransform
// (Final, Native, Public, BlueprintCallable)

void ABaseCharacter::RefreshCachedTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseCharacter", "RefreshCachedTransform");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.BaseCharacter.RefreshCachedVelocity
// (Final, Native, Public, BlueprintCallable)

void ABaseCharacter::RefreshCachedVelocity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseCharacter", "RefreshCachedVelocity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.BaseCharacter.SetActorLocationAndRotationExceptSkelMesh
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NewLocation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         NewRotation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreOverlap                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseCharacter::SetActorLocationAndRotationExceptSkelMesh(const struct FVector& NewLocation, const struct FRotator& NewRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport, bool bIgnoreOverlap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseCharacter", "SetActorLocationAndRotationExceptSkelMesh");

	Params::BaseCharacter_SetActorLocationAndRotationExceptSkelMesh Parms{};

	Parms.NewLocation = std::move(NewLocation);
	Parms.NewRotation = std::move(NewRotation);
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;
	Parms.bIgnoreOverlap = bIgnoreOverlap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

	return Parms.ReturnValue;
}


// Function KuroGAS.BaseCharacter.SetActorTransformExceptSkelMesh
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       NewTransform                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreOverlap                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseCharacter::SetActorTransformExceptSkelMesh(const struct FTransform& NewTransform, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport, bool bIgnoreOverlap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseCharacter", "SetActorTransformExceptSkelMesh");

	Params::BaseCharacter_SetActorTransformExceptSkelMesh Parms{};

	Parms.NewTransform = std::move(NewTransform);
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;
	Parms.bIgnoreOverlap = bIgnoreOverlap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

	return Parms.ReturnValue;
}


// Function KuroGAS.BaseCharacter.ContainsAllTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTagContainer            TagToCheck                                             (ConstParm, Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseCharacter::ContainsAllTag(const struct FGameplayTagContainer& TagToCheck) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseCharacter", "ContainsAllTag");

	Params::BaseCharacter_ContainsAllTag Parms{};

	Parms.TagToCheck = std::move(TagToCheck);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.BaseCharacter.ContainsAnyTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTagContainer            TagToCheck                                             (ConstParm, Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseCharacter::ContainsAnyTag(const struct FGameplayTagContainer& TagToCheck) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseCharacter", "ContainsAnyTag");

	Params::BaseCharacter_ContainsAnyTag Parms{};

	Parms.TagToCheck = std::move(TagToCheck);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.BaseCharacter.ContainsTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     TagToCheck                                             (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseCharacter::ContainsTag(const struct FGameplayTag& TagToCheck) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseCharacter", "ContainsTag");

	Params::BaseCharacter_ContainsTag Parms{};

	Parms.TagToCheck = std::move(TagToCheck);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.BaseGameplayAbility.GetCallerMagnitudeByTag
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     Tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBaseGameplayAbility::GetCallerMagnitudeByTag(const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseGameplayAbility", "GetCallerMagnitudeByTag");

	Params::BaseGameplayAbility_GetCallerMagnitudeByTag Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.BaseGameplayAbility.PreAvatarSet
// (Event, Public, BlueprintEvent)

void UBaseGameplayAbility::PreAvatarSet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseGameplayAbility", "PreAvatarSet");

	UObject::ProcessEvent(Func, nullptr);
}


// Function KuroGAS.BaseGameplayEffectExecutionCalculation.ExecuteImplementation
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// int64                                   GameplayEffectId                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StackNum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEffectContextHandle     Context                                                (Parm, NativeAccessSpecifierPublic)
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseGameplayEffectExecutionCalculation::ExecuteImplementation(int64 GameplayEffectId, float Level, int32 StackNum, const struct FGameplayEffectContextHandle& Context, class AActor* Instigator, class AActor* Target) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseGameplayEffectExecutionCalculation", "ExecuteImplementation");

	Params::BaseGameplayEffectExecutionCalculation_ExecuteImplementation Parms{};

	Parms.GameplayEffectId = GameplayEffectId;
	Parms.Level = Level;
	Parms.StackNum = StackNum;
	Parms.Context = std::move(Context);
	Parms.Instigator = Instigator;
	Parms.Target = Target;

	UObject::ProcessEvent(Func, &Parms);
}


// Function KuroGAS.BaseGameplayModMagnitudeCalculation.CalculationImplementation
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// int64                                   GameplayEffectId                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StackNum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBaseGameplayModMagnitudeCalculation::CalculationImplementation(int64 GameplayEffectId, float Level, int32 StackNum, class AActor* Instigator, class AActor* Target) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseGameplayModMagnitudeCalculation", "CalculationImplementation");

	Params::BaseGameplayModMagnitudeCalculation_CalculationImplementation Parms{};

	Parms.GameplayEffectId = GameplayEffectId;
	Parms.Level = Level;
	Parms.StackNum = StackNum;
	Parms.Instigator = Instigator;
	Parms.Target = Target;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.AddDataTableRowByName_EditorOnly
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UDataTable*                       DataTable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStruct*                          Data                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGASBPLibrary::AddDataTableRowByName_EditorOnly(class UDataTable* DataTable, class FName Name_0, class UStruct* Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "AddDataTableRowByName_EditorOnly");

	Params::GASBPLibrary_AddDataTableRowByName_EditorOnly Parms{};

	Parms.DataTable = DataTable;
	Parms.Name_0 = Name_0;
	Parms.Data = Data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.AddEffectContextTarget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FGameplayEffectContextHandle     EffectContext                                          (Parm, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGASBPLibrary::AddEffectContextTarget(const struct FGameplayEffectContextHandle& EffectContext, class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "AddEffectContextTarget");

	Params::GASBPLibrary_AddEffectContextTarget Parms{};

	Parms.EffectContext = std::move(EffectContext);
	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.GASBPLibrary.AddGameplayTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            TagContainer                                           (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   TagHash                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGASBPLibrary::AddGameplayTag(struct FGameplayTagContainer& TagContainer, int32 TagHash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "AddGameplayTag");

	Params::GASBPLibrary_AddGameplayTag Parms{};

	Parms.TagContainer = std::move(TagContainer);
	Parms.TagHash = TagHash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	TagContainer = std::move(Parms.TagContainer);
}


// Function KuroGAS.GASBPLibrary.AddGrantedTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FGameplayEffectSpecHandle        SpecHandle                                             (Parm, NativeAccessSpecifierPublic)
// int32                                   TagHash                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEffectSpecHandle        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayEffectSpecHandle UGASBPLibrary::AddGrantedTag(const struct FGameplayEffectSpecHandle& SpecHandle, int32 TagHash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "AddGrantedTag");

	Params::GASBPLibrary_AddGrantedTag Parms{};

	Parms.SpecHandle = std::move(SpecHandle);
	Parms.TagHash = TagHash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.AddTagToActor
// (Final, Native, Static, Public)
// Parameters:
// class UAbilitySystemComponent*          Asc                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InTagHash                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MarkTagHash                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGASBPLibrary::AddTagToActor(class UAbilitySystemComponent* Asc, const int32 InTagHash, const int32 MarkTagHash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "AddTagToActor");

	Params::GASBPLibrary_AddTagToActor Parms{};

	Parms.Asc = Asc;
	Parms.InTagHash = InTagHash;
	Parms.MarkTagHash = MarkTagHash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.EnsureGameplayTagDataTableLoaded
// (Final, Native, Static, Public, BlueprintCallable)

void UGASBPLibrary::EnsureGameplayTagDataTableLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "EnsureGameplayTagDataTableLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.GASBPLibrary.FindAllBlueprintAsset
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             BaseClassName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FAssetData>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FAssetData> UGASBPLibrary::FindAllBlueprintAsset(class FName BaseClassName, const class FString& Path)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "FindAllBlueprintAsset");

	Params::GASBPLibrary_FindAllBlueprintAsset Parms{};

	Parms.BaseClassName = BaseClassName;
	Parms.Path = std::move(Path);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.FnvHash
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Str                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGASBPLibrary::FnvHash(const class FString& Str)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "FnvHash");

	Params::GASBPLibrary_FnvHash Parms{};

	Parms.Str = std::move(Str);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.GetActiveBuffAssetTags
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   HandleId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer UGASBPLibrary::GetActiveBuffAssetTags(int32 HandleId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "GetActiveBuffAssetTags");

	Params::GASBPLibrary_GetActiveBuffAssetTags Parms{};

	Parms.HandleId = HandleId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.GetActiveBuffContextHandle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   HandleId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEffectContextHandle     ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayEffectContextHandle UGASBPLibrary::GetActiveBuffContextHandle(int32 HandleId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "GetActiveBuffContextHandle");

	Params::GASBPLibrary_GetActiveBuffContextHandle Parms{};

	Parms.HandleId = HandleId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.GetActiveBuffDebugAttributeString
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   HandleId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UGASBPLibrary::GetActiveBuffDebugAttributeString(int32 HandleId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "GetActiveBuffDebugAttributeString");

	Params::GASBPLibrary_GetActiveBuffDebugAttributeString Parms{};

	Parms.HandleId = HandleId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.GetActiveBuffDebugString
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   HandleId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UGASBPLibrary::GetActiveBuffDebugString(int32 HandleId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "GetActiveBuffDebugString");

	Params::GASBPLibrary_GetActiveBuffDebugString Parms{};

	Parms.HandleId = HandleId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.GetActiveBuffGrantedTags
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   HandleId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer UGASBPLibrary::GetActiveBuffGrantedTags(int32 HandleId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "GetActiveBuffGrantedTags");

	Params::GASBPLibrary_GetActiveBuffGrantedTags Parms{};

	Parms.HandleId = HandleId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.GetActiveBuffId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   HandleId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UGASBPLibrary::GetActiveBuffId(int32 HandleId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "GetActiveBuffId");

	Params::GASBPLibrary_GetActiveBuffId Parms{};

	Parms.HandleId = HandleId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.GetActiveBuffInstigator
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   HandleId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UGASBPLibrary::GetActiveBuffInstigator(int32 HandleId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "GetActiveBuffInstigator");

	Params::GASBPLibrary_GetActiveBuffInstigator Parms{};

	Parms.HandleId = HandleId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.GetActiveBuffLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   HandleId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGASBPLibrary::GetActiveBuffLevel(int32 HandleId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "GetActiveBuffLevel");

	Params::GASBPLibrary_GetActiveBuffLevel Parms{};

	Parms.HandleId = HandleId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.GetActiveBuffPeriod
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   HandleId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGASBPLibrary::GetActiveBuffPeriod(int32 HandleId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "GetActiveBuffPeriod");

	Params::GASBPLibrary_GetActiveBuffPeriod Parms{};

	Parms.HandleId = HandleId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.GetActiveBuffRemainingDuration
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   HandleId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGASBPLibrary::GetActiveBuffRemainingDuration(int32 HandleId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "GetActiveBuffRemainingDuration");

	Params::GASBPLibrary_GetActiveBuffRemainingDuration Parms{};

	Parms.HandleId = HandleId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.GetActiveBuffServerId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   HandleId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGASBPLibrary::GetActiveBuffServerId(int32 HandleId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "GetActiveBuffServerId");

	Params::GASBPLibrary_GetActiveBuffServerId Parms{};

	Parms.HandleId = HandleId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.GetActiveBuffStackCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   HandleId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGASBPLibrary::GetActiveBuffStackCount(int32 HandleId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "GetActiveBuffStackCount");

	Params::GASBPLibrary_GetActiveBuffStackCount Parms{};

	Parms.HandleId = HandleId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.GetActiveBuffTotalDuration
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   HandleId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGASBPLibrary::GetActiveBuffTotalDuration(int32 HandleId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "GetActiveBuffTotalDuration");

	Params::GASBPLibrary_GetActiveBuffTotalDuration Parms{};

	Parms.HandleId = HandleId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.GetActiveGameplayEffectAssetTags
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FActiveGameplayEffectHandle      ActiveHandle                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer UGASBPLibrary::GetActiveGameplayEffectAssetTags(const struct FActiveGameplayEffectHandle& ActiveHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "GetActiveGameplayEffectAssetTags");

	Params::GASBPLibrary_GetActiveGameplayEffectAssetTags Parms{};

	Parms.ActiveHandle = std::move(ActiveHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.GetActiveGameplayEffectDebugString
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FActiveGameplayEffectHandle      ActiveHandle                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UGASBPLibrary::GetActiveGameplayEffectDebugString(const struct FActiveGameplayEffectHandle& ActiveHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "GetActiveGameplayEffectDebugString");

	Params::GASBPLibrary_GetActiveGameplayEffectDebugString Parms{};

	Parms.ActiveHandle = std::move(ActiveHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.GetActiveGameplayEffectGrantedTags
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FActiveGameplayEffectHandle      ActiveHandle                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer UGASBPLibrary::GetActiveGameplayEffectGrantedTags(const struct FActiveGameplayEffectHandle& ActiveHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "GetActiveGameplayEffectGrantedTags");

	Params::GASBPLibrary_GetActiveGameplayEffectGrantedTags Parms{};

	Parms.ActiveHandle = std::move(ActiveHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.GetActiveGameplayEffectHandleEffectContext
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FActiveGameplayEffectHandle      Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEffectContextHandle     ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayEffectContextHandle UGASBPLibrary::GetActiveGameplayEffectHandleEffectContext(const struct FActiveGameplayEffectHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "GetActiveGameplayEffectHandleEffectContext");

	Params::GASBPLibrary_GetActiveGameplayEffectHandleEffectContext Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.GetActiveGameplayEffectHandleGeId
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FActiveGameplayEffectHandle      Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UGASBPLibrary::GetActiveGameplayEffectHandleGeId(const struct FActiveGameplayEffectHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "GetActiveGameplayEffectHandleGeId");

	Params::GASBPLibrary_GetActiveGameplayEffectHandleGeId Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.GetActiveGameplayEffectHandleInstigator
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FActiveGameplayEffectHandle      Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UGASBPLibrary::GetActiveGameplayEffectHandleInstigator(const struct FActiveGameplayEffectHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "GetActiveGameplayEffectHandleInstigator");

	Params::GASBPLibrary_GetActiveGameplayEffectHandleInstigator Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.GetActiveGameplayEffectHandleLevel
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FActiveGameplayEffectHandle      Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGASBPLibrary::GetActiveGameplayEffectHandleLevel(const struct FActiveGameplayEffectHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "GetActiveGameplayEffectHandleLevel");

	Params::GASBPLibrary_GetActiveGameplayEffectHandleLevel Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.GetActiveGameplayEffectModifiedAttributes
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FActiveGameplayEffectHandle      ActiveHandle                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGameplayAttribute>       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FGameplayAttribute> UGASBPLibrary::GetActiveGameplayEffectModifiedAttributes(const struct FActiveGameplayEffectHandle& ActiveHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "GetActiveGameplayEffectModifiedAttributes");

	Params::GASBPLibrary_GetActiveGameplayEffectModifiedAttributes Parms{};

	Parms.ActiveHandle = std::move(ActiveHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.GetActiveGameplayEffectPeriod
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FActiveGameplayEffectHandle      ActiveHandle                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGASBPLibrary::GetActiveGameplayEffectPeriod(const struct FActiveGameplayEffectHandle& ActiveHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "GetActiveGameplayEffectPeriod");

	Params::GASBPLibrary_GetActiveGameplayEffectPeriod Parms{};

	Parms.ActiveHandle = std::move(ActiveHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.GetActiveGameplayEffectServerId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FActiveGameplayEffectHandle      ActiveHandle                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGASBPLibrary::GetActiveGameplayEffectServerId(const struct FActiveGameplayEffectHandle& ActiveHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "GetActiveGameplayEffectServerId");

	Params::GASBPLibrary_GetActiveGameplayEffectServerId Parms{};

	Parms.ActiveHandle = std::move(ActiveHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.GetAllTagsByParentTags
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          ASC                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     Query                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            Result                                                 (Parm, OutParm, NativeAccessSpecifierPublic)

void UGASBPLibrary::GetAllTagsByParentTags(class UAbilitySystemComponent* ASC, const struct FGameplayTag& Query, struct FGameplayTagContainer* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "GetAllTagsByParentTags");

	Params::GASBPLibrary_GetAllTagsByParentTags Parms{};

	Parms.ASC = ASC;
	Parms.Query = std::move(Query);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}


// Function KuroGAS.GASBPLibrary.GetAssetPath
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UGASBPLibrary::GetAssetPath(class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "GetAssetPath");

	Params::GASBPLibrary_GetAssetPath Parms{};

	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.GetGameplayAbilitySourceGE
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameplayAbility*                 GameplayAbility                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActiveGameplayEffectHandle      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FActiveGameplayEffectHandle UGASBPLibrary::GetGameplayAbilitySourceGE(const class UGameplayAbility* GameplayAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "GetGameplayAbilitySourceGE");

	Params::GASBPLibrary_GetGameplayAbilitySourceGE Parms{};

	Parms.GameplayAbility = GameplayAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.GetGameplayAbilitySystemActivatableAbilitiesDebugString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAbilitySystemComponent*          ASC                                                    (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UGASBPLibrary::GetGameplayAbilitySystemActivatableAbilitiesDebugString(const class UAbilitySystemComponent* ASC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "GetGameplayAbilitySystemActivatableAbilitiesDebugString");

	Params::GASBPLibrary_GetGameplayAbilitySystemActivatableAbilitiesDebugString Parms{};

	Parms.ASC = ASC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.GetGameplayCueNotify
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     GameplayTag                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSoftObjectPath                  OutSoftObjectPath                                      (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGASBPLibrary::GetGameplayCueNotify(const struct FGameplayTag& GameplayTag, struct FSoftObjectPath* OutSoftObjectPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "GetGameplayCueNotify");

	Params::GASBPLibrary_GetGameplayCueNotify Parms{};

	Parms.GameplayTag = std::move(GameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSoftObjectPath != nullptr)
		*OutSoftObjectPath = std::move(Parms.OutSoftObjectPath);
}


// Function KuroGAS.GASBPLibrary.GetGameplayEffectContextTarget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayEffectContextHandle     Handle                                                 (Parm, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UGASBPLibrary::GetGameplayEffectContextTarget(const struct FGameplayEffectContextHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "GetGameplayEffectContextTarget");

	Params::GASBPLibrary_GetGameplayEffectContextTarget Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.GetGameplayTagFromTagHash
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   TagHash                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UGASBPLibrary::GetGameplayTagFromTagHash(int32 TagHash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "GetGameplayTagFromTagHash");

	Params::GASBPLibrary_GetGameplayTagFromTagHash Parms{};

	Parms.TagHash = TagHash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.GetGameplayTagId
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     Tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGASBPLibrary::GetGameplayTagId(const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "GetGameplayTagId");

	Params::GASBPLibrary_GetGameplayTagId Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.GetGameplayTags
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TMap<int32, struct FGameplayTag>        Tags                                                   (Parm, OutParm, NativeAccessSpecifierPublic)

void UGASBPLibrary::GetGameplayTags(TMap<int32, struct FGameplayTag>* Tags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "GetGameplayTags");

	Params::GASBPLibrary_GetGameplayTags Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Tags != nullptr)
		*Tags = std::move(Parms.Tags);
}


// Function KuroGAS.GASBPLibrary.GetNetworkGameplayTagNodeIndexHash
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UGASBPLibrary::GetNetworkGameplayTagNodeIndexHash()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "GetNetworkGameplayTagNodeIndexHash");

	Params::GASBPLibrary_GetNetworkGameplayTagNodeIndexHash Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.GetOwnedGameplayTags
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          ASC                                                    (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            TargetContainer                                        (Parm, OutParm, NativeAccessSpecifierPublic)

void UGASBPLibrary::GetOwnedGameplayTags(const class UAbilitySystemComponent* ASC, struct FGameplayTagContainer* TargetContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "GetOwnedGameplayTags");

	Params::GASBPLibrary_GetOwnedGameplayTags Parms{};

	Parms.ASC = ASC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (TargetContainer != nullptr)
		*TargetContainer = std::move(Parms.TargetContainer);
}


// Function KuroGAS.GASBPLibrary.IsActiveBuffInhibited
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   HandleId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGASBPLibrary::IsActiveBuffInhibited(int32 HandleId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "IsActiveBuffInhibited");

	Params::GASBPLibrary_IsActiveBuffInhibited Parms{};

	Parms.HandleId = HandleId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.IsActiveGameplayEffectInhibited
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FActiveGameplayEffectHandle      ActiveHandle                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGASBPLibrary::IsActiveGameplayEffectInhibited(const struct FActiveGameplayEffectHandle& ActiveHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "IsActiveGameplayEffectInhibited");

	Params::GASBPLibrary_IsActiveGameplayEffectInhibited Parms{};

	Parms.ActiveHandle = std::move(ActiveHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.IterateStructAndAssignAttributeSet
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UBaseAttributeSet*                AttributeSet                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStruct*                          Data                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGASBPLibrary::IterateStructAndAssignAttributeSet(class UBaseAttributeSet* AttributeSet, class UStruct* Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "IterateStructAndAssignAttributeSet");

	Params::GASBPLibrary_IterateStructAndAssignAttributeSet Parms{};

	Parms.AttributeSet = AttributeSet;
	Parms.Data = Data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.GASBPLibrary.MakeGameplayTagContainerFromTagHash
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   TagHash                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer UGASBPLibrary::MakeGameplayTagContainerFromTagHash(int32 TagHash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "MakeGameplayTagContainerFromTagHash");

	Params::GASBPLibrary_MakeGameplayTagContainerFromTagHash Parms{};

	Parms.TagHash = TagHash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.RemoveActiveBuff
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          Asc                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   HandleId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StacksToRemove                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGASBPLibrary::RemoveActiveBuff(class UAbilitySystemComponent* Asc, int32 HandleId, int32 StacksToRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "RemoveActiveBuff");

	Params::GASBPLibrary_RemoveActiveBuff Parms{};

	Parms.Asc = Asc;
	Parms.HandleId = HandleId;
	Parms.StacksToRemove = StacksToRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.RemoveAllDurationGameplayEffects
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          ASC                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGASBPLibrary::RemoveAllDurationGameplayEffects(class UAbilitySystemComponent* ASC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "RemoveAllDurationGameplayEffects");

	Params::GASBPLibrary_RemoveAllDurationGameplayEffects Parms{};

	Parms.ASC = ASC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.GASBPLibrary.RemoveAllGameplayEffects
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          ASC                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGASBPLibrary::RemoveAllGameplayEffects(class UAbilitySystemComponent* ASC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "RemoveAllGameplayEffects");

	Params::GASBPLibrary_RemoveAllGameplayEffects Parms{};

	Parms.ASC = ASC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.GASBPLibrary.RemoveBuffByTagFromActor
// (Final, Native, Static, Public)
// Parameters:
// class UAbilitySystemComponent*          Asc                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InTagHash                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MarkTagHash                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGASBPLibrary::RemoveBuffByTagFromActor(class UAbilitySystemComponent* Asc, const int32 InTagHash, const int32 MarkTagHash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "RemoveBuffByTagFromActor");

	Params::GASBPLibrary_RemoveBuffByTagFromActor Parms{};

	Parms.Asc = Asc;
	Parms.InTagHash = InTagHash;
	Parms.MarkTagHash = MarkTagHash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.GASBPLibrary.RemoveTagFromActor
// (Final, Native, Static, Public)
// Parameters:
// class UAbilitySystemComponent*          Asc                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InTagHash                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MarkTagHash                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGASBPLibrary::RemoveTagFromActor(class UAbilitySystemComponent* Asc, const int32 InTagHash, const int32 MarkTagHash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "RemoveTagFromActor");

	Params::GASBPLibrary_RemoveTagFromActor Parms{};

	Parms.Asc = Asc;
	Parms.InTagHash = InTagHash;
	Parms.MarkTagHash = MarkTagHash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.GASBPLibrary.ResetGameplayEffectSpecPeriod
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FGameplayEffectSpecHandle        SpecHandle                                             (Parm, NativeAccessSpecifierPublic)
// float                                   NewPeriod                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEffectSpecHandle        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayEffectSpecHandle UGASBPLibrary::ResetGameplayEffectSpecPeriod(const struct FGameplayEffectSpecHandle& SpecHandle, float NewPeriod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "ResetGameplayEffectSpecPeriod");

	Params::GASBPLibrary_ResetGameplayEffectSpecPeriod Parms{};

	Parms.SpecHandle = std::move(SpecHandle);
	Parms.NewPeriod = NewPeriod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGAS.GASBPLibrary.SetAttributeValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UBaseAttributeSet*                AttributeSet                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStruct*                          InStruct                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGASBPLibrary::SetAttributeValue(class UBaseAttributeSet* AttributeSet, class UStruct* InStruct)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "SetAttributeValue");

	Params::GASBPLibrary_SetAttributeValue Parms{};

	Parms.AttributeSet = AttributeSet;
	Parms.InStruct = InStruct;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.GASBPLibrary.SetNeedSyncAttributes
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSet<int32>                             SourceNeedSyncAttributes                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGASBPLibrary::SetNeedSyncAttributes(const TSet<int32>& SourceNeedSyncAttributes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "SetNeedSyncAttributes");

	Params::GASBPLibrary_SetNeedSyncAttributes Parms{};

	Parms.SourceNeedSyncAttributes = std::move(SourceNeedSyncAttributes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGAS.GASBPLibrary.SetRootComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  NewRootComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGASBPLibrary::SetRootComponent(class AActor* TargetActor, class USceneComponent* NewRootComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GASBPLibrary", "SetRootComponent");

	Params::GASBPLibrary_SetRootComponent Parms{};

	Parms.TargetActor = TargetActor;
	Parms.NewRootComponent = NewRootComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

