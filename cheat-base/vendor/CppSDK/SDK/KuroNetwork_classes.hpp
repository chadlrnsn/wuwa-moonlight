#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroNetwork

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "KuroNetwork_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "JsEnv_structs.hpp"


namespace SDK
{

// Class KuroNetwork.KuroHttp
// 0x0000 (0x0030 - 0x0030)
class UKuroHttp final : public UBlueprintFunctionLibrary
{
public:
	static void CompressAndPostDataAsync(const class FString& URL, const TMap<class FString, class FString>& HeaderParam, ECompressMethod CompressMethod, const struct FArrayBuffer& Buffer, TDelegate<void(bool Successed)> PostHandle, float InTimeout);
	static void CompressDataAsync(const struct FArrayBuffer& InBuffer, ECompressMethod CompressMethod, const TDelegate<void(TArray<uint8>& Data, int32 SizeNeededForDecompress)>& OnCompressed);
	static void CompressStringAsync(const class FString& InString, ECompressMethod CompressMethod, const TDelegate<void(TArray<uint8>& Data, int32 SizeNeededForDecompress)>& OnCompressed);
	static void Get(const class FString& URL, const TMap<class FString, class FString>& HeaderParam, TDelegate<void(bool Success, int32 Code, const class FString& Data)> Handle, float InTimeout);
	static TMap<class FString, class FString> GetDefaultHeader();
	static void Post(const class FString& URL, const TMap<class FString, class FString>& HeaderParam, const class FString& Content, TDelegate<void(bool Success, int32 Code, const class FString& Data)> Handle, float InTimeout);
	static void PostWithData(const class FString& URL, const TMap<class FString, class FString>& HeaderParam, const TArray<uint8>& Content, TDelegate<void(bool Success, int32 Code, const class FString& Data)> Handle, float InTimeout);
	static void PostWithFile(const class FString& URL, const TMap<class FString, class FString>& HeaderParam, const class FString& FilePath, TDelegate<void(bool Success, int32 Code, const class FString& Data)> Handle, float InTimeout);
	static void UnCompressDataToStringAsync(const TArray<uint8>& Data, ECompressMethod CompressMethod, int32 PresumedUnCompressedSize, TDelegate<void(const class FString& String)> OnDecompressed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroHttp">();
	}
	static class UKuroHttp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroHttp>();
	}
};
static_assert(alignof(UKuroHttp) == 0x000008, "Wrong alignment on UKuroHttp");
static_assert(sizeof(UKuroHttp) == 0x000030, "Wrong size on UKuroHttp");

// Class KuroNetwork.KuroHttpServerRequestProxy
// 0x0080 (0x00B0 - 0x0030)
class UKuroHttpServerRequestProxy final : public UObject
{
public:
	uint8                                         Pad_30[0x80];                                      // 0x0030(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetHeader(const class FString& Key, TArray<class FString>* OutHeader);
	class FString GetRequest();
	void Response(const class FString& Json, const bool bSuccess);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroHttpServerRequestProxy">();
	}
	static class UKuroHttpServerRequestProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroHttpServerRequestProxy>();
	}
};
static_assert(alignof(UKuroHttpServerRequestProxy) == 0x000008, "Wrong alignment on UKuroHttpServerRequestProxy");
static_assert(sizeof(UKuroHttpServerRequestProxy) == 0x0000B0, "Wrong size on UKuroHttpServerRequestProxy");

// Class KuroNetwork.KuroHttpServerRouterProxy
// 0x0088 (0x00B8 - 0x0030)
class UKuroHttpServerRouterProxy final : public UObject
{
public:
	TDelegate<void(const class FString& ModuleName, class UKuroHttpServerRequestProxy* RequestProxy)> HttpRequestDelegate;                               // 0x0030(0x0028)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x60];                                      // 0x0058(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindRoute(const class FString& ModuleName);
	void CreateRouter(const int32 Port);
	void StartServer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroHttpServerRouterProxy">();
	}
	static class UKuroHttpServerRouterProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroHttpServerRouterProxy>();
	}
};
static_assert(alignof(UKuroHttpServerRouterProxy) == 0x000008, "Wrong alignment on UKuroHttpServerRouterProxy");
static_assert(sizeof(UKuroHttpServerRouterProxy) == 0x0000B8, "Wrong size on UKuroHttpServerRouterProxy");
static_assert(offsetof(UKuroHttpServerRouterProxy, HttpRequestDelegate) == 0x000030, "Member 'UKuroHttpServerRouterProxy::HttpRequestDelegate' has a wrong offset!");

// Class KuroNetwork.KuroKcpClient
// 0x0228 (0x0258 - 0x0030)
class UKuroKcpClient final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnConnectSuccess;                                  // 0x0038(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(int32 SeqNo, int16 RpdId, uint16 MessageId, const struct FArrayBuffer& MessageBuffer)> OnRecResp;                                         // 0x0048(0x0028)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(int32 SeqNo, int16 RpdId, uint32 ErrorCode, const struct FArrayBuffer& StringBuffer)> OnRecException;                                    // 0x0070(0x0028)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(int32 SeqNo, uint16 MessageId, const struct FArrayBuffer& MessageBuffer)> OnRecPush;                                         // 0x0098(0x0028)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(int32 Code1, int32 Code2, int32 Code3, int32 Code4, int32 Code5)> OnError;                                           // 0x00C0(0x0028)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	bool                                          UseNewResolveIp;                                   // 0x00E8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMultiThreaded;                                   // 0x00E9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTickDrivenOutside;                               // 0x00EA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EB[0x16D];                                     // 0x00EB(0x016D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetEnType(uint8 Type, int16 MsgId);
	bool SetK(uint8 Type, const struct FArrayBuffer& KeyBuffer);
	void SetKcpMtu(int32 Mtu);
	void SetKcpNoDelay(int32 NoDelay, int32 Interval, int32 Resend, int32 Nc);
	void SetKcpSegmentSize(int32 SegmentSize);
	void SetKcpStream(bool bStream);
	void SetKcpWndSize(int32 SndWnd, int32 RcvWnd);
	void TickOutside(float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroKcpClient">();
	}
	static class UKuroKcpClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroKcpClient>();
	}
};
static_assert(alignof(UKuroKcpClient) == 0x000008, "Wrong alignment on UKuroKcpClient");
static_assert(sizeof(UKuroKcpClient) == 0x000258, "Wrong size on UKuroKcpClient");
static_assert(offsetof(UKuroKcpClient, OnConnectSuccess) == 0x000038, "Member 'UKuroKcpClient::OnConnectSuccess' has a wrong offset!");
static_assert(offsetof(UKuroKcpClient, OnRecResp) == 0x000048, "Member 'UKuroKcpClient::OnRecResp' has a wrong offset!");
static_assert(offsetof(UKuroKcpClient, OnRecException) == 0x000070, "Member 'UKuroKcpClient::OnRecException' has a wrong offset!");
static_assert(offsetof(UKuroKcpClient, OnRecPush) == 0x000098, "Member 'UKuroKcpClient::OnRecPush' has a wrong offset!");
static_assert(offsetof(UKuroKcpClient, OnError) == 0x0000C0, "Member 'UKuroKcpClient::OnError' has a wrong offset!");
static_assert(offsetof(UKuroKcpClient, UseNewResolveIp) == 0x0000E8, "Member 'UKuroKcpClient::UseNewResolveIp' has a wrong offset!");
static_assert(offsetof(UKuroKcpClient, IsMultiThreaded) == 0x0000E9, "Member 'UKuroKcpClient::IsMultiThreaded' has a wrong offset!");
static_assert(offsetof(UKuroKcpClient, IsTickDrivenOutside) == 0x0000EA, "Member 'UKuroKcpClient::IsTickDrivenOutside' has a wrong offset!");

// Class KuroNetwork.KuroNetworkChange
// 0x0020 (0x0050 - 0x0030)
class UKuroNetworkChange final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             NetworkChangeDelegate;                             // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	uint8 GetNetworkType();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroNetworkChange">();
	}
	static class UKuroNetworkChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroNetworkChange>();
	}
};
static_assert(alignof(UKuroNetworkChange) == 0x000008, "Wrong alignment on UKuroNetworkChange");
static_assert(sizeof(UKuroNetworkChange) == 0x000050, "Wrong size on UKuroNetworkChange");
static_assert(offsetof(UKuroNetworkChange, NetworkChangeDelegate) == 0x000030, "Member 'UKuroNetworkChange::NetworkChangeDelegate' has a wrong offset!");

// Class KuroNetwork.KuroNetworkSetting
// 0x0058 (0x0088 - 0x0030)
class UKuroNetworkSetting final : public UObject
{
public:
	struct FKuroPublicKey                         ServerPublicKey;                                   // 0x0030(0x0020)(Edit, Config, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FKuroPrivateKey                        ClientPrivateKey;                                  // 0x0050(0x0030)(Edit, Config, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          EnableDump;                                        // 0x0080(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroNetworkSetting">();
	}
	static class UKuroNetworkSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroNetworkSetting>();
	}
};
static_assert(alignof(UKuroNetworkSetting) == 0x000008, "Wrong alignment on UKuroNetworkSetting");
static_assert(sizeof(UKuroNetworkSetting) == 0x000088, "Wrong size on UKuroNetworkSetting");
static_assert(offsetof(UKuroNetworkSetting, ServerPublicKey) == 0x000030, "Member 'UKuroNetworkSetting::ServerPublicKey' has a wrong offset!");
static_assert(offsetof(UKuroNetworkSetting, ClientPrivateKey) == 0x000050, "Member 'UKuroNetworkSetting::ClientPrivateKey' has a wrong offset!");
static_assert(offsetof(UKuroNetworkSetting, EnableDump) == 0x000080, "Member 'UKuroNetworkSetting::EnableDump' has a wrong offset!");

// Class KuroNetwork.SendHttpRequest
// 0x0020 (0x0058 - 0x0038)
class USendHttpRequest final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFail;                                            // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USendHttpRequest* HttpRequest(const class FString& URL, EHttpMethod Method, const class FString& PostBody);
	static class USendHttpRequest* HttpRequestEx(const class FString& URL, EHttpMethod Method, const class FString& PostBody, const class FString& HeaderParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SendHttpRequest">();
	}
	static class USendHttpRequest* GetDefaultObj()
	{
		return GetDefaultObjImpl<USendHttpRequest>();
	}
};
static_assert(alignof(USendHttpRequest) == 0x000008, "Wrong alignment on USendHttpRequest");
static_assert(sizeof(USendHttpRequest) == 0x000058, "Wrong size on USendHttpRequest");
static_assert(offsetof(USendHttpRequest, OnSuccess) == 0x000038, "Member 'USendHttpRequest::OnSuccess' has a wrong offset!");
static_assert(offsetof(USendHttpRequest, OnFail) == 0x000048, "Member 'USendHttpRequest::OnFail' has a wrong offset!");

}

