#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroAnim

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "AnimGraphRuntime_structs.hpp"


namespace SDK
{

// Enum KuroAnim.ECombineCurveMode
// NumValues: 0x0005
enum class ECombineCurveMode : uint8
{
	Replenish                                = 0,
	Accumulate                               = 1,
	Override                                 = 2,
	CleanAndOverride                         = 3,
	ECombineCurveMode_MAX                    = 4,
};

// Enum KuroAnim.ECollisionType
// NumValues: 0x0006
enum class ECollisionType : uint8
{
	None                                     = 0,
	Spherical                                = 1,
	Cylinder                                 = 2,
	Capsule                                  = 3,
	Planar                                   = 4,
	ECollisionType_MAX                       = 5,
};

// Enum KuroAnim.EClothType
// NumValues: 0x0004
enum class EClothType : uint8
{
	Line                                     = 0,
	Cloth                                    = 1,
	Dress                                    = 2,
	EClothType_MAX                           = 3,
};

// Enum KuroAnim.EAdjustBoxType
// NumValues: 0x0003
enum class EAdjustBoxType : uint8
{
	OpenMode                                 = 0,
	AlwaysVertical                           = 1,
	EAdjustBoxType_MAX                       = 2,
};

// Enum KuroAnim.EAdjustCapsuleType
// NumValues: 0x0004
enum class EAdjustCapsuleType : uint8
{
	OpenMode                                 = 0,
	ThreeDimension                           = 1,
	AlwaysVertical                           = 2,
	EAdjustCapsuleType_MAX                   = 3,
};

// Enum KuroAnim.EStandTurnType
// NumValues: 0x0004
enum class EStandTurnType : uint8
{
	None                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	EStandTurnType_MAX                       = 3,
};

// Enum KuroAnim.EMoveDirection
// NumValues: 0x0006
enum class EMoveDirection : uint8
{
	Forward                                  = 0,
	Backward                                 = 1,
	Left                                     = 2,
	Right                                    = 3,
	Stop                                     = 4,
	EMoveDirection_MAX                       = 5,
};

// Enum KuroAnim.EExitClimbType
// NumValues: 0x000C
enum class EExitClimbType : uint8
{
	Leave                                    = 0,
	Water                                    = 1,
	Top                                      = 2,
	Bottom                                   = 3,
	Jump                                     = 4,
	Unknown                                  = 5,
	Sprint                                   = 6,
	Vault                                    = 7,
	SprintVaultFar                           = 8,
	SprintVaultNear                          = 9,
	BlockUp                                  = 10,
	EExitClimbType_MAX                       = 11,
};

// Enum KuroAnim.EEnterClimbType
// NumValues: 0x0006
enum class EEnterClimbType : uint8
{
	Air                                      = 0,
	Water                                    = 1,
	Ground                                   = 2,
	Down                                     = 3,
	Skill                                    = 4,
	EEnterClimbType_MAX                      = 5,
};

// Enum KuroAnim.EClimbStateType
// NumValues: 0x0005
enum class EClimbStateType : uint8
{
	None                                     = 0,
	EnterClimb                               = 1,
	Climbing                                 = 2,
	ExitClimb                                = 3,
	EClimbStateType_MAX                      = 4,
};

// Enum KuroAnim.ECharViewDirectionStateType
// NumValues: 0x0004
enum class ECharViewDirectionStateType : uint8
{
	LockDirection                            = 0,
	AimDirection                             = 1,
	FaceDirection                            = 2,
	ECharViewDirectionStateType_MAX          = 3,
};

// Enum KuroAnim.ECharMoveStateType
// NumValues: 0x001D
enum class ECharMoveStateType : uint8
{
	Other                                    = 0,
	Stand                                    = 1,
	Walk                                     = 2,
	WalkStop                                 = 3,
	Run                                      = 4,
	RunStop                                  = 5,
	Sprint                                   = 6,
	SprintStop                               = 7,
	Dodge                                    = 8,
	LandRoll                                 = 9,
	KnockDown                                = 10,
	Parry                                    = 11,
	SoftKnock                                = 12,
	HeavyKnock                               = 13,
	NormalClimb                              = 14,
	FastClimb                                = 15,
	Glide                                    = 16,
	KnockUp                                  = 17,
	FastSwim                                 = 18,
	NormalSwim                               = 19,
	Swing                                    = 20,
	Captured                                 = 21,
	Slide                                    = 22,
	Flying                                   = 23,
	EnterClimb                               = 24,
	ExitClimb                                = 25,
	NormalSki                                = 26,
	StandUp                                  = 27,
	ECharMoveStateType_MAX                   = 28,
};

// Enum KuroAnim.ECharPositionStateType
// NumValues: 0x0006
enum class ECharPositionStateType : uint8
{
	Ground                                   = 0,
	Climb                                    = 1,
	Air                                      = 2,
	Water                                    = 3,
	Ski                                      = 4,
	ECharPositionStateType_MAX               = 5,
};

// Enum KuroAnim.SightLockTurnMode
// NumValues: 0x0003
enum class ESightLockTurnMode : uint8
{
	ZFirst                                   = 0,
	XFirst                                   = 1,
	SightLockTurnMode_MAX                    = 2,
};

// Enum KuroAnim.SightLockMode
// NumValues: 0x0005
enum class ESightLockMode : uint8
{
	None                                     = 0,
	SightBoneFirst                           = 1,
	Ratio                                    = 2,
	Shooting                                 = 3,
	SightLockMode_MAX                        = 4,
};

// Enum KuroAnim.EndBoneIKMode
// NumValues: 0x0005
enum class EndBoneIKMode : uint8
{
	None                                     = 0,
	AxisModeLockX                            = 1,
	AxisModeLockY                            = 2,
	FullRotationMode                         = 3,
	EndBoneIKMode_MAX                        = 4,
};

// Enum KuroAnim.KuroAnimIKMode
// NumValues: 0x0004
enum class EKuroAnimIKMode : uint8
{
	DeltaPositionMode                        = 0,
	LocalPositionMode                        = 1,
	DeltaPositionFromCurveMode               = 2,
	KuroAnimIKMode_MAX                       = 3,
};

// Enum KuroAnim.KuroHumanIKMode
// NumValues: 0x0005
enum class EKuroHumanIKMode : uint8
{
	None                                     = 0,
	GroundMode                               = 1,
	ClimbMode                                = 2,
	SlideMode                                = 3,
	KuroHumanIKMode_MAX                      = 4,
};

// ScriptStruct KuroAnim.BranchBlendFilter
// 0x0018 (0x0018 - 0x0000)
struct FBranchBlendFilter final
{
public:
	struct FBoneReference                         BoneConfig;                                        // 0x0000(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         BlendDepth;                                        // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBranchBlendFilter) == 0x000004, "Wrong alignment on FBranchBlendFilter");
static_assert(sizeof(FBranchBlendFilter) == 0x000018, "Wrong size on FBranchBlendFilter");
static_assert(offsetof(FBranchBlendFilter, BoneConfig) == 0x000000, "Member 'FBranchBlendFilter::BoneConfig' has a wrong offset!");
static_assert(offsetof(FBranchBlendFilter, BlendDepth) == 0x000014, "Member 'FBranchBlendFilter::BlendDepth' has a wrong offset!");

// ScriptStruct KuroAnim.MaskLayer
// 0x0010 (0x0010 - 0x0000)
struct FMaskLayer final
{
public:
	TArray<struct FBranchBlendFilter>             MaskLayer;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaskLayer) == 0x000008, "Wrong alignment on FMaskLayer");
static_assert(sizeof(FMaskLayer) == 0x000010, "Wrong size on FMaskLayer");
static_assert(offsetof(FMaskLayer, MaskLayer) == 0x000000, "Member 'FMaskLayer::MaskLayer' has a wrong offset!");

// ScriptStruct KuroAnim.AdditiveBlendAlpha
// 0x000C (0x000C - 0x0000)
struct FAdditiveBlendAlpha final
{
public:
	float                                         MeshSpaceAlpha;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveAlpha;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverlayAlpha;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAdditiveBlendAlpha) == 0x000004, "Wrong alignment on FAdditiveBlendAlpha");
static_assert(sizeof(FAdditiveBlendAlpha) == 0x00000C, "Wrong size on FAdditiveBlendAlpha");
static_assert(offsetof(FAdditiveBlendAlpha, MeshSpaceAlpha) == 0x000000, "Member 'FAdditiveBlendAlpha::MeshSpaceAlpha' has a wrong offset!");
static_assert(offsetof(FAdditiveBlendAlpha, AdditiveAlpha) == 0x000004, "Member 'FAdditiveBlendAlpha::AdditiveAlpha' has a wrong offset!");
static_assert(offsetof(FAdditiveBlendAlpha, OverlayAlpha) == 0x000008, "Member 'FAdditiveBlendAlpha::OverlayAlpha' has a wrong offset!");

// ScriptStruct KuroAnim.AnimNode_AdditiveBoneBlend
// 0x01B0 (0x01C0 - 0x0010)
struct FAnimNode_AdditiveBoneBlend final : public FAnimNode_Base
{
public:
	struct FPoseLink                              BaseLayer;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPoseLink                              OverlayLayer;                                      // 0x0020(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPoseLink                              AdditiveBasePose;                                  // 0x0030(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FAdditiveBlendAlpha>            AdditiveBlendAlpha;                                // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bMeshSpaceAdd;                                     // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMaskLayer>                     LayerSetup;                                        // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChestBlendDepth;                                   // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebug;                                            // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBoneReference>                 SupperotBoneConfigs;                               // 0x0078(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, int32>                      SpecialCurves;                                     // 0x0088(0x0050)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0xE8];                                      // 0x00D8(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_AdditiveBoneBlend) == 0x000008, "Wrong alignment on FAnimNode_AdditiveBoneBlend");
static_assert(sizeof(FAnimNode_AdditiveBoneBlend) == 0x0001C0, "Wrong size on FAnimNode_AdditiveBoneBlend");
static_assert(offsetof(FAnimNode_AdditiveBoneBlend, BaseLayer) == 0x000010, "Member 'FAnimNode_AdditiveBoneBlend::BaseLayer' has a wrong offset!");
static_assert(offsetof(FAnimNode_AdditiveBoneBlend, OverlayLayer) == 0x000020, "Member 'FAnimNode_AdditiveBoneBlend::OverlayLayer' has a wrong offset!");
static_assert(offsetof(FAnimNode_AdditiveBoneBlend, AdditiveBasePose) == 0x000030, "Member 'FAnimNode_AdditiveBoneBlend::AdditiveBasePose' has a wrong offset!");
static_assert(offsetof(FAnimNode_AdditiveBoneBlend, AdditiveBlendAlpha) == 0x000040, "Member 'FAnimNode_AdditiveBoneBlend::AdditiveBlendAlpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_AdditiveBoneBlend, bMeshSpaceAdd) == 0x000050, "Member 'FAnimNode_AdditiveBoneBlend::bMeshSpaceAdd' has a wrong offset!");
static_assert(offsetof(FAnimNode_AdditiveBoneBlend, LayerSetup) == 0x000058, "Member 'FAnimNode_AdditiveBoneBlend::LayerSetup' has a wrong offset!");
static_assert(offsetof(FAnimNode_AdditiveBoneBlend, Alpha) == 0x000068, "Member 'FAnimNode_AdditiveBoneBlend::Alpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_AdditiveBoneBlend, ChestBlendDepth) == 0x00006C, "Member 'FAnimNode_AdditiveBoneBlend::ChestBlendDepth' has a wrong offset!");
static_assert(offsetof(FAnimNode_AdditiveBoneBlend, bDebug) == 0x000070, "Member 'FAnimNode_AdditiveBoneBlend::bDebug' has a wrong offset!");
static_assert(offsetof(FAnimNode_AdditiveBoneBlend, SupperotBoneConfigs) == 0x000078, "Member 'FAnimNode_AdditiveBoneBlend::SupperotBoneConfigs' has a wrong offset!");
static_assert(offsetof(FAnimNode_AdditiveBoneBlend, SpecialCurves) == 0x000088, "Member 'FAnimNode_AdditiveBoneBlend::SpecialCurves' has a wrong offset!");

// ScriptStruct KuroAnim.AnimNode_BoneRotateToLocation
// 0x0050 (0x0120 - 0x00D0)
struct FAnimNode_BoneRotateToLocation final : public FAnimNode_SkeletalControlBase
{
public:
	class FName                                   BoneName;                                          // 0x00D0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnAngle;                                         // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookUpAngle;                                       // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ForwardLocation;                                   // 0x00E4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              TurnLimit;                                         // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LookUpLimit;                                       // 0x00F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookUpOffset;                                      // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnUpOffset;                                      // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRollBackToOrigin;                                 // 0x0108(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopRoll;                                         // 0x0109(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebug;                                            // 0x010A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10B[0x15];                                     // 0x010B(0x0015)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_BoneRotateToLocation) == 0x000008, "Wrong alignment on FAnimNode_BoneRotateToLocation");
static_assert(sizeof(FAnimNode_BoneRotateToLocation) == 0x000120, "Wrong size on FAnimNode_BoneRotateToLocation");
static_assert(offsetof(FAnimNode_BoneRotateToLocation, BoneName) == 0x0000D0, "Member 'FAnimNode_BoneRotateToLocation::BoneName' has a wrong offset!");
static_assert(offsetof(FAnimNode_BoneRotateToLocation, TurnAngle) == 0x0000DC, "Member 'FAnimNode_BoneRotateToLocation::TurnAngle' has a wrong offset!");
static_assert(offsetof(FAnimNode_BoneRotateToLocation, LookUpAngle) == 0x0000E0, "Member 'FAnimNode_BoneRotateToLocation::LookUpAngle' has a wrong offset!");
static_assert(offsetof(FAnimNode_BoneRotateToLocation, ForwardLocation) == 0x0000E4, "Member 'FAnimNode_BoneRotateToLocation::ForwardLocation' has a wrong offset!");
static_assert(offsetof(FAnimNode_BoneRotateToLocation, TurnLimit) == 0x0000F0, "Member 'FAnimNode_BoneRotateToLocation::TurnLimit' has a wrong offset!");
static_assert(offsetof(FAnimNode_BoneRotateToLocation, LookUpLimit) == 0x0000F8, "Member 'FAnimNode_BoneRotateToLocation::LookUpLimit' has a wrong offset!");
static_assert(offsetof(FAnimNode_BoneRotateToLocation, LookUpOffset) == 0x000100, "Member 'FAnimNode_BoneRotateToLocation::LookUpOffset' has a wrong offset!");
static_assert(offsetof(FAnimNode_BoneRotateToLocation, TurnUpOffset) == 0x000104, "Member 'FAnimNode_BoneRotateToLocation::TurnUpOffset' has a wrong offset!");
static_assert(offsetof(FAnimNode_BoneRotateToLocation, bRollBackToOrigin) == 0x000108, "Member 'FAnimNode_BoneRotateToLocation::bRollBackToOrigin' has a wrong offset!");
static_assert(offsetof(FAnimNode_BoneRotateToLocation, bStopRoll) == 0x000109, "Member 'FAnimNode_BoneRotateToLocation::bStopRoll' has a wrong offset!");
static_assert(offsetof(FAnimNode_BoneRotateToLocation, bDebug) == 0x00010A, "Member 'FAnimNode_BoneRotateToLocation::bDebug' has a wrong offset!");

// ScriptStruct KuroAnim.AnimNode_CombineCurves
// 0x0050 (0x0060 - 0x0010)
struct FAnimNode_CombineCurves final : public FAnimNode_Base
{
public:
	struct FPoseLink                              Base;                                              // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FPoseLink                              CurveAnim;                                         // 0x0020(0x0010)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	ECombineCurveMode                             CombineMode;                                       // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Alpha;                                             // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CleanAlphaCurveName;                               // 0x0038(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           CleanCurves;                                       // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_CombineCurves) == 0x000008, "Wrong alignment on FAnimNode_CombineCurves");
static_assert(sizeof(FAnimNode_CombineCurves) == 0x000060, "Wrong size on FAnimNode_CombineCurves");
static_assert(offsetof(FAnimNode_CombineCurves, Base) == 0x000010, "Member 'FAnimNode_CombineCurves::Base' has a wrong offset!");
static_assert(offsetof(FAnimNode_CombineCurves, CurveAnim) == 0x000020, "Member 'FAnimNode_CombineCurves::CurveAnim' has a wrong offset!");
static_assert(offsetof(FAnimNode_CombineCurves, CombineMode) == 0x000030, "Member 'FAnimNode_CombineCurves::CombineMode' has a wrong offset!");
static_assert(offsetof(FAnimNode_CombineCurves, Alpha) == 0x000034, "Member 'FAnimNode_CombineCurves::Alpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_CombineCurves, CleanAlphaCurveName) == 0x000038, "Member 'FAnimNode_CombineCurves::CleanAlphaCurveName' has a wrong offset!");
static_assert(offsetof(FAnimNode_CombineCurves, CleanCurves) == 0x000048, "Member 'FAnimNode_CombineCurves::CleanCurves' has a wrong offset!");

// ScriptStruct KuroAnim.AnimNode_ExtraFollowAnims
// 0x0A40 (0x0A50 - 0x0010)
struct alignas(0x10) FAnimNode_ExtraFollowAnims final : public FAnimNode_Base
{
public:
	uint8                                         Pad_10[0xA40];                                     // 0x0010(0x0A40)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_ExtraFollowAnims) == 0x000010, "Wrong alignment on FAnimNode_ExtraFollowAnims");
static_assert(sizeof(FAnimNode_ExtraFollowAnims) == 0x000A50, "Wrong size on FAnimNode_ExtraFollowAnims");

// ScriptStruct KuroAnim.BoneBlock
// 0x0060 (0x0060 - 0x0000)
struct FBoneBlock final
{
public:
	TArray<class FName>                           Groups;                                            // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<int32, float>                            Link;                                              // 0x0010(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoneBlock) == 0x000008, "Wrong alignment on FBoneBlock");
static_assert(sizeof(FBoneBlock) == 0x000060, "Wrong size on FBoneBlock");
static_assert(offsetof(FBoneBlock, Groups) == 0x000000, "Member 'FBoneBlock::Groups' has a wrong offset!");
static_assert(offsetof(FBoneBlock, Link) == 0x000010, "Member 'FBoneBlock::Link' has a wrong offset!");

// ScriptStruct KuroAnim.SpecialBoneShakeData
// 0x0018 (0x0018 - 0x0000)
struct FSpecialBoneShakeData final
{
public:
	TArray<class FName>                           Groups;                                            // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Influence;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShakeTime;                                         // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialBoneShakeData) == 0x000008, "Wrong alignment on FSpecialBoneShakeData");
static_assert(sizeof(FSpecialBoneShakeData) == 0x000018, "Wrong size on FSpecialBoneShakeData");
static_assert(offsetof(FSpecialBoneShakeData, Groups) == 0x000000, "Member 'FSpecialBoneShakeData::Groups' has a wrong offset!");
static_assert(offsetof(FSpecialBoneShakeData, Influence) == 0x000010, "Member 'FSpecialBoneShakeData::Influence' has a wrong offset!");
static_assert(offsetof(FSpecialBoneShakeData, ShakeTime) == 0x000014, "Member 'FSpecialBoneShakeData::ShakeTime' has a wrong offset!");

// ScriptStruct KuroAnim.SkeletonGroup
// 0x0020 (0x0020 - 0x0000)
struct FSkeletonGroup final
{
public:
	TArray<struct FBoneBlock>                     Blocks;                                            // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSpecialBoneShakeData>          SpeicalBoneShakeData;                              // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkeletonGroup) == 0x000008, "Wrong alignment on FSkeletonGroup");
static_assert(sizeof(FSkeletonGroup) == 0x000020, "Wrong size on FSkeletonGroup");
static_assert(offsetof(FSkeletonGroup, Blocks) == 0x000000, "Member 'FSkeletonGroup::Blocks' has a wrong offset!");
static_assert(offsetof(FSkeletonGroup, SpeicalBoneShakeData) == 0x000010, "Member 'FSkeletonGroup::SpeicalBoneShakeData' has a wrong offset!");

// ScriptStruct KuroAnim.HitBones
// 0x0010 (0x0010 - 0x0000)
struct FHitBones final
{
public:
	TArray<class FName>                           Bones;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitBones) == 0x000008, "Wrong alignment on FHitBones");
static_assert(sizeof(FHitBones) == 0x000010, "Wrong size on FHitBones");
static_assert(offsetof(FHitBones, Bones) == 0x000000, "Member 'FHitBones::Bones' has a wrong offset!");

// ScriptStruct KuroAnim.AnimNode_Feedback
// 0x0190 (0x0260 - 0x00D0)
struct FAnimNode_Feedback final : public FAnimNode_SkeletalControlBase
{
public:
	struct FSkeletonGroup                         SkeletonBlockInfo;                                 // 0x00D0(0x0020)(Edit, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnitTime;                                          // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Hit;                                               // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NotEffectToChild;                                  // 0x00F9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FA[0x2];                                       // 0x00FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShakeRate;                                         // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitBones                              HitBoneNames;                                      // 0x0100(0x0010)(Edit, NativeAccessSpecifierPublic)
	class UCurveFloat*                            Curve;                                             // 0x0110(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebug;                                            // 0x0118(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119[0x147];                                    // 0x0119(0x0147)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_Feedback) == 0x000008, "Wrong alignment on FAnimNode_Feedback");
static_assert(sizeof(FAnimNode_Feedback) == 0x000260, "Wrong size on FAnimNode_Feedback");
static_assert(offsetof(FAnimNode_Feedback, SkeletonBlockInfo) == 0x0000D0, "Member 'FAnimNode_Feedback::SkeletonBlockInfo' has a wrong offset!");
static_assert(offsetof(FAnimNode_Feedback, DeltaTime) == 0x0000F0, "Member 'FAnimNode_Feedback::DeltaTime' has a wrong offset!");
static_assert(offsetof(FAnimNode_Feedback, UnitTime) == 0x0000F4, "Member 'FAnimNode_Feedback::UnitTime' has a wrong offset!");
static_assert(offsetof(FAnimNode_Feedback, Hit) == 0x0000F8, "Member 'FAnimNode_Feedback::Hit' has a wrong offset!");
static_assert(offsetof(FAnimNode_Feedback, NotEffectToChild) == 0x0000F9, "Member 'FAnimNode_Feedback::NotEffectToChild' has a wrong offset!");
static_assert(offsetof(FAnimNode_Feedback, ShakeRate) == 0x0000FC, "Member 'FAnimNode_Feedback::ShakeRate' has a wrong offset!");
static_assert(offsetof(FAnimNode_Feedback, HitBoneNames) == 0x000100, "Member 'FAnimNode_Feedback::HitBoneNames' has a wrong offset!");
static_assert(offsetof(FAnimNode_Feedback, Curve) == 0x000110, "Member 'FAnimNode_Feedback::Curve' has a wrong offset!");
static_assert(offsetof(FAnimNode_Feedback, bDebug) == 0x000118, "Member 'FAnimNode_Feedback::bDebug' has a wrong offset!");

// ScriptStruct KuroAnim.AnimNode_FeedbackRotate
// 0x0238 (0x0308 - 0x00D0)
struct FAnimNode_FeedbackRotate final : public FAnimNode_SkeletalControlBase
{
public:
	TArray<struct FBoneReference>                 BeginBones;                                        // 0x00D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FBoneReference>                 EndBones;                                          // 0x00E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FBoneReference>                 WeakenBones;                                       // 0x00F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         RootBone;                                          // 0x0100(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MaxTurnAngle;                                      // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weaken;                                            // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoveryWeaken;                                    // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistance;                                       // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimChangeOptizimeParameter;                       // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NewHit;                                            // 0x012C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12D[0x3];                                      // 0x012D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HitPos;                                            // 0x0130(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitVector;                                         // 0x013C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FeedbackTimeLength;                                // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            Curve;                                             // 0x0150(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_158[0x1B0];                                    // 0x0158(0x01B0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_FeedbackRotate) == 0x000008, "Wrong alignment on FAnimNode_FeedbackRotate");
static_assert(sizeof(FAnimNode_FeedbackRotate) == 0x000308, "Wrong size on FAnimNode_FeedbackRotate");
static_assert(offsetof(FAnimNode_FeedbackRotate, BeginBones) == 0x0000D0, "Member 'FAnimNode_FeedbackRotate::BeginBones' has a wrong offset!");
static_assert(offsetof(FAnimNode_FeedbackRotate, EndBones) == 0x0000E0, "Member 'FAnimNode_FeedbackRotate::EndBones' has a wrong offset!");
static_assert(offsetof(FAnimNode_FeedbackRotate, WeakenBones) == 0x0000F0, "Member 'FAnimNode_FeedbackRotate::WeakenBones' has a wrong offset!");
static_assert(offsetof(FAnimNode_FeedbackRotate, RootBone) == 0x000100, "Member 'FAnimNode_FeedbackRotate::RootBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_FeedbackRotate, MaxTurnAngle) == 0x000114, "Member 'FAnimNode_FeedbackRotate::MaxTurnAngle' has a wrong offset!");
static_assert(offsetof(FAnimNode_FeedbackRotate, Weaken) == 0x000118, "Member 'FAnimNode_FeedbackRotate::Weaken' has a wrong offset!");
static_assert(offsetof(FAnimNode_FeedbackRotate, RecoveryWeaken) == 0x00011C, "Member 'FAnimNode_FeedbackRotate::RecoveryWeaken' has a wrong offset!");
static_assert(offsetof(FAnimNode_FeedbackRotate, MinDistance) == 0x000120, "Member 'FAnimNode_FeedbackRotate::MinDistance' has a wrong offset!");
static_assert(offsetof(FAnimNode_FeedbackRotate, MaxDistance) == 0x000124, "Member 'FAnimNode_FeedbackRotate::MaxDistance' has a wrong offset!");
static_assert(offsetof(FAnimNode_FeedbackRotate, AnimChangeOptizimeParameter) == 0x000128, "Member 'FAnimNode_FeedbackRotate::AnimChangeOptizimeParameter' has a wrong offset!");
static_assert(offsetof(FAnimNode_FeedbackRotate, NewHit) == 0x00012C, "Member 'FAnimNode_FeedbackRotate::NewHit' has a wrong offset!");
static_assert(offsetof(FAnimNode_FeedbackRotate, HitPos) == 0x000130, "Member 'FAnimNode_FeedbackRotate::HitPos' has a wrong offset!");
static_assert(offsetof(FAnimNode_FeedbackRotate, HitVector) == 0x00013C, "Member 'FAnimNode_FeedbackRotate::HitVector' has a wrong offset!");
static_assert(offsetof(FAnimNode_FeedbackRotate, FeedbackTimeLength) == 0x000148, "Member 'FAnimNode_FeedbackRotate::FeedbackTimeLength' has a wrong offset!");
static_assert(offsetof(FAnimNode_FeedbackRotate, Curve) == 0x000150, "Member 'FAnimNode_FeedbackRotate::Curve' has a wrong offset!");

// ScriptStruct KuroAnim.AnimNode_FollowAnims
// 0x0118 (0x0128 - 0x0010)
struct FAnimNode_FollowAnims final : public FAnimNode_Base
{
public:
	struct FPoseLink                              Base;                                              // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TMap<class FString, class UAnimSequenceBase*> AnimMap;                                           // 0x0020(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TSet<class FName>                             Slots;                                             // 0x0070(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x68];                                      // 0x00C0(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_FollowAnims) == 0x000008, "Wrong alignment on FAnimNode_FollowAnims");
static_assert(sizeof(FAnimNode_FollowAnims) == 0x000128, "Wrong size on FAnimNode_FollowAnims");
static_assert(offsetof(FAnimNode_FollowAnims, Base) == 0x000010, "Member 'FAnimNode_FollowAnims::Base' has a wrong offset!");
static_assert(offsetof(FAnimNode_FollowAnims, AnimMap) == 0x000020, "Member 'FAnimNode_FollowAnims::AnimMap' has a wrong offset!");
static_assert(offsetof(FAnimNode_FollowAnims, Slots) == 0x000070, "Member 'FAnimNode_FollowAnims::Slots' has a wrong offset!");

// ScriptStruct KuroAnim.AnimNode_HumanTwoBoneIK
// 0x00F0 (0x01C0 - 0x00D0)
struct FAnimNode_HumanTwoBoneIK final : public FAnimNode_SkeletalControlBase
{
public:
	struct FBoneReference                         IKBone;                                            // 0x00D0(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	EKuroAnimIKMode                               bMode;                                             // 0x00E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BaseAngleCurveName;                                // 0x00E8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LocationCurveName;                                 // 0x00F8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                IKLocalPos;                                        // 0x0108(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowerLimit[0x2];                                   // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OffsetOrTargetPosition;                            // 0x011C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EndBoneIKMode                                 bEndBoneMode;                                      // 0x0128(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x3];                                      // 0x0129(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                EndBoneBaseAxis;                                   // 0x012C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndBoneTargetAxis;                                 // 0x0138(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0xC];                                      // 0x0144(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  EndBoneTargetRotation;                             // 0x0150(0x0010)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         EndBoneLimit[0x6];                                 // 0x0160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_178[0x48];                                     // 0x0178(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_HumanTwoBoneIK) == 0x000010, "Wrong alignment on FAnimNode_HumanTwoBoneIK");
static_assert(sizeof(FAnimNode_HumanTwoBoneIK) == 0x0001C0, "Wrong size on FAnimNode_HumanTwoBoneIK");
static_assert(offsetof(FAnimNode_HumanTwoBoneIK, IKBone) == 0x0000D0, "Member 'FAnimNode_HumanTwoBoneIK::IKBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_HumanTwoBoneIK, bMode) == 0x0000E4, "Member 'FAnimNode_HumanTwoBoneIK::bMode' has a wrong offset!");
static_assert(offsetof(FAnimNode_HumanTwoBoneIK, BaseAngleCurveName) == 0x0000E8, "Member 'FAnimNode_HumanTwoBoneIK::BaseAngleCurveName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HumanTwoBoneIK, LocationCurveName) == 0x0000F8, "Member 'FAnimNode_HumanTwoBoneIK::LocationCurveName' has a wrong offset!");
static_assert(offsetof(FAnimNode_HumanTwoBoneIK, IKLocalPos) == 0x000108, "Member 'FAnimNode_HumanTwoBoneIK::IKLocalPos' has a wrong offset!");
static_assert(offsetof(FAnimNode_HumanTwoBoneIK, LowerLimit) == 0x000114, "Member 'FAnimNode_HumanTwoBoneIK::LowerLimit' has a wrong offset!");
static_assert(offsetof(FAnimNode_HumanTwoBoneIK, OffsetOrTargetPosition) == 0x00011C, "Member 'FAnimNode_HumanTwoBoneIK::OffsetOrTargetPosition' has a wrong offset!");
static_assert(offsetof(FAnimNode_HumanTwoBoneIK, bEndBoneMode) == 0x000128, "Member 'FAnimNode_HumanTwoBoneIK::bEndBoneMode' has a wrong offset!");
static_assert(offsetof(FAnimNode_HumanTwoBoneIK, EndBoneBaseAxis) == 0x00012C, "Member 'FAnimNode_HumanTwoBoneIK::EndBoneBaseAxis' has a wrong offset!");
static_assert(offsetof(FAnimNode_HumanTwoBoneIK, EndBoneTargetAxis) == 0x000138, "Member 'FAnimNode_HumanTwoBoneIK::EndBoneTargetAxis' has a wrong offset!");
static_assert(offsetof(FAnimNode_HumanTwoBoneIK, EndBoneTargetRotation) == 0x000150, "Member 'FAnimNode_HumanTwoBoneIK::EndBoneTargetRotation' has a wrong offset!");
static_assert(offsetof(FAnimNode_HumanTwoBoneIK, EndBoneLimit) == 0x000160, "Member 'FAnimNode_HumanTwoBoneIK::EndBoneLimit' has a wrong offset!");

// ScriptStruct KuroAnim.KuroHumanIKPart
// 0x0070 (0x0070 - 0x0000)
struct FKuroHumanIKPart final
{
public:
	struct FBoneReference                         IKBone;                                            // 0x0000(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseCurve;                                         // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BaseAngleCurveName;                                // 0x0018(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LocationCurveName;                                 // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AlphaCurveName;                                    // 0x0038(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxIkDist;                                         // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowerLimits[0x2];                                  // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndBoneLimits[0x6];                                // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EndBoneIKMode                                 EndBoneIKMode;                                     // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DebugPrint;                                        // 0x0069(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x6];                                       // 0x006A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKuroHumanIKPart) == 0x000008, "Wrong alignment on FKuroHumanIKPart");
static_assert(sizeof(FKuroHumanIKPart) == 0x000070, "Wrong size on FKuroHumanIKPart");
static_assert(offsetof(FKuroHumanIKPart, IKBone) == 0x000000, "Member 'FKuroHumanIKPart::IKBone' has a wrong offset!");
static_assert(offsetof(FKuroHumanIKPart, bUseCurve) == 0x000014, "Member 'FKuroHumanIKPart::bUseCurve' has a wrong offset!");
static_assert(offsetof(FKuroHumanIKPart, BaseAngleCurveName) == 0x000018, "Member 'FKuroHumanIKPart::BaseAngleCurveName' has a wrong offset!");
static_assert(offsetof(FKuroHumanIKPart, LocationCurveName) == 0x000028, "Member 'FKuroHumanIKPart::LocationCurveName' has a wrong offset!");
static_assert(offsetof(FKuroHumanIKPart, AlphaCurveName) == 0x000038, "Member 'FKuroHumanIKPart::AlphaCurveName' has a wrong offset!");
static_assert(offsetof(FKuroHumanIKPart, MaxIkDist) == 0x000044, "Member 'FKuroHumanIKPart::MaxIkDist' has a wrong offset!");
static_assert(offsetof(FKuroHumanIKPart, LowerLimits) == 0x000048, "Member 'FKuroHumanIKPart::LowerLimits' has a wrong offset!");
static_assert(offsetof(FKuroHumanIKPart, EndBoneLimits) == 0x000050, "Member 'FKuroHumanIKPart::EndBoneLimits' has a wrong offset!");
static_assert(offsetof(FKuroHumanIKPart, EndBoneIKMode) == 0x000068, "Member 'FKuroHumanIKPart::EndBoneIKMode' has a wrong offset!");
static_assert(offsetof(FKuroHumanIKPart, DebugPrint) == 0x000069, "Member 'FKuroHumanIKPart::DebugPrint' has a wrong offset!");

// ScriptStruct KuroAnim.AnimNode_KuroHumanIK
// 0x0130 (0x0200 - 0x00D0)
struct alignas(0x10) FAnimNode_KuroHumanIK final : public FAnimNode_SkeletalControlBase
{
public:
	TArray<struct FKuroHumanIKPart>               FootParts;                                         // 0x00D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKuroHumanIKPart>               HandParts;                                         // 0x00E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EKuroHumanIKMode                              Mode;                                              // 0x00F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CapsuleRadius;                                     // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMoving;                                         // 0x00F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsComplexIk;                                      // 0x00F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FA[0x2];                                       // 0x00FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeltaSeconds;                                      // 0x00FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForbiddenCurvePosition;                           // 0x0100(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoLerp;                                           // 0x0101(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_102[0x2];                                      // 0x0102(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GroundDepth;                                       // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxIKFootDetectDepth;                              // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingSpeed;                                       // 0x010C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkRunMix;                                        // 0x0110(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegMovementSlop;                                   // 0x0114(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbRadius;                                       // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SlideForward;                                      // 0x011C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlideRadius;                                       // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStandSlide;                                       // 0x012C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawDebug;                                        // 0x012D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12E[0xD2];                                     // 0x012E(0x00D2)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_KuroHumanIK) == 0x000010, "Wrong alignment on FAnimNode_KuroHumanIK");
static_assert(sizeof(FAnimNode_KuroHumanIK) == 0x000200, "Wrong size on FAnimNode_KuroHumanIK");
static_assert(offsetof(FAnimNode_KuroHumanIK, FootParts) == 0x0000D0, "Member 'FAnimNode_KuroHumanIK::FootParts' has a wrong offset!");
static_assert(offsetof(FAnimNode_KuroHumanIK, HandParts) == 0x0000E0, "Member 'FAnimNode_KuroHumanIK::HandParts' has a wrong offset!");
static_assert(offsetof(FAnimNode_KuroHumanIK, Mode) == 0x0000F0, "Member 'FAnimNode_KuroHumanIK::Mode' has a wrong offset!");
static_assert(offsetof(FAnimNode_KuroHumanIK, CapsuleRadius) == 0x0000F4, "Member 'FAnimNode_KuroHumanIK::CapsuleRadius' has a wrong offset!");
static_assert(offsetof(FAnimNode_KuroHumanIK, bIsMoving) == 0x0000F8, "Member 'FAnimNode_KuroHumanIK::bIsMoving' has a wrong offset!");
static_assert(offsetof(FAnimNode_KuroHumanIK, bIsComplexIk) == 0x0000F9, "Member 'FAnimNode_KuroHumanIK::bIsComplexIk' has a wrong offset!");
static_assert(offsetof(FAnimNode_KuroHumanIK, DeltaSeconds) == 0x0000FC, "Member 'FAnimNode_KuroHumanIK::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(FAnimNode_KuroHumanIK, bForbiddenCurvePosition) == 0x000100, "Member 'FAnimNode_KuroHumanIK::bForbiddenCurvePosition' has a wrong offset!");
static_assert(offsetof(FAnimNode_KuroHumanIK, bNoLerp) == 0x000101, "Member 'FAnimNode_KuroHumanIK::bNoLerp' has a wrong offset!");
static_assert(offsetof(FAnimNode_KuroHumanIK, GroundDepth) == 0x000104, "Member 'FAnimNode_KuroHumanIK::GroundDepth' has a wrong offset!");
static_assert(offsetof(FAnimNode_KuroHumanIK, MaxIKFootDetectDepth) == 0x000108, "Member 'FAnimNode_KuroHumanIK::MaxIKFootDetectDepth' has a wrong offset!");
static_assert(offsetof(FAnimNode_KuroHumanIK, MovingSpeed) == 0x00010C, "Member 'FAnimNode_KuroHumanIK::MovingSpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_KuroHumanIK, WalkRunMix) == 0x000110, "Member 'FAnimNode_KuroHumanIK::WalkRunMix' has a wrong offset!");
static_assert(offsetof(FAnimNode_KuroHumanIK, DegMovementSlop) == 0x000114, "Member 'FAnimNode_KuroHumanIK::DegMovementSlop' has a wrong offset!");
static_assert(offsetof(FAnimNode_KuroHumanIK, ClimbRadius) == 0x000118, "Member 'FAnimNode_KuroHumanIK::ClimbRadius' has a wrong offset!");
static_assert(offsetof(FAnimNode_KuroHumanIK, SlideForward) == 0x00011C, "Member 'FAnimNode_KuroHumanIK::SlideForward' has a wrong offset!");
static_assert(offsetof(FAnimNode_KuroHumanIK, SlideRadius) == 0x000128, "Member 'FAnimNode_KuroHumanIK::SlideRadius' has a wrong offset!");
static_assert(offsetof(FAnimNode_KuroHumanIK, bStandSlide) == 0x00012C, "Member 'FAnimNode_KuroHumanIK::bStandSlide' has a wrong offset!");
static_assert(offsetof(FAnimNode_KuroHumanIK, bDrawDebug) == 0x00012D, "Member 'FAnimNode_KuroHumanIK::bDrawDebug' has a wrong offset!");

// ScriptStruct KuroAnim.AnimNode_MountBuffer
// 0x0100 (0x01D0 - 0x00D0)
struct alignas(0x10) FAnimNode_MountBuffer final : public FAnimNode_SkeletalControlBase
{
public:
	struct FBoneReference                         MountBone;                                         // 0x00D0(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         PowerIntensity;                                    // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirResistance;                                     // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MetaDeltaTime;                                     // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InertanceIntensity;                                // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0xDC];                                      // 0x00F4(0x00DC)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_MountBuffer) == 0x000010, "Wrong alignment on FAnimNode_MountBuffer");
static_assert(sizeof(FAnimNode_MountBuffer) == 0x0001D0, "Wrong size on FAnimNode_MountBuffer");
static_assert(offsetof(FAnimNode_MountBuffer, MountBone) == 0x0000D0, "Member 'FAnimNode_MountBuffer::MountBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_MountBuffer, PowerIntensity) == 0x0000E4, "Member 'FAnimNode_MountBuffer::PowerIntensity' has a wrong offset!");
static_assert(offsetof(FAnimNode_MountBuffer, AirResistance) == 0x0000E8, "Member 'FAnimNode_MountBuffer::AirResistance' has a wrong offset!");
static_assert(offsetof(FAnimNode_MountBuffer, MetaDeltaTime) == 0x0000EC, "Member 'FAnimNode_MountBuffer::MetaDeltaTime' has a wrong offset!");
static_assert(offsetof(FAnimNode_MountBuffer, InertanceIntensity) == 0x0000F0, "Member 'FAnimNode_MountBuffer::InertanceIntensity' has a wrong offset!");

// ScriptStruct KuroAnim.AnimNode_MultiBonesIK
// 0x0078 (0x0148 - 0x00D0)
struct FAnimNode_MultiBonesIK final : public FAnimNode_SkeletalControlBase
{
public:
	struct FBoneReference                         IKBone;                                            // 0x00D0(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                IKBonePos;                                         // 0x00E4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoneReference                         BeginBone;                                         // 0x00F0(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         EndBone;                                           // 0x0104(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	EKuroAnimIKMode                               bMode;                                             // 0x0118(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119[0x3];                                      // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OffsetOrTargetPosition;                            // 0x011C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0x20];                                     // 0x0128(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_MultiBonesIK) == 0x000008, "Wrong alignment on FAnimNode_MultiBonesIK");
static_assert(sizeof(FAnimNode_MultiBonesIK) == 0x000148, "Wrong size on FAnimNode_MultiBonesIK");
static_assert(offsetof(FAnimNode_MultiBonesIK, IKBone) == 0x0000D0, "Member 'FAnimNode_MultiBonesIK::IKBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_MultiBonesIK, IKBonePos) == 0x0000E4, "Member 'FAnimNode_MultiBonesIK::IKBonePos' has a wrong offset!");
static_assert(offsetof(FAnimNode_MultiBonesIK, BeginBone) == 0x0000F0, "Member 'FAnimNode_MultiBonesIK::BeginBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_MultiBonesIK, EndBone) == 0x000104, "Member 'FAnimNode_MultiBonesIK::EndBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_MultiBonesIK, bMode) == 0x000118, "Member 'FAnimNode_MultiBonesIK::bMode' has a wrong offset!");
static_assert(offsetof(FAnimNode_MultiBonesIK, OffsetOrTargetPosition) == 0x00011C, "Member 'FAnimNode_MultiBonesIK::OffsetOrTargetPosition' has a wrong offset!");

// ScriptStruct KuroAnim.PhyClothLine
// 0x001C (0x001C - 0x0000)
struct FPhyClothLine final
{
public:
	struct FBoneReference                         RootBone;                                          // 0x0000(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Generate;                                          // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPhyClothLine) == 0x000004, "Wrong alignment on FPhyClothLine");
static_assert(sizeof(FPhyClothLine) == 0x00001C, "Wrong size on FPhyClothLine");
static_assert(offsetof(FPhyClothLine, RootBone) == 0x000000, "Member 'FPhyClothLine::RootBone' has a wrong offset!");
static_assert(offsetof(FPhyClothLine, Thickness) == 0x000014, "Member 'FPhyClothLine::Thickness' has a wrong offset!");
static_assert(offsetof(FPhyClothLine, Generate) == 0x000018, "Member 'FPhyClothLine::Generate' has a wrong offset!");

// ScriptStruct KuroAnim.PhyClothConfig
// 0x002C (0x002C - 0x0000)
struct FPhyClothConfig final
{
public:
	float                                         SpringStiffness;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleSpringStiffness;                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damping;                                           // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Gravity;                                           // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mass;                                              // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LimitScale;                                        // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LimitDegree;                                       // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrengthRateForSideLink;                           // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrengthRateForInverseLink;                        // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPhyClothConfig) == 0x000004, "Wrong alignment on FPhyClothConfig");
static_assert(sizeof(FPhyClothConfig) == 0x00002C, "Wrong size on FPhyClothConfig");
static_assert(offsetof(FPhyClothConfig, SpringStiffness) == 0x000000, "Member 'FPhyClothConfig::SpringStiffness' has a wrong offset!");
static_assert(offsetof(FPhyClothConfig, AngleSpringStiffness) == 0x000004, "Member 'FPhyClothConfig::AngleSpringStiffness' has a wrong offset!");
static_assert(offsetof(FPhyClothConfig, Damping) == 0x000008, "Member 'FPhyClothConfig::Damping' has a wrong offset!");
static_assert(offsetof(FPhyClothConfig, Gravity) == 0x00000C, "Member 'FPhyClothConfig::Gravity' has a wrong offset!");
static_assert(offsetof(FPhyClothConfig, Mass) == 0x000018, "Member 'FPhyClothConfig::Mass' has a wrong offset!");
static_assert(offsetof(FPhyClothConfig, LimitScale) == 0x00001C, "Member 'FPhyClothConfig::LimitScale' has a wrong offset!");
static_assert(offsetof(FPhyClothConfig, LimitDegree) == 0x000020, "Member 'FPhyClothConfig::LimitDegree' has a wrong offset!");
static_assert(offsetof(FPhyClothConfig, StrengthRateForSideLink) == 0x000024, "Member 'FPhyClothConfig::StrengthRateForSideLink' has a wrong offset!");
static_assert(offsetof(FPhyClothConfig, StrengthRateForInverseLink) == 0x000028, "Member 'FPhyClothConfig::StrengthRateForInverseLink' has a wrong offset!");

// ScriptStruct KuroAnim.PhyClothCollision
// 0x0038 (0x0038 - 0x0000)
struct FPhyClothCollision final
{
public:
	ECollisionType                                Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoneReference                         BindBone;                                          // 0x0004(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                CenterPos;                                         // 0x0018(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0024(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              Size;                                              // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPhyClothCollision) == 0x000004, "Wrong alignment on FPhyClothCollision");
static_assert(sizeof(FPhyClothCollision) == 0x000038, "Wrong size on FPhyClothCollision");
static_assert(offsetof(FPhyClothCollision, Type) == 0x000000, "Member 'FPhyClothCollision::Type' has a wrong offset!");
static_assert(offsetof(FPhyClothCollision, BindBone) == 0x000004, "Member 'FPhyClothCollision::BindBone' has a wrong offset!");
static_assert(offsetof(FPhyClothCollision, CenterPos) == 0x000018, "Member 'FPhyClothCollision::CenterPos' has a wrong offset!");
static_assert(offsetof(FPhyClothCollision, Rotation) == 0x000024, "Member 'FPhyClothCollision::Rotation' has a wrong offset!");
static_assert(offsetof(FPhyClothCollision, Size) == 0x000030, "Member 'FPhyClothCollision::Size' has a wrong offset!");

// ScriptStruct KuroAnim.PhyClothGroup
// 0x0090 (0x0090 - 0x0000)
struct FPhyClothGroup final
{
public:
	TArray<struct FPhyClothLine>                  RootBones;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EClothType                                    Type;                                              // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBoneReference>                 ExceptBones;                                       // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FBoneReference>                 HelperLinkBones;                                   // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FPhyClothConfig                        Config;                                            // 0x0038(0x002C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPhyClothCollision>             Collisions;                                        // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                CenterLineStart;                                   // 0x0078(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CenterLineDirect;                                  // 0x0084(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPhyClothGroup) == 0x000008, "Wrong alignment on FPhyClothGroup");
static_assert(sizeof(FPhyClothGroup) == 0x000090, "Wrong size on FPhyClothGroup");
static_assert(offsetof(FPhyClothGroup, RootBones) == 0x000000, "Member 'FPhyClothGroup::RootBones' has a wrong offset!");
static_assert(offsetof(FPhyClothGroup, Type) == 0x000010, "Member 'FPhyClothGroup::Type' has a wrong offset!");
static_assert(offsetof(FPhyClothGroup, ExceptBones) == 0x000018, "Member 'FPhyClothGroup::ExceptBones' has a wrong offset!");
static_assert(offsetof(FPhyClothGroup, HelperLinkBones) == 0x000028, "Member 'FPhyClothGroup::HelperLinkBones' has a wrong offset!");
static_assert(offsetof(FPhyClothGroup, Config) == 0x000038, "Member 'FPhyClothGroup::Config' has a wrong offset!");
static_assert(offsetof(FPhyClothGroup, Collisions) == 0x000068, "Member 'FPhyClothGroup::Collisions' has a wrong offset!");
static_assert(offsetof(FPhyClothGroup, CenterLineStart) == 0x000078, "Member 'FPhyClothGroup::CenterLineStart' has a wrong offset!");
static_assert(offsetof(FPhyClothGroup, CenterLineDirect) == 0x000084, "Member 'FPhyClothGroup::CenterLineDirect' has a wrong offset!");

// ScriptStruct KuroAnim.AnimNode_PhyCloth
// 0x0370 (0x0440 - 0x00D0)
struct alignas(0x10) FAnimNode_PhyCloth final : public FAnimNode_SkeletalControlBase
{
public:
	TArray<struct FPhyClothGroup>                 ClothGroups;                                       // 0x00D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          OpenCollateralRotation;                            // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MultiThread;                                       // 0x00E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Transport;                                         // 0x00E2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E3[0x1];                                       // 0x00E3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TransportThreadHold;                               // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinIterTimes;                                      // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxIterTimes;                                      // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDeltaTime;                                      // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WindSpeed;                                         // 0x00F4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirDrag;                                           // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisturbPeriodic;                                   // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisturbStrMul;                                     // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DisturbStr;                                        // 0x0110(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DisturbSplit;                                      // 0x0118(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_120[0x10];                                     // 0x0120(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OriginAlphaCurveName;                              // 0x0130(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C[0x304];                                    // 0x013C(0x0304)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_PhyCloth) == 0x000010, "Wrong alignment on FAnimNode_PhyCloth");
static_assert(sizeof(FAnimNode_PhyCloth) == 0x000440, "Wrong size on FAnimNode_PhyCloth");
static_assert(offsetof(FAnimNode_PhyCloth, ClothGroups) == 0x0000D0, "Member 'FAnimNode_PhyCloth::ClothGroups' has a wrong offset!");
static_assert(offsetof(FAnimNode_PhyCloth, OpenCollateralRotation) == 0x0000E0, "Member 'FAnimNode_PhyCloth::OpenCollateralRotation' has a wrong offset!");
static_assert(offsetof(FAnimNode_PhyCloth, MultiThread) == 0x0000E1, "Member 'FAnimNode_PhyCloth::MultiThread' has a wrong offset!");
static_assert(offsetof(FAnimNode_PhyCloth, Transport) == 0x0000E2, "Member 'FAnimNode_PhyCloth::Transport' has a wrong offset!");
static_assert(offsetof(FAnimNode_PhyCloth, TransportThreadHold) == 0x0000E4, "Member 'FAnimNode_PhyCloth::TransportThreadHold' has a wrong offset!");
static_assert(offsetof(FAnimNode_PhyCloth, MinIterTimes) == 0x0000E8, "Member 'FAnimNode_PhyCloth::MinIterTimes' has a wrong offset!");
static_assert(offsetof(FAnimNode_PhyCloth, MaxIterTimes) == 0x0000EC, "Member 'FAnimNode_PhyCloth::MaxIterTimes' has a wrong offset!");
static_assert(offsetof(FAnimNode_PhyCloth, MaxDeltaTime) == 0x0000F0, "Member 'FAnimNode_PhyCloth::MaxDeltaTime' has a wrong offset!");
static_assert(offsetof(FAnimNode_PhyCloth, WindSpeed) == 0x0000F4, "Member 'FAnimNode_PhyCloth::WindSpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_PhyCloth, AirDrag) == 0x000100, "Member 'FAnimNode_PhyCloth::AirDrag' has a wrong offset!");
static_assert(offsetof(FAnimNode_PhyCloth, DisturbPeriodic) == 0x000104, "Member 'FAnimNode_PhyCloth::DisturbPeriodic' has a wrong offset!");
static_assert(offsetof(FAnimNode_PhyCloth, DisturbStrMul) == 0x000108, "Member 'FAnimNode_PhyCloth::DisturbStrMul' has a wrong offset!");
static_assert(offsetof(FAnimNode_PhyCloth, DisturbStr) == 0x000110, "Member 'FAnimNode_PhyCloth::DisturbStr' has a wrong offset!");
static_assert(offsetof(FAnimNode_PhyCloth, DisturbSplit) == 0x000118, "Member 'FAnimNode_PhyCloth::DisturbSplit' has a wrong offset!");
static_assert(offsetof(FAnimNode_PhyCloth, OriginAlphaCurveName) == 0x000130, "Member 'FAnimNode_PhyCloth::OriginAlphaCurveName' has a wrong offset!");

// ScriptStruct KuroAnim.AnimNode_SightLock
// 0x00E8 (0x01B8 - 0x00D0)
struct FAnimNode_SightLock final : public FAnimNode_SkeletalControlBase
{
public:
	int32                                         Increment;                                         // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESightLockMode                                Mode;                                              // 0x00D4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D5[0x3];                                       // 0x00D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SightDirectInSightBone;                            // 0x00D8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                UpAxisInSightBone;                                 // 0x00E4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SightBoneBaseEuler;                                // 0x00F0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AssistRatio;                                       // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SightBoneLimit[0x4];                               // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AssistLimit;                                       // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetDirect;                                      // 0x0114(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SightBoneName;                                     // 0x0120(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BeginBoneName;                                     // 0x012C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndBoneName;                                       // 0x0138(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0x74];                                     // 0x0144(0x0074)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_SightLock) == 0x000008, "Wrong alignment on FAnimNode_SightLock");
static_assert(sizeof(FAnimNode_SightLock) == 0x0001B8, "Wrong size on FAnimNode_SightLock");
static_assert(offsetof(FAnimNode_SightLock, Increment) == 0x0000D0, "Member 'FAnimNode_SightLock::Increment' has a wrong offset!");
static_assert(offsetof(FAnimNode_SightLock, Mode) == 0x0000D4, "Member 'FAnimNode_SightLock::Mode' has a wrong offset!");
static_assert(offsetof(FAnimNode_SightLock, SightDirectInSightBone) == 0x0000D8, "Member 'FAnimNode_SightLock::SightDirectInSightBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_SightLock, UpAxisInSightBone) == 0x0000E4, "Member 'FAnimNode_SightLock::UpAxisInSightBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_SightLock, SightBoneBaseEuler) == 0x0000F0, "Member 'FAnimNode_SightLock::SightBoneBaseEuler' has a wrong offset!");
static_assert(offsetof(FAnimNode_SightLock, AssistRatio) == 0x0000FC, "Member 'FAnimNode_SightLock::AssistRatio' has a wrong offset!");
static_assert(offsetof(FAnimNode_SightLock, SightBoneLimit) == 0x000100, "Member 'FAnimNode_SightLock::SightBoneLimit' has a wrong offset!");
static_assert(offsetof(FAnimNode_SightLock, AssistLimit) == 0x000110, "Member 'FAnimNode_SightLock::AssistLimit' has a wrong offset!");
static_assert(offsetof(FAnimNode_SightLock, TargetDirect) == 0x000114, "Member 'FAnimNode_SightLock::TargetDirect' has a wrong offset!");
static_assert(offsetof(FAnimNode_SightLock, SightBoneName) == 0x000120, "Member 'FAnimNode_SightLock::SightBoneName' has a wrong offset!");
static_assert(offsetof(FAnimNode_SightLock, BeginBoneName) == 0x00012C, "Member 'FAnimNode_SightLock::BeginBoneName' has a wrong offset!");
static_assert(offsetof(FAnimNode_SightLock, EndBoneName) == 0x000138, "Member 'FAnimNode_SightLock::EndBoneName' has a wrong offset!");

// ScriptStruct KuroAnim.AnimNode_SlotBlend
// 0x0048 (0x0058 - 0x0010)
struct FAnimNode_SlotBlend final : public FAnimNode_Base
{
public:
	struct FPoseLink                              A;                                                 // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPoseLink                              B;                                                 // 0x0020(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bResetChildOnActivation : 1;                       // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SlotName;                                          // 0x0044(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_SlotBlend) == 0x000008, "Wrong alignment on FAnimNode_SlotBlend");
static_assert(sizeof(FAnimNode_SlotBlend) == 0x000058, "Wrong size on FAnimNode_SlotBlend");
static_assert(offsetof(FAnimNode_SlotBlend, A) == 0x000010, "Member 'FAnimNode_SlotBlend::A' has a wrong offset!");
static_assert(offsetof(FAnimNode_SlotBlend, B) == 0x000020, "Member 'FAnimNode_SlotBlend::B' has a wrong offset!");
static_assert(offsetof(FAnimNode_SlotBlend, SlotName) == 0x000044, "Member 'FAnimNode_SlotBlend::SlotName' has a wrong offset!");

// ScriptStruct KuroAnim.StatureConfig
// 0x0020 (0x0020 - 0x0000)
struct FStatureConfig final
{
public:
	struct FBoneReference                         Bone;                                              // 0x0000(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0014(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStatureConfig) == 0x000004, "Wrong alignment on FStatureConfig");
static_assert(sizeof(FStatureConfig) == 0x000020, "Wrong size on FStatureConfig");
static_assert(offsetof(FStatureConfig, Bone) == 0x000000, "Member 'FStatureConfig::Bone' has a wrong offset!");
static_assert(offsetof(FStatureConfig, Scale) == 0x000014, "Member 'FStatureConfig::Scale' has a wrong offset!");

// ScriptStruct KuroAnim.AnimNode_StatureScale
// 0x0070 (0x0080 - 0x0010)
struct FAnimNode_StatureScale final : public FAnimNode_Base
{
public:
	struct FPoseLink                              Base;                                              // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FStatureConfig>                 StatureConfigs;                                    // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_StatureScale) == 0x000008, "Wrong alignment on FAnimNode_StatureScale");
static_assert(sizeof(FAnimNode_StatureScale) == 0x000080, "Wrong size on FAnimNode_StatureScale");
static_assert(offsetof(FAnimNode_StatureScale, Base) == 0x000010, "Member 'FAnimNode_StatureScale::Base' has a wrong offset!");
static_assert(offsetof(FAnimNode_StatureScale, StatureConfigs) == 0x000020, "Member 'FAnimNode_StatureScale::StatureConfigs' has a wrong offset!");

// ScriptStruct KuroAnim.SuiguangTailBoneConfig
// 0x002C (0x002C - 0x0000)
struct FSuiguangTailBoneConfig final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnAngle;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookUpAngle;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              TurnLimit;                                         // 0x0014(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LookUpLimit;                                       // 0x001C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookUpOffset;                                      // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnUpOffset;                                      // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSuiguangTailBoneConfig) == 0x000004, "Wrong alignment on FSuiguangTailBoneConfig");
static_assert(sizeof(FSuiguangTailBoneConfig) == 0x00002C, "Wrong size on FSuiguangTailBoneConfig");
static_assert(offsetof(FSuiguangTailBoneConfig, BoneName) == 0x000000, "Member 'FSuiguangTailBoneConfig::BoneName' has a wrong offset!");
static_assert(offsetof(FSuiguangTailBoneConfig, TurnAngle) == 0x00000C, "Member 'FSuiguangTailBoneConfig::TurnAngle' has a wrong offset!");
static_assert(offsetof(FSuiguangTailBoneConfig, LookUpAngle) == 0x000010, "Member 'FSuiguangTailBoneConfig::LookUpAngle' has a wrong offset!");
static_assert(offsetof(FSuiguangTailBoneConfig, TurnLimit) == 0x000014, "Member 'FSuiguangTailBoneConfig::TurnLimit' has a wrong offset!");
static_assert(offsetof(FSuiguangTailBoneConfig, LookUpLimit) == 0x00001C, "Member 'FSuiguangTailBoneConfig::LookUpLimit' has a wrong offset!");
static_assert(offsetof(FSuiguangTailBoneConfig, LookUpOffset) == 0x000024, "Member 'FSuiguangTailBoneConfig::LookUpOffset' has a wrong offset!");
static_assert(offsetof(FSuiguangTailBoneConfig, TurnUpOffset) == 0x000028, "Member 'FSuiguangTailBoneConfig::TurnUpOffset' has a wrong offset!");

// ScriptStruct KuroAnim.AnimNode_SuiguangTailRotate
// 0x0038 (0x0108 - 0x00D0)
struct FAnimNode_SuiguangTailRotate final : public FAnimNode_SkeletalControlBase
{
public:
	struct FVector                                TargetLocation;                                    // 0x00D0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSuiguangTailBoneConfig>        SuiguangTailBoneConfig;                            // 0x00E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bRollBackToOrigin;                                 // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopRoll;                                         // 0x00F1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebug;                                            // 0x00F2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F3[0x15];                                      // 0x00F3(0x0015)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_SuiguangTailRotate) == 0x000008, "Wrong alignment on FAnimNode_SuiguangTailRotate");
static_assert(sizeof(FAnimNode_SuiguangTailRotate) == 0x000108, "Wrong size on FAnimNode_SuiguangTailRotate");
static_assert(offsetof(FAnimNode_SuiguangTailRotate, TargetLocation) == 0x0000D0, "Member 'FAnimNode_SuiguangTailRotate::TargetLocation' has a wrong offset!");
static_assert(offsetof(FAnimNode_SuiguangTailRotate, SuiguangTailBoneConfig) == 0x0000E0, "Member 'FAnimNode_SuiguangTailRotate::SuiguangTailBoneConfig' has a wrong offset!");
static_assert(offsetof(FAnimNode_SuiguangTailRotate, bRollBackToOrigin) == 0x0000F0, "Member 'FAnimNode_SuiguangTailRotate::bRollBackToOrigin' has a wrong offset!");
static_assert(offsetof(FAnimNode_SuiguangTailRotate, bStopRoll) == 0x0000F1, "Member 'FAnimNode_SuiguangTailRotate::bStopRoll' has a wrong offset!");
static_assert(offsetof(FAnimNode_SuiguangTailRotate, bDebug) == 0x0000F2, "Member 'FAnimNode_SuiguangTailRotate::bDebug' has a wrong offset!");

// ScriptStruct KuroAnim.AnimNode_TextureFace
// 0x00B8 (0x00C8 - 0x0010)
struct FAnimNode_TextureFace final : public FAnimNode_Base
{
public:
	struct FPoseLink                              Base;                                              // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FPoseLink                              CurveAnim;                                         // 0x0020(0x0010)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          Enable;                                            // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TexEyeOpenId;                                      // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TexEyeCloseId;                                     // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Alpha;                                             // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TexEyeCloseThreshold;                              // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 TexFaceMeshComp;                                   // 0x0048(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TexMatSlotName;                                    // 0x0050(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TexFaceSwitchKey;                                  // 0x005C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TexTargetCurveName;                                // 0x0068(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FaceSwitchRowName;                                 // 0x0074(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FaceSwitchRowNum;                                  // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           MouthCurves;                                       // 0x0088(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   MouthAlpha;                                        // 0x0098(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MouthAlphaThreshold;                               // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OpenMouthThreshold;                                // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OpenMouthTexId;                                    // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B0[0x18];                                      // 0x00B0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_TextureFace) == 0x000008, "Wrong alignment on FAnimNode_TextureFace");
static_assert(sizeof(FAnimNode_TextureFace) == 0x0000C8, "Wrong size on FAnimNode_TextureFace");
static_assert(offsetof(FAnimNode_TextureFace, Base) == 0x000010, "Member 'FAnimNode_TextureFace::Base' has a wrong offset!");
static_assert(offsetof(FAnimNode_TextureFace, CurveAnim) == 0x000020, "Member 'FAnimNode_TextureFace::CurveAnim' has a wrong offset!");
static_assert(offsetof(FAnimNode_TextureFace, Enable) == 0x000030, "Member 'FAnimNode_TextureFace::Enable' has a wrong offset!");
static_assert(offsetof(FAnimNode_TextureFace, TexEyeOpenId) == 0x000034, "Member 'FAnimNode_TextureFace::TexEyeOpenId' has a wrong offset!");
static_assert(offsetof(FAnimNode_TextureFace, TexEyeCloseId) == 0x000038, "Member 'FAnimNode_TextureFace::TexEyeCloseId' has a wrong offset!");
static_assert(offsetof(FAnimNode_TextureFace, Alpha) == 0x00003C, "Member 'FAnimNode_TextureFace::Alpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_TextureFace, TexEyeCloseThreshold) == 0x000040, "Member 'FAnimNode_TextureFace::TexEyeCloseThreshold' has a wrong offset!");
static_assert(offsetof(FAnimNode_TextureFace, TexFaceMeshComp) == 0x000048, "Member 'FAnimNode_TextureFace::TexFaceMeshComp' has a wrong offset!");
static_assert(offsetof(FAnimNode_TextureFace, TexMatSlotName) == 0x000050, "Member 'FAnimNode_TextureFace::TexMatSlotName' has a wrong offset!");
static_assert(offsetof(FAnimNode_TextureFace, TexFaceSwitchKey) == 0x00005C, "Member 'FAnimNode_TextureFace::TexFaceSwitchKey' has a wrong offset!");
static_assert(offsetof(FAnimNode_TextureFace, TexTargetCurveName) == 0x000068, "Member 'FAnimNode_TextureFace::TexTargetCurveName' has a wrong offset!");
static_assert(offsetof(FAnimNode_TextureFace, FaceSwitchRowName) == 0x000074, "Member 'FAnimNode_TextureFace::FaceSwitchRowName' has a wrong offset!");
static_assert(offsetof(FAnimNode_TextureFace, FaceSwitchRowNum) == 0x000080, "Member 'FAnimNode_TextureFace::FaceSwitchRowNum' has a wrong offset!");
static_assert(offsetof(FAnimNode_TextureFace, MouthCurves) == 0x000088, "Member 'FAnimNode_TextureFace::MouthCurves' has a wrong offset!");
static_assert(offsetof(FAnimNode_TextureFace, MouthAlpha) == 0x000098, "Member 'FAnimNode_TextureFace::MouthAlpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_TextureFace, MouthAlphaThreshold) == 0x0000A4, "Member 'FAnimNode_TextureFace::MouthAlphaThreshold' has a wrong offset!");
static_assert(offsetof(FAnimNode_TextureFace, OpenMouthThreshold) == 0x0000A8, "Member 'FAnimNode_TextureFace::OpenMouthThreshold' has a wrong offset!");
static_assert(offsetof(FAnimNode_TextureFace, OpenMouthTexId) == 0x0000AC, "Member 'FAnimNode_TextureFace::OpenMouthTexId' has a wrong offset!");

// ScriptStruct KuroAnim.ClimbStateStruct
// 0x0003 (0x0003 - 0x0000)
struct FClimbStateStruct final
{
public:
	EClimbStateType                               ClimbState;                                        // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEnterClimbType                               EnterClimbType;                                    // 0x0001(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExitClimbType                                ExitClimbType;                                     // 0x0002(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FClimbStateStruct) == 0x000001, "Wrong alignment on FClimbStateStruct");
static_assert(sizeof(FClimbStateStruct) == 0x000003, "Wrong size on FClimbStateStruct");
static_assert(offsetof(FClimbStateStruct, ClimbState) == 0x000000, "Member 'FClimbStateStruct::ClimbState' has a wrong offset!");
static_assert(offsetof(FClimbStateStruct, EnterClimbType) == 0x000001, "Member 'FClimbStateStruct::EnterClimbType' has a wrong offset!");
static_assert(offsetof(FClimbStateStruct, ExitClimbType) == 0x000002, "Member 'FClimbStateStruct::ExitClimbType' has a wrong offset!");

// ScriptStruct KuroAnim.ClimbInfoStruct
// 0x0010 (0x0010 - 0x0000)
struct FClimbInfoStruct final
{
public:
	bool                                          IsClimbMoving;                                     // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ClimbInput;                                        // 0x0004(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OnWallAngle;                                       // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FClimbInfoStruct) == 0x000004, "Wrong alignment on FClimbInfoStruct");
static_assert(sizeof(FClimbInfoStruct) == 0x000010, "Wrong size on FClimbInfoStruct");
static_assert(offsetof(FClimbInfoStruct, IsClimbMoving) == 0x000000, "Member 'FClimbInfoStruct::IsClimbMoving' has a wrong offset!");
static_assert(offsetof(FClimbInfoStruct, ClimbInput) == 0x000004, "Member 'FClimbInfoStruct::ClimbInput' has a wrong offset!");
static_assert(offsetof(FClimbInfoStruct, OnWallAngle) == 0x00000C, "Member 'FClimbInfoStruct::OnWallAngle' has a wrong offset!");

// ScriptStruct KuroAnim.LeanAmount
// 0x0008 (0x0008 - 0x0000)
struct FLeanAmount final
{
public:
	float                                         ForwardAndBackward;                                // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftAndRight;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLeanAmount) == 0x000004, "Wrong alignment on FLeanAmount");
static_assert(sizeof(FLeanAmount) == 0x000008, "Wrong size on FLeanAmount");
static_assert(offsetof(FLeanAmount, ForwardAndBackward) == 0x000000, "Member 'FLeanAmount::ForwardAndBackward' has a wrong offset!");
static_assert(offsetof(FLeanAmount, LeftAndRight) == 0x000004, "Member 'FLeanAmount::LeftAndRight' has a wrong offset!");

// ScriptStruct KuroAnim.VeloctiyBlend
// 0x0010 (0x0010 - 0x0000)
struct FVeloctiyBlend final
{
public:
	float                                         Forward;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Backward;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Left;                                              // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Right;                                             // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVeloctiyBlend) == 0x000004, "Wrong alignment on FVeloctiyBlend");
static_assert(sizeof(FVeloctiyBlend) == 0x000010, "Wrong size on FVeloctiyBlend");
static_assert(offsetof(FVeloctiyBlend, Forward) == 0x000000, "Member 'FVeloctiyBlend::Forward' has a wrong offset!");
static_assert(offsetof(FVeloctiyBlend, Backward) == 0x000004, "Member 'FVeloctiyBlend::Backward' has a wrong offset!");
static_assert(offsetof(FVeloctiyBlend, Left) == 0x000008, "Member 'FVeloctiyBlend::Left' has a wrong offset!");
static_assert(offsetof(FVeloctiyBlend, Right) == 0x00000C, "Member 'FVeloctiyBlend::Right' has a wrong offset!");

}

