#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroGameplay

#include "Basic.hpp"

#include "KuroCurve_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "KuroGameplay_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "SlateCore_structs.hpp"
#include "AIModule_classes.hpp"
#include "Niagara_structs.hpp"
#include "InputCore_structs.hpp"
#include "Slate_structs.hpp"
#include "UMG_classes.hpp"


namespace SDK
{

// Class KuroGameplay.KuroAIController
// 0x0000 (0x03B8 - 0x03B8)
class AKuroAIController : public AAIController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroAIController">();
	}
	static class AKuroAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroAIController>();
	}
};
static_assert(alignof(AKuroAIController) == 0x000008, "Wrong alignment on AKuroAIController");
static_assert(sizeof(AKuroAIController) == 0x0003B8, "Wrong size on AKuroAIController");

// Class KuroGameplay.EffectModelBase
// 0x0020 (0x0058 - 0x0038)
class UEffectModelBase : public UPrimaryDataAsset
{
public:
	float                                         StartTime;                                         // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoopTime;                                          // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndTime;                                           // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoPlay;                                          // 0x0044(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoDestroy;                                       // 0x0045(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreTimeDilation;                                // 0x0046(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UiScenePrimitive;                                  // 0x0047(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ImportanceLevel;                                   // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultManualTime;                                 // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultManualSpeed;                                // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreDisable;                                     // 0x0054(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableOnMobile;                                   // 0x0055(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HideOnBurstSkill;                                  // 0x0056(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeedDisableWithActor;                              // 0x0057(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectModelBase">();
	}
	static class UEffectModelBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectModelBase>();
	}
};
static_assert(alignof(UEffectModelBase) == 0x000008, "Wrong alignment on UEffectModelBase");
static_assert(sizeof(UEffectModelBase) == 0x000058, "Wrong size on UEffectModelBase");
static_assert(offsetof(UEffectModelBase, StartTime) == 0x000038, "Member 'UEffectModelBase::StartTime' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, LoopTime) == 0x00003C, "Member 'UEffectModelBase::LoopTime' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, EndTime) == 0x000040, "Member 'UEffectModelBase::EndTime' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, AutoPlay) == 0x000044, "Member 'UEffectModelBase::AutoPlay' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, AutoDestroy) == 0x000045, "Member 'UEffectModelBase::AutoDestroy' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, IgnoreTimeDilation) == 0x000046, "Member 'UEffectModelBase::IgnoreTimeDilation' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, UiScenePrimitive) == 0x000047, "Member 'UEffectModelBase::UiScenePrimitive' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, ImportanceLevel) == 0x000048, "Member 'UEffectModelBase::ImportanceLevel' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, DefaultManualTime) == 0x00004C, "Member 'UEffectModelBase::DefaultManualTime' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, DefaultManualSpeed) == 0x000050, "Member 'UEffectModelBase::DefaultManualSpeed' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, IgnoreDisable) == 0x000054, "Member 'UEffectModelBase::IgnoreDisable' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, DisableOnMobile) == 0x000055, "Member 'UEffectModelBase::DisableOnMobile' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, HideOnBurstSkill) == 0x000056, "Member 'UEffectModelBase::HideOnBurstSkill' has a wrong offset!");
static_assert(offsetof(UEffectModelBase, NeedDisableWithActor) == 0x000057, "Member 'UEffectModelBase::NeedDisableWithActor' has a wrong offset!");

// Class KuroGameplay.KuroEffectLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroEffectLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class USceneComponent* AddSceneComponent(class AActor* Actor, class UClass* Class_0, class USceneComponent* Parent, bool bDeferredFinish);
	static class USceneComponent* AddSceneComponentWithTransform(class AActor* Actor, class UClass* Class_0, class USceneComponent* Parent, bool bDeferredFinish, const struct FTransform& Transform);
	static bool EqualWorld(class UWorld* World, class UWorld* Other);
	static class USceneComponent* GetActorDefaultAttachComponent(class AActor* Actor);
	static float GetNiagaraEffectRegularTypeScalabilitySettingsMaxDistance(EKuroNiagaraEffectRegularType EffectRegularType);
	static EKuroNiagaraEffectRegularType GetNiagaraSystemEffectRegularType(class UNiagaraSystem* NiagaraSystem);
	static float GetNpcDisappearDistance();
	static void InitModelNiagaraSpec(class UNiagaraComponent* NiagaraComponent, bool bUIScene, bool bReceivesDecals, int32 TranslucencySortPriority);
	static bool IsNiagaraComponentHasBound(class UNiagaraComponent* NiagaraComponent);
	static void RegisterOnSystemFinished(class UNiagaraComponent* NiagaraComponent);
	static void RegisterOnSystemPaused(class UNiagaraComponent* NiagaraComponent);
	static bool SetNiagaraFrameDeltaTime(class UNiagaraComponent* NiagaraComponent, float DeltaTime);
	static void SetOnSystemFinishedDelegate(const TDelegate<void(class UNiagaraComponent* NiagaraComponent)>& Delegate);
	static void SetOnSystemPausedDelegate(const TDelegate<void(class UNiagaraComponent* NiagaraComponent, bool IsPaused)>& Delegate);
	static void UpdateEffectModelLightSpec(class UEffectModelLight* EffectModelLight, class UPointLightComponent* LightComponent, bool bForceUpdate, float Time, float DefaultMaxLightRadius);
	static void UpdateEffectModelNiagaraSpec(class UEffectModelNiagara* EffectModelNiagara, class UNiagaraComponent* NiagaraComponent, bool bForceUpdate, float Time, int32 ExtraState);
	static void UpdateEffectModelPostProcessMaterial(class UEffectModelPostProcess* EffectModelPostProcess, class UMaterialInstanceDynamic* DynMaterial, bool bForceUpdate, float Time);
	static struct FVector2D UpdateEffectModelPostProcessSpec(class UEffectModelPostProcess* EffectModelPostProcess, class UKuroPostProcessComponent* PostProcessComponent, bool bForceUpdate, float Time, class APlayerController* Controller, class ACharacter* Character, class AActor* EffectActor, const struct FVector2D& LastScreenUV);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroEffectLibrary">();
	}
	static class UKuroEffectLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroEffectLibrary>();
	}
};
static_assert(alignof(UKuroEffectLibrary) == 0x000008, "Wrong alignment on UKuroEffectLibrary");
static_assert(sizeof(UKuroEffectLibrary) == 0x000030, "Wrong size on UKuroEffectLibrary");

// Class KuroGameplay.EffectModelLight
// 0x0678 (0x06D0 - 0x0058)
class UEffectModelLight : public UEffectModelBase
{
public:
	struct FKuroCurveVector                       Location;                                          // 0x0058(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Intensity;                                         // 0x0200(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  Color;                                             // 0x0290(0x0220)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Radius;                                            // 0x04B0(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        FalloffExponent;                                   // 0x0540(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	ELightQualityType                             LightQualityType;                                  // 0x05D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D1[0x3];                                      // 0x05D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SourceRadius;                                      // 0x05D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoftSourceRadius;                                  // 0x05D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SourceLength;                                      // 0x05DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        CharacterLightAlpha;                               // 0x05E0(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         CharacterFalloffExponent;                          // 0x0670(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterBlendAtten;                               // 0x0674(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterBlendIntensity;                           // 0x0678(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EToonLightType                                ToonLightType;                                     // 0x067C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_67D[0x3];                                      // 0x067D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CharacterPriority;                                 // 0x0680(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterIntensity;                                // 0x0684(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           CharacterColor;                                    // 0x0688(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterShadowIntensity;                          // 0x0698(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterRealTimeShadowIntensity;                  // 0x069C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterDesaturationIntensity;                    // 0x06A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterHardIntensity;                            // 0x06A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           CharacterHardColor;                                // 0x06A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           CharacterHardShadowColor;                          // 0x06B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterHardBlend;                                // 0x06C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6CC[0x4];                                      // 0x06CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectModelLight">();
	}
	static class UEffectModelLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectModelLight>();
	}
};
static_assert(alignof(UEffectModelLight) == 0x000008, "Wrong alignment on UEffectModelLight");
static_assert(sizeof(UEffectModelLight) == 0x0006D0, "Wrong size on UEffectModelLight");
static_assert(offsetof(UEffectModelLight, Location) == 0x000058, "Member 'UEffectModelLight::Location' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, Intensity) == 0x000200, "Member 'UEffectModelLight::Intensity' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, Color) == 0x000290, "Member 'UEffectModelLight::Color' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, Radius) == 0x0004B0, "Member 'UEffectModelLight::Radius' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, FalloffExponent) == 0x000540, "Member 'UEffectModelLight::FalloffExponent' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, LightQualityType) == 0x0005D0, "Member 'UEffectModelLight::LightQualityType' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, SourceRadius) == 0x0005D4, "Member 'UEffectModelLight::SourceRadius' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, SoftSourceRadius) == 0x0005D8, "Member 'UEffectModelLight::SoftSourceRadius' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, SourceLength) == 0x0005DC, "Member 'UEffectModelLight::SourceLength' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterLightAlpha) == 0x0005E0, "Member 'UEffectModelLight::CharacterLightAlpha' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterFalloffExponent) == 0x000670, "Member 'UEffectModelLight::CharacterFalloffExponent' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterBlendAtten) == 0x000674, "Member 'UEffectModelLight::CharacterBlendAtten' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterBlendIntensity) == 0x000678, "Member 'UEffectModelLight::CharacterBlendIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, ToonLightType) == 0x00067C, "Member 'UEffectModelLight::ToonLightType' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterPriority) == 0x000680, "Member 'UEffectModelLight::CharacterPriority' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterIntensity) == 0x000684, "Member 'UEffectModelLight::CharacterIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterColor) == 0x000688, "Member 'UEffectModelLight::CharacterColor' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterShadowIntensity) == 0x000698, "Member 'UEffectModelLight::CharacterShadowIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterRealTimeShadowIntensity) == 0x00069C, "Member 'UEffectModelLight::CharacterRealTimeShadowIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterDesaturationIntensity) == 0x0006A0, "Member 'UEffectModelLight::CharacterDesaturationIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterHardIntensity) == 0x0006A4, "Member 'UEffectModelLight::CharacterHardIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterHardColor) == 0x0006A8, "Member 'UEffectModelLight::CharacterHardColor' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterHardShadowColor) == 0x0006B8, "Member 'UEffectModelLight::CharacterHardShadowColor' has a wrong offset!");
static_assert(offsetof(UEffectModelLight, CharacterHardBlend) == 0x0006C8, "Member 'UEffectModelLight::CharacterHardBlend' has a wrong offset!");

// Class KuroGameplay.KuroInputEvent
// 0x0028 (0x0058 - 0x0030)
class UKuroInputEvent final : public UObject
{
public:
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoActionCallback(const struct FKey& Key);
	void DoAxisCallback(float Value);
	void DoKeyCallback(const struct FKey& Key);
	void DoTouchCallback(const ETouchIndex TouchIndex, const struct FVector& Position);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroInputEvent">();
	}
	static class UKuroInputEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroInputEvent>();
	}
};
static_assert(alignof(UKuroInputEvent) == 0x000008, "Wrong alignment on UKuroInputEvent");
static_assert(sizeof(UKuroInputEvent) == 0x000058, "Wrong size on UKuroInputEvent");

// Class KuroGameplay.EffectModelNiagara
// 0x0608 (0x0660 - 0x0058)
class UEffectModelNiagara : public UEffectModelBase
{
public:
	struct FKuroCurveVector                       Location;                                          // 0x0058(0x01A8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       Rotation;                                          // 0x0200(0x01A8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       Scale;                                             // 0x03A8(0x01A8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         NiagaraRef;                                        // 0x0550(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FKuroCurveFloat>     FloatParameters;                                   // 0x0558(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FKuroCurveLinearColor> ColorParameters;                                   // 0x05A8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FKuroCurveVector>    VectorParameters;                                  // 0x05F8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          DeactivateOnStop;                                  // 0x0648(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReceiveDecal;                                      // 0x0649(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64A[0x2];                                      // 0x064A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TranslucencySortPriority;                          // 0x064C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FEffectModelNiagaraExtraState>  ExtraStates;                                       // 0x0650(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectModelNiagara">();
	}
	static class UEffectModelNiagara* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectModelNiagara>();
	}
};
static_assert(alignof(UEffectModelNiagara) == 0x000008, "Wrong alignment on UEffectModelNiagara");
static_assert(sizeof(UEffectModelNiagara) == 0x000660, "Wrong size on UEffectModelNiagara");
static_assert(offsetof(UEffectModelNiagara, Location) == 0x000058, "Member 'UEffectModelNiagara::Location' has a wrong offset!");
static_assert(offsetof(UEffectModelNiagara, Rotation) == 0x000200, "Member 'UEffectModelNiagara::Rotation' has a wrong offset!");
static_assert(offsetof(UEffectModelNiagara, Scale) == 0x0003A8, "Member 'UEffectModelNiagara::Scale' has a wrong offset!");
static_assert(offsetof(UEffectModelNiagara, NiagaraRef) == 0x000550, "Member 'UEffectModelNiagara::NiagaraRef' has a wrong offset!");
static_assert(offsetof(UEffectModelNiagara, FloatParameters) == 0x000558, "Member 'UEffectModelNiagara::FloatParameters' has a wrong offset!");
static_assert(offsetof(UEffectModelNiagara, ColorParameters) == 0x0005A8, "Member 'UEffectModelNiagara::ColorParameters' has a wrong offset!");
static_assert(offsetof(UEffectModelNiagara, VectorParameters) == 0x0005F8, "Member 'UEffectModelNiagara::VectorParameters' has a wrong offset!");
static_assert(offsetof(UEffectModelNiagara, DeactivateOnStop) == 0x000648, "Member 'UEffectModelNiagara::DeactivateOnStop' has a wrong offset!");
static_assert(offsetof(UEffectModelNiagara, ReceiveDecal) == 0x000649, "Member 'UEffectModelNiagara::ReceiveDecal' has a wrong offset!");
static_assert(offsetof(UEffectModelNiagara, TranslucencySortPriority) == 0x00064C, "Member 'UEffectModelNiagara::TranslucencySortPriority' has a wrong offset!");
static_assert(offsetof(UEffectModelNiagara, ExtraStates) == 0x000650, "Member 'UEffectModelNiagara::ExtraStates' has a wrong offset!");

// Class KuroGameplay.EffectModelPostProcess
// 0x2490 (0x24E8 - 0x0058)
class UEffectModelPostProcess : public UEffectModelBase
{
public:
	struct FKuroCurveVector                       Location;                                          // 0x0058(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          EnableVolume;                                      // 0x0200(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_201[0x3];                                      // 0x0201(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VolumeRadius;                                      // 0x0204(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeHardness;                                    // 0x0208(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseVolumeHardnessCurve;                            // 0x020C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20D[0x3];                                      // 0x020D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        VolumeHardnessCurve;                               // 0x0210(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         WeatherPriority;                                   // 0x02A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnablePostprocessMaterial;                        // 0x02A4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A5[0x3];                                      // 0x02A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     PostprocessMaterial;                               // 0x02A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FKuroCurveFloat>     PostprocessMaterialFloatParameters;                // 0x02B0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FKuroCurveLinearColor> PostprocessMaterialColorParameters;                // 0x0300(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          BlurIntensityOverride;                             // 0x0350(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_351[0x7];                                      // 0x0351(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        BlurIntensity;                                     // 0x0358(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          UseWorldPosition;                                  // 0x03E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E9[0x3];                                      // 0x03E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ScreenPosition;                                    // 0x03EC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F4[0x4];                                      // 0x03F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        RadialBlurRadius;                                  // 0x03F8(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        RadialBlurHardness;                                // 0x0488(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UTexture*                               RadialBlurMask;                                    // 0x0518(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RadialBlurMaskScale;                               // 0x0520(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  RadialBlurMaskScaleOffset;                         // 0x0528(0x0220)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          MainLightIntensityOverride;                        // 0x0748(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_749[0x7];                                      // 0x0749(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        MainLightIntensity;                                // 0x0750(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          MainLightColorOverride;                            // 0x07E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E1[0x7];                                      // 0x07E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveLinearColor                  MainLightColor;                                    // 0x07E8(0x0220)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          SkyLightIntensityOverride;                         // 0x0A08(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A09[0x7];                                      // 0x0A09(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        SkyLightIntensity;                                 // 0x0A10(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          SkyLightColorOverride;                             // 0x0AA0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA1[0x7];                                      // 0x0AA1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveLinearColor                  SkyLightColor;                                     // 0x0AA8(0x0220)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          FogDensityOverride;                                // 0x0CC8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC9[0x7];                                      // 0x0CC9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        FogDensity;                                        // 0x0CD0(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        FogStartDistance;                                  // 0x0D60(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         FogFalloff;                                        // 0x0DF0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FogColorOverride;                                  // 0x0DF4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DF5[0x3];                                      // 0x0DF5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveLinearColor                  FogNearColor;                                      // 0x0DF8(0x0220)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  FogFarColor;                                       // 0x1018(0x0220)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        FogNearColorDistance;                              // 0x1238(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        FogFarColorDistance;                               // 0x12C8(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         FogColorRatio;                                     // 0x1358(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          KuroBloomIntensityOverride;                        // 0x135C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_135D[0x3];                                     // 0x135D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        KuroBloomIntensity;                                // 0x1360(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          KuroThresholdOverride;                             // 0x13F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13F1[0x7];                                     // 0x13F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        KuroThreshold;                                     // 0x13F8(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          SceneFringeIntensityOverride;                      // 0x1488(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1489[0x7];                                     // 0x1489(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        SceneFringeIntensity;                              // 0x1490(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          StartOffsetOverride;                               // 0x1520(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1521[0x7];                                     // 0x1521(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        StartOffset;                                       // 0x1528(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          VignetteIntensityOverride;                         // 0x15B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15B9[0x7];                                     // 0x15B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        VignetteIntensity;                                 // 0x15C0(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          GrainJitterOverride;                               // 0x1650(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1651[0x7];                                     // 0x1651(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        GrainJitter;                                       // 0x1658(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          GrainIntensityOverride;                            // 0x16E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16E9[0x7];                                     // 0x16E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        GrainIntensity;                                    // 0x16F0(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          LutIntensityOverride;                              // 0x1780(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1781[0x7];                                     // 0x1781(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        LutIntensity;                                      // 0x1788(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          LutTextureOverride;                                // 0x1818(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1819[0x7];                                     // 0x1819(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             LutTexture;                                        // 0x1820(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SceneColorTintOverride;                            // 0x1828(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1829[0x7];                                     // 0x1829(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveLinearColor                  SceneColorTint;                                    // 0x1830(0x0220)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          SceneColorDesaturateOverride;                      // 0x1A50(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A51[0x7];                                     // 0x1A51(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        SceneColorDesaturate;                              // 0x1A58(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          BlackWhiteFlashIntensityOverride;                  // 0x1AE8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AE9[0x7];                                     // 0x1AE9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        BlackWhiteFlashIntensity;                          // 0x1AF0(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          BlackWhiteFlashFactorOverride;                     // 0x1B80(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B81[0x7];                                     // 0x1B81(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        BlackWhiteFlashFactor;                             // 0x1B88(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          BlackWhiteFlashThresholdOverride;                  // 0x1C18(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C19[0x7];                                     // 0x1C19(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        BlackWhiteFlashThreshold;                          // 0x1C20(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          BlackWhiteFlashBlackAreaColorOverride;             // 0x1CB0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CB1[0x7];                                     // 0x1CB1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveLinearColor                  BlackWhiteFlashBlackAreaColor;                     // 0x1CB8(0x0220)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          BlackWhiteFlashWhiteAreaColorOverride;             // 0x1ED8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1ED9[0x7];                                     // 0x1ED9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveLinearColor                  BlackWhiteFlashWhiteAreaColor;                     // 0x1EE0(0x0220)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          GrayGradationOverride;                             // 0x2100(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          GrayGradationCullTranslucency;                     // 0x2101(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          GrayGradationUsePlayerLocation;                    // 0x2102(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2103[0x5];                                     // 0x2103(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        GrayGradationDegree;                               // 0x2108(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        GrayGradationLerpWidth;                            // 0x2198(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UTexture2D*                             GrayGradationRampTexture;                          // 0x2228(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  GrayGradationColorTint;                            // 0x2230(0x0220)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        GrayGradationBlendWeight;                          // 0x2450(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UKuroWeatherDataAsset*                  WeatherDataAsset;                                  // 0x24E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectModelPostProcess">();
	}
	static class UEffectModelPostProcess* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEffectModelPostProcess>();
	}
};
static_assert(alignof(UEffectModelPostProcess) == 0x000008, "Wrong alignment on UEffectModelPostProcess");
static_assert(sizeof(UEffectModelPostProcess) == 0x0024E8, "Wrong size on UEffectModelPostProcess");
static_assert(offsetof(UEffectModelPostProcess, Location) == 0x000058, "Member 'UEffectModelPostProcess::Location' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, EnableVolume) == 0x000200, "Member 'UEffectModelPostProcess::EnableVolume' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VolumeRadius) == 0x000204, "Member 'UEffectModelPostProcess::VolumeRadius' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VolumeHardness) == 0x000208, "Member 'UEffectModelPostProcess::VolumeHardness' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, UseVolumeHardnessCurve) == 0x00020C, "Member 'UEffectModelPostProcess::UseVolumeHardnessCurve' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VolumeHardnessCurve) == 0x000210, "Member 'UEffectModelPostProcess::VolumeHardnessCurve' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, WeatherPriority) == 0x0002A0, "Member 'UEffectModelPostProcess::WeatherPriority' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, bEnablePostprocessMaterial) == 0x0002A4, "Member 'UEffectModelPostProcess::bEnablePostprocessMaterial' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, PostprocessMaterial) == 0x0002A8, "Member 'UEffectModelPostProcess::PostprocessMaterial' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, PostprocessMaterialFloatParameters) == 0x0002B0, "Member 'UEffectModelPostProcess::PostprocessMaterialFloatParameters' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, PostprocessMaterialColorParameters) == 0x000300, "Member 'UEffectModelPostProcess::PostprocessMaterialColorParameters' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, BlurIntensityOverride) == 0x000350, "Member 'UEffectModelPostProcess::BlurIntensityOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, BlurIntensity) == 0x000358, "Member 'UEffectModelPostProcess::BlurIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, UseWorldPosition) == 0x0003E8, "Member 'UEffectModelPostProcess::UseWorldPosition' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, ScreenPosition) == 0x0003EC, "Member 'UEffectModelPostProcess::ScreenPosition' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, RadialBlurRadius) == 0x0003F8, "Member 'UEffectModelPostProcess::RadialBlurRadius' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, RadialBlurHardness) == 0x000488, "Member 'UEffectModelPostProcess::RadialBlurHardness' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, RadialBlurMask) == 0x000518, "Member 'UEffectModelPostProcess::RadialBlurMask' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, RadialBlurMaskScale) == 0x000520, "Member 'UEffectModelPostProcess::RadialBlurMaskScale' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, RadialBlurMaskScaleOffset) == 0x000528, "Member 'UEffectModelPostProcess::RadialBlurMaskScaleOffset' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, MainLightIntensityOverride) == 0x000748, "Member 'UEffectModelPostProcess::MainLightIntensityOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, MainLightIntensity) == 0x000750, "Member 'UEffectModelPostProcess::MainLightIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, MainLightColorOverride) == 0x0007E0, "Member 'UEffectModelPostProcess::MainLightColorOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, MainLightColor) == 0x0007E8, "Member 'UEffectModelPostProcess::MainLightColor' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, SkyLightIntensityOverride) == 0x000A08, "Member 'UEffectModelPostProcess::SkyLightIntensityOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, SkyLightIntensity) == 0x000A10, "Member 'UEffectModelPostProcess::SkyLightIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, SkyLightColorOverride) == 0x000AA0, "Member 'UEffectModelPostProcess::SkyLightColorOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, SkyLightColor) == 0x000AA8, "Member 'UEffectModelPostProcess::SkyLightColor' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, FogDensityOverride) == 0x000CC8, "Member 'UEffectModelPostProcess::FogDensityOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, FogDensity) == 0x000CD0, "Member 'UEffectModelPostProcess::FogDensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, FogStartDistance) == 0x000D60, "Member 'UEffectModelPostProcess::FogStartDistance' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, FogFalloff) == 0x000DF0, "Member 'UEffectModelPostProcess::FogFalloff' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, FogColorOverride) == 0x000DF4, "Member 'UEffectModelPostProcess::FogColorOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, FogNearColor) == 0x000DF8, "Member 'UEffectModelPostProcess::FogNearColor' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, FogFarColor) == 0x001018, "Member 'UEffectModelPostProcess::FogFarColor' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, FogNearColorDistance) == 0x001238, "Member 'UEffectModelPostProcess::FogNearColorDistance' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, FogFarColorDistance) == 0x0012C8, "Member 'UEffectModelPostProcess::FogFarColorDistance' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, FogColorRatio) == 0x001358, "Member 'UEffectModelPostProcess::FogColorRatio' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, KuroBloomIntensityOverride) == 0x00135C, "Member 'UEffectModelPostProcess::KuroBloomIntensityOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, KuroBloomIntensity) == 0x001360, "Member 'UEffectModelPostProcess::KuroBloomIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, KuroThresholdOverride) == 0x0013F0, "Member 'UEffectModelPostProcess::KuroThresholdOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, KuroThreshold) == 0x0013F8, "Member 'UEffectModelPostProcess::KuroThreshold' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, SceneFringeIntensityOverride) == 0x001488, "Member 'UEffectModelPostProcess::SceneFringeIntensityOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, SceneFringeIntensity) == 0x001490, "Member 'UEffectModelPostProcess::SceneFringeIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, StartOffsetOverride) == 0x001520, "Member 'UEffectModelPostProcess::StartOffsetOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, StartOffset) == 0x001528, "Member 'UEffectModelPostProcess::StartOffset' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VignetteIntensityOverride) == 0x0015B8, "Member 'UEffectModelPostProcess::VignetteIntensityOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, VignetteIntensity) == 0x0015C0, "Member 'UEffectModelPostProcess::VignetteIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, GrainJitterOverride) == 0x001650, "Member 'UEffectModelPostProcess::GrainJitterOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, GrainJitter) == 0x001658, "Member 'UEffectModelPostProcess::GrainJitter' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, GrainIntensityOverride) == 0x0016E8, "Member 'UEffectModelPostProcess::GrainIntensityOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, GrainIntensity) == 0x0016F0, "Member 'UEffectModelPostProcess::GrainIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, LutIntensityOverride) == 0x001780, "Member 'UEffectModelPostProcess::LutIntensityOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, LutIntensity) == 0x001788, "Member 'UEffectModelPostProcess::LutIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, LutTextureOverride) == 0x001818, "Member 'UEffectModelPostProcess::LutTextureOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, LutTexture) == 0x001820, "Member 'UEffectModelPostProcess::LutTexture' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, SceneColorTintOverride) == 0x001828, "Member 'UEffectModelPostProcess::SceneColorTintOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, SceneColorTint) == 0x001830, "Member 'UEffectModelPostProcess::SceneColorTint' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, SceneColorDesaturateOverride) == 0x001A50, "Member 'UEffectModelPostProcess::SceneColorDesaturateOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, SceneColorDesaturate) == 0x001A58, "Member 'UEffectModelPostProcess::SceneColorDesaturate' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, BlackWhiteFlashIntensityOverride) == 0x001AE8, "Member 'UEffectModelPostProcess::BlackWhiteFlashIntensityOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, BlackWhiteFlashIntensity) == 0x001AF0, "Member 'UEffectModelPostProcess::BlackWhiteFlashIntensity' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, BlackWhiteFlashFactorOverride) == 0x001B80, "Member 'UEffectModelPostProcess::BlackWhiteFlashFactorOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, BlackWhiteFlashFactor) == 0x001B88, "Member 'UEffectModelPostProcess::BlackWhiteFlashFactor' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, BlackWhiteFlashThresholdOverride) == 0x001C18, "Member 'UEffectModelPostProcess::BlackWhiteFlashThresholdOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, BlackWhiteFlashThreshold) == 0x001C20, "Member 'UEffectModelPostProcess::BlackWhiteFlashThreshold' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, BlackWhiteFlashBlackAreaColorOverride) == 0x001CB0, "Member 'UEffectModelPostProcess::BlackWhiteFlashBlackAreaColorOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, BlackWhiteFlashBlackAreaColor) == 0x001CB8, "Member 'UEffectModelPostProcess::BlackWhiteFlashBlackAreaColor' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, BlackWhiteFlashWhiteAreaColorOverride) == 0x001ED8, "Member 'UEffectModelPostProcess::BlackWhiteFlashWhiteAreaColorOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, BlackWhiteFlashWhiteAreaColor) == 0x001EE0, "Member 'UEffectModelPostProcess::BlackWhiteFlashWhiteAreaColor' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, GrayGradationOverride) == 0x002100, "Member 'UEffectModelPostProcess::GrayGradationOverride' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, GrayGradationCullTranslucency) == 0x002101, "Member 'UEffectModelPostProcess::GrayGradationCullTranslucency' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, GrayGradationUsePlayerLocation) == 0x002102, "Member 'UEffectModelPostProcess::GrayGradationUsePlayerLocation' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, GrayGradationDegree) == 0x002108, "Member 'UEffectModelPostProcess::GrayGradationDegree' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, GrayGradationLerpWidth) == 0x002198, "Member 'UEffectModelPostProcess::GrayGradationLerpWidth' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, GrayGradationRampTexture) == 0x002228, "Member 'UEffectModelPostProcess::GrayGradationRampTexture' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, GrayGradationColorTint) == 0x002230, "Member 'UEffectModelPostProcess::GrayGradationColorTint' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, GrayGradationBlendWeight) == 0x002450, "Member 'UEffectModelPostProcess::GrayGradationBlendWeight' has a wrong offset!");
static_assert(offsetof(UEffectModelPostProcess, WeatherDataAsset) == 0x0024E0, "Member 'UEffectModelPostProcess::WeatherDataAsset' has a wrong offset!");

// Class KuroGameplay.GameBudgetAllocator
// 0x0590 (0x05C0 - 0x0030)
class UGameBudgetAllocator final : public UObject
{
public:
	uint8                                         Pad_30[0x590];                                     // 0x0030(0x0590)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AfterTickOutside(float DeltaSeconds);
	void SetCenterActor(class AActor* CenterActor);
	void SetDefaultTickIntervalDetailConfig(struct FGameBudgetAllocatorGroupConfig* Config, uint32 MaxTickInterval, uint16 TickReductionStartSize, uint16 TickReductionIntervalSize);
	void SetGlobalMode(EGameBudgetAllocatorGlobalMode Mode);
	void SetGroupConfig(class FName GroupName, const struct FGameBudgetAllocatorGroupConfig& Config);
	void SetMaximumFrameRate(uint32 MaxFPS);
	void SetTickIntervalDetailConfig(struct FGameBudgetAllocatorGroupConfig* Config, EGameBudgetAllocatorGlobalMode GlobalMode, EGameBudgetAllocatorActorMode ActorMode, uint32 MaxTickInterval, uint16 TickReductionStartSize, uint16 TickReductionIntervalSize);
	void TickOutside(float DeltaSeconds);
	void UpdateMinUpdateFIFOBudgetTime(float Time);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameBudgetAllocator">();
	}
	static class UGameBudgetAllocator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameBudgetAllocator>();
	}
};
static_assert(alignof(UGameBudgetAllocator) == 0x000008, "Wrong alignment on UGameBudgetAllocator");
static_assert(sizeof(UGameBudgetAllocator) == 0x0005C0, "Wrong size on UGameBudgetAllocator");

// Class KuroGameplay.KuroInputManager
// 0x0060 (0x0090 - 0x0030)
class UKuroInputManager final : public UObject
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UKuroInputEvent*>                HoldEvents;                                        // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void OnActorDestroy(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroInputManager">();
	}
	static class UKuroInputManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroInputManager>();
	}
};
static_assert(alignof(UKuroInputManager) == 0x000008, "Wrong alignment on UKuroInputManager");
static_assert(sizeof(UKuroInputManager) == 0x000090, "Wrong size on UKuroInputManager");
static_assert(offsetof(UKuroInputManager, HoldEvents) == 0x000080, "Member 'UKuroInputManager::HoldEvents' has a wrong offset!");

// Class KuroGameplay.KuroLevelPlayLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroLevelPlayLibrary final : public UBlueprintFunctionLibrary
{
public:
	static int32 GetEntityIdByBaseItem(class AActor* Actor);
	static void RegisterBaseItemInfo(class UClass* BaseItemClass, const class FString& EntityIdName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroLevelPlayLibrary">();
	}
	static class UKuroLevelPlayLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroLevelPlayLibrary>();
	}
};
static_assert(alignof(UKuroLevelPlayLibrary) == 0x000008, "Wrong alignment on UKuroLevelPlayLibrary");
static_assert(sizeof(UKuroLevelPlayLibrary) == 0x000030, "Wrong size on UKuroLevelPlayLibrary");

// Class KuroGameplay.KuroMultilBgProgressBar
// 0x0320 (0x0490 - 0x0170)
class UKuroMultilBgProgressBar final : public UWidget
{
public:
	struct FProgressBarStyle                      WidgetStyle;                                       // 0x0170(0x0248)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class USlateWidgetStyleAsset*                 Style;                                             // 0x03B8(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       BackgroundImage;                                   // 0x03C0(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       FillImageMiddle;                                   // 0x03C8(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       FillImage;                                         // 0x03D0(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlateBrushAsset*                       MarqueeImage;                                      // 0x03D8(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MiddlePercent;                                     // 0x03E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Percent;                                           // 0x03E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProgressBarFillType                          BarFillType;                                       // 0x03E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMarquee;                                        // 0x03E9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3EA[0x2];                                      // 0x03EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              BorderPadding;                                     // 0x03EC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F4[0x4];                                      // 0x03F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             PercentDelegate;                                   // 0x03F8(0x0028)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void()>                             MiddlePercentDelegate;                             // 0x0420(0x0028)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	struct FLinearColor                           FillColorAndOpacity;                               // 0x0448(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             FillColorAndOpacityDelegate;                       // 0x0458(0x0028)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_480[0x10];                                     // 0x0480(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetFillColorAndOpacity(const struct FLinearColor& InColor);
	void SetIsMarquee(bool InbIsMarquee);
	void SetMiddlePercent(float InPercent);
	void SetPercent(float InPercent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroMultilBgProgressBar">();
	}
	static class UKuroMultilBgProgressBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroMultilBgProgressBar>();
	}
};
static_assert(alignof(UKuroMultilBgProgressBar) == 0x000008, "Wrong alignment on UKuroMultilBgProgressBar");
static_assert(sizeof(UKuroMultilBgProgressBar) == 0x000490, "Wrong size on UKuroMultilBgProgressBar");
static_assert(offsetof(UKuroMultilBgProgressBar, WidgetStyle) == 0x000170, "Member 'UKuroMultilBgProgressBar::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, Style) == 0x0003B8, "Member 'UKuroMultilBgProgressBar::Style' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, BackgroundImage) == 0x0003C0, "Member 'UKuroMultilBgProgressBar::BackgroundImage' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, FillImageMiddle) == 0x0003C8, "Member 'UKuroMultilBgProgressBar::FillImageMiddle' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, FillImage) == 0x0003D0, "Member 'UKuroMultilBgProgressBar::FillImage' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, MarqueeImage) == 0x0003D8, "Member 'UKuroMultilBgProgressBar::MarqueeImage' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, MiddlePercent) == 0x0003E0, "Member 'UKuroMultilBgProgressBar::MiddlePercent' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, Percent) == 0x0003E4, "Member 'UKuroMultilBgProgressBar::Percent' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, BarFillType) == 0x0003E8, "Member 'UKuroMultilBgProgressBar::BarFillType' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, bIsMarquee) == 0x0003E9, "Member 'UKuroMultilBgProgressBar::bIsMarquee' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, BorderPadding) == 0x0003EC, "Member 'UKuroMultilBgProgressBar::BorderPadding' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, PercentDelegate) == 0x0003F8, "Member 'UKuroMultilBgProgressBar::PercentDelegate' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, MiddlePercentDelegate) == 0x000420, "Member 'UKuroMultilBgProgressBar::MiddlePercentDelegate' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, FillColorAndOpacity) == 0x000448, "Member 'UKuroMultilBgProgressBar::FillColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UKuroMultilBgProgressBar, FillColorAndOpacityDelegate) == 0x000458, "Member 'UKuroMultilBgProgressBar::FillColorAndOpacityDelegate' has a wrong offset!");

// Class KuroGameplay.KuroResourceManager
// 0x0160 (0x0190 - 0x0030)
class UKuroResourceManager final : public UObject
{
public:
	TDelegate<void(int32 HandleId)>               LoadResourceDelegate;                              // 0x0030(0x0028)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x138];                                     // 0x0058(0x0138)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UObject* GetAsset(const int32 HandleId);
	int32 LoadAsyncWithId(const class FString& Path, const int32 HandleId, const int32 Priority);
	int32 LoadWithId(const class FString& Path, const int32 HandleId);
	void Release(const int32 HandleId);
	bool WaitComplete(const int32 HandleId, const float Timeout);

	void DebugDumpLoadingAssets() const;
	class UObject* GetLoadedAsset(const class FString& Path) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroResourceManager">();
	}
	static class UKuroResourceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroResourceManager>();
	}
};
static_assert(alignof(UKuroResourceManager) == 0x000008, "Wrong alignment on UKuroResourceManager");
static_assert(sizeof(UKuroResourceManager) == 0x000190, "Wrong size on UKuroResourceManager");
static_assert(offsetof(UKuroResourceManager, LoadResourceDelegate) == 0x000030, "Member 'UKuroResourceManager::LoadResourceDelegate' has a wrong offset!");

// Class KuroGameplay.KuroSequencePerformanceManager
// 0x0000 (0x0030 - 0x0030)
class UKuroSequencePerformanceManager final : public UBlueprintFunctionLibrary
{
public:
	static void CloseKuroPerformanceMode();
	static void EditPerformanceConfiguration(const TArray<class FString>& CmdArray);
	static void ExecuteCommandInPerformance(const class FString& Command, class FString* CommandOriginalValue);
	static EKuroPerformanceMode GetPerformanceMode();
	static void OpenKuroPerformanceMode();
	static void SetPerformanceMode(const EKuroPerformanceMode CurrentPerformanceMode);

	void CloseKuroPerformanceModeInEditor();
	void OpenKuroPerformanceModeInEditor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroSequencePerformanceManager">();
	}
	static class UKuroSequencePerformanceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroSequencePerformanceManager>();
	}
};
static_assert(alignof(UKuroSequencePerformanceManager) == 0x000008, "Wrong alignment on UKuroSequencePerformanceManager");
static_assert(sizeof(UKuroSequencePerformanceManager) == 0x000030, "Wrong size on UKuroSequencePerformanceManager");

// Class KuroGameplay.KuroSequenceRuntimeFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroSequenceRuntimeFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FSequencerBindingRuntimeProxy FindBindingById(class UMovieSceneSequence* Sequence, const struct FGuid& BindingId);
	static TArray<class UMovieSceneTrack*> FindMasterTracksByType(class UMovieSceneSequence* Sequence, TSubclassOf<class UMovieSceneTrack> TrackType);
	static TArray<class UMovieSceneTrack*> FindTracksByType(const struct FSequencerBindingRuntimeProxy& InBinding, TSubclassOf<class UMovieSceneTrack> TrackType);
	static int32 GetEndFrame(class UMovieSceneSection* Section);
	static float GetFadeAmountAt(class UMovieSceneFadeSection* Section, const struct FFrameTime& Frame);
	static struct FTransform GetFrameTransform(class UMovieSceneTrack* Track, const struct FFrameTime& Frame);
	static bool GetFrameTransformByTag(class UMovieSceneSequence* Sequence, class FName Tag, int32 OutsideFrame, struct FTransform* OutTransfom);
	static TArray<class UMovieSceneTrack*> GetMasterTracks(class UMovieSceneSequence* Sequence);
	static class UObject* GetObjectTemplate(const struct FSequencerBindingRuntimeProxy& InBinding);
	static int32 GetPlaybackEnd(class UMovieSceneSequence* Sequence);
	static int32 GetPlaybackStart(class UMovieSceneSequence* Sequence);
	static TArray<class UMovieSceneSection*> GetSections(class UMovieSceneTrack* Track);
	static TArray<struct FSequencerBindingRuntimeProxy> GetSpawnables(class UMovieSceneSequence* Sequence);
	static int32 GetStartFrame(class UMovieSceneSection* Section);
	static TArray<class UMovieSceneTrack*> GetTracks(const struct FSequencerBindingRuntimeProxy& InBinding);
	static bool HandleSeqTexStreaming(const class ULevelSequence* LevelSequences, const bool bStartForceStreamIn);
	static void MuteTrackByTag(class UMovieSceneSequence* Sequence, class FName Tag, bool bIsMuted);
	static void ResetMovieSceneCompiledData(class UMovieSceneSequence* Sequence);
	static bool SectionContains(class UMovieSceneSection* Section, const struct FFrameTime& Frame);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroSequenceRuntimeFunctionLibrary">();
	}
	static class UKuroSequenceRuntimeFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroSequenceRuntimeFunctionLibrary>();
	}
};
static_assert(alignof(UKuroSequenceRuntimeFunctionLibrary) == 0x000008, "Wrong alignment on UKuroSequenceRuntimeFunctionLibrary");
static_assert(sizeof(UKuroSequenceRuntimeFunctionLibrary) == 0x000030, "Wrong size on UKuroSequenceRuntimeFunctionLibrary");

// Class KuroGameplay.KuroStaticMeshLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroStaticMeshLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void MergeSimpleCollisions(class UStaticMeshComponent* TemplateComponent, const TArray<struct FTransform>& LocalTransforms);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroStaticMeshLibrary">();
	}
	static class UKuroStaticMeshLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroStaticMeshLibrary>();
	}
};
static_assert(alignof(UKuroStaticMeshLibrary) == 0x000008, "Wrong alignment on UKuroStaticMeshLibrary");
static_assert(sizeof(UKuroStaticMeshLibrary) == 0x000030, "Wrong size on UKuroStaticMeshLibrary");

// Class KuroGameplay.PerformanceStatisticsLibrary
// 0x0000 (0x0030 - 0x0030)
class UPerformanceStatisticsLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddStatistics(class FName SectionName, int32 FrameCount, const class FString& Tag, int32 MeasureMode, float Time, const class FString& UserDefineMessage);
	static void Clear();
	static void Export();
	static void ReadAllSectionsFromDirectory();
	static void ReadSectionFromFile(class FString* FilePath);
	static void StatisticsFromRawDataFiles();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerformanceStatisticsLibrary">();
	}
	static class UPerformanceStatisticsLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerformanceStatisticsLibrary>();
	}
};
static_assert(alignof(UPerformanceStatisticsLibrary) == 0x000008, "Wrong alignment on UPerformanceStatisticsLibrary");
static_assert(sizeof(UPerformanceStatisticsLibrary) == 0x000030, "Wrong size on UPerformanceStatisticsLibrary");

}

