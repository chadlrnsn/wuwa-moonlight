#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroAnim

#include "Basic.hpp"

#include "KuroAnim_classes.hpp"
#include "KuroAnim_parameters.hpp"


namespace SDK
{

// Function KuroAnim.KuroAnimInstance.AngleConversion
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Angle                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroAnimInstance::AngleConversion(const float& Angle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "AngleConversion");

	Params::KuroAnimInstance_AngleConversion Parms{};

	Parms.Angle = Angle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroAnim.KuroAnimInstance.BindBooleanVarToActorTag
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                                    BooleanVarRef                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroAnimInstance::BindBooleanVarToActorTag(bool& BooleanVarRef, class FName Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "BindBooleanVarToActorTag");

	Params::KuroAnimInstance_BindBooleanVarToActorTag Parms{};

	Parms.BooleanVarRef = BooleanVarRef;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	BooleanVarRef = Parms.BooleanVarRef;
}


// Function KuroAnim.KuroAnimInstance.BindBooleanVarToTag
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                                    BooleanVarRef                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroAnimInstance::BindBooleanVarToTag(bool& BooleanVarRef, const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "BindBooleanVarToTag");

	Params::KuroAnimInstance_BindBooleanVarToTag Parms{};

	Parms.BooleanVarRef = BooleanVarRef;
	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	BooleanVarRef = Parms.BooleanVarRef;
}


// Function KuroAnim.KuroAnimInstance.BindComponentVarToAnimInstance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Component                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ComponentVarName                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InstanceVarName                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroAnimInstance::BindComponentVarToAnimInstance(class UObject* Component, const class FString& ComponentVarName, const class FString& InstanceVarName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "BindComponentVarToAnimInstance");

	Params::KuroAnimInstance_BindComponentVarToAnimInstance Parms{};

	Parms.Component = Component;
	Parms.ComponentVarName = std::move(ComponentVarName);
	Parms.InstanceVarName = std::move(InstanceVarName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroAnim.KuroAnimInstance.BindEnumToRoleAnimInstance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Component                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroAnimInstance::BindEnumToRoleAnimInstance(class UObject* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "BindEnumToRoleAnimInstance");

	Params::KuroAnimInstance_BindEnumToRoleAnimInstance Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroAnim.KuroAnimInstance.BindVarToCharacter
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          VelocityRef                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ActorForwardVectorRef                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ActorRotationRef                                       (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         ControlRotationRef                                     (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          CurrentAccelerationRef                                 (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMoveBlockRef                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroAnimInstance::BindVarToCharacter(struct FVector& VelocityRef, struct FVector& ActorForwardVectorRef, struct FRotator& ActorRotationRef, struct FRotator& ControlRotationRef, struct FVector& CurrentAccelerationRef, bool& bMoveBlockRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "BindVarToCharacter");

	Params::KuroAnimInstance_BindVarToCharacter Parms{};

	Parms.VelocityRef = std::move(VelocityRef);
	Parms.ActorForwardVectorRef = std::move(ActorForwardVectorRef);
	Parms.ActorRotationRef = std::move(ActorRotationRef);
	Parms.ControlRotationRef = std::move(ControlRotationRef);
	Parms.CurrentAccelerationRef = std::move(CurrentAccelerationRef);
	Parms.bMoveBlockRef = bMoveBlockRef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	VelocityRef = std::move(Parms.VelocityRef);
	ActorForwardVectorRef = std::move(Parms.ActorForwardVectorRef);
	ActorRotationRef = std::move(Parms.ActorRotationRef);
	ControlRotationRef = std::move(Parms.ControlRotationRef);
	CurrentAccelerationRef = std::move(Parms.CurrentAccelerationRef);
	bMoveBlockRef = Parms.bMoveBlockRef;
}


// Function KuroAnim.KuroAnimInstance.CalculateAimMixed
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Speed                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         RoleRotator                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKuroAnimInstance::CalculateAimMixed(const struct FVector& Speed, const struct FRotator& RoleRotator, class ACharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "CalculateAimMixed");

	Params::KuroAnimInstance_CalculateAimMixed Parms{};

	Parms.Speed = std::move(Speed);
	Parms.RoleRotator = std::move(RoleRotator);
	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroAnim.KuroAnimInstance.CalculateRelativeAcceleration
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Speed                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Acceleration                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         RoleRotator                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKuroAnimInstance::CalculateRelativeAcceleration(const struct FVector& Speed, const struct FVector& Acceleration, const struct FRotator& RoleRotator, class ACharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "CalculateRelativeAcceleration");

	Params::KuroAnimInstance_CalculateRelativeAcceleration Parms{};

	Parms.Speed = std::move(Speed);
	Parms.Acceleration = std::move(Acceleration);
	Parms.RoleRotator = std::move(RoleRotator);
	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroAnim.KuroAnimInstance.CalculateSpeedMixed
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                         RoleRotator                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         AdditiveRotator                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Speed                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      Curve                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CachedPercentFB                                        (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CachedPercentLR                                        (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVeloctiyBlend                   VelocityBlend                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UKuroAnimInstance::CalculateSpeedMixed(const struct FRotator& RoleRotator, const struct FRotator& AdditiveRotator, const struct FVector& Speed, class ACharacter* Character, class UCurveFloat*& Curve, const float& DeltaTime, float& CachedPercentFB, float& CachedPercentLR, struct FVeloctiyBlend& VelocityBlend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "CalculateSpeedMixed");

	Params::KuroAnimInstance_CalculateSpeedMixed Parms{};

	Parms.RoleRotator = std::move(RoleRotator);
	Parms.AdditiveRotator = std::move(AdditiveRotator);
	Parms.Speed = std::move(Speed);
	Parms.Character = Character;
	Parms.Curve = Curve;
	Parms.DeltaTime = DeltaTime;
	Parms.CachedPercentFB = CachedPercentFB;
	Parms.CachedPercentLR = CachedPercentLR;
	Parms.VelocityBlend = std::move(VelocityBlend);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Curve = Parms.Curve;
	CachedPercentFB = Parms.CachedPercentFB;
	CachedPercentLR = Parms.CachedPercentLR;
	VelocityBlend = std::move(Parms.VelocityBlend);
}


// Function KuroAnim.KuroAnimInstance.CalculateStandRate
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UCurveFloat*                      AngleToStepFrequency                                   (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Slop                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimWalkSpeed                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimRunSpeed                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SprintSpeed                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StepLengthMix                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroAnimInstance::CalculateStandRate(class UCurveFloat*& AngleToStepFrequency, const float& Slop, const float& Speed, const float& AnimWalkSpeed, const float& AnimRunSpeed, const float& SprintSpeed, const float& StepLengthMix)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "CalculateStandRate");

	Params::KuroAnimInstance_CalculateStandRate Parms{};

	Parms.AngleToStepFrequency = AngleToStepFrequency;
	Parms.Slop = Slop;
	Parms.Speed = Speed;
	Parms.AnimWalkSpeed = AnimWalkSpeed;
	Parms.AnimRunSpeed = AnimRunSpeed;
	Parms.SprintSpeed = SprintSpeed;
	Parms.StepLengthMix = StepLengthMix;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	AngleToStepFrequency = Parms.AngleToStepFrequency;

	return Parms.ReturnValue;
}


// Function KuroAnim.KuroAnimInstance.CalculateStepLengthMixed
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UCurveFloat*                      AngleToStepLength                                      (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      WalkCurve                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      RunCurve                                               (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Slop                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroAnimInstance::CalculateStepLengthMixed(class UCurveFloat*& AngleToStepLength, class UCurveFloat*& WalkCurve, class UCurveFloat*& RunCurve, const float& Speed, const float& Slop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "CalculateStepLengthMixed");

	Params::KuroAnimInstance_CalculateStepLengthMixed Parms{};

	Parms.AngleToStepLength = AngleToStepLength;
	Parms.WalkCurve = WalkCurve;
	Parms.RunCurve = RunCurve;
	Parms.Speed = Speed;
	Parms.Slop = Slop;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	AngleToStepLength = Parms.AngleToStepLength;
	WalkCurve = Parms.WalkCurve;
	RunCurve = Parms.RunCurve;

	return Parms.ReturnValue;
}


// Function KuroAnim.KuroAnimInstance.CalculateWalkRunMixed
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   MoveState                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroAnimInstance::CalculateWalkRunMixed(const int32& MoveState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "CalculateWalkRunMixed");

	Params::KuroAnimInstance_CalculateWalkRunMixed Parms{};

	Parms.MoveState = MoveState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroAnim.KuroAnimInstance.CalucateClimbOffset
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class ACharacter*                       Character                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          IKDirection                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OffsetRelativeLocation                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          BoneLocation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OffsetCorrection                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TraceRadius                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          MeshWorldLocation                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         QuatInverse                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          CachedLocation                                         (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          CachedNormal                                           (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   IKCurveValue                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ClimbRadius                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PrevFrameAlpha                                         (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutOffset                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutNormal                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSuccess                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroAnimInstance::CalucateClimbOffset(class ACharacter*& Character, const struct FVector& IKDirection, const struct FVector& OffsetRelativeLocation, const struct FVector& BoneLocation, float OffsetCorrection, float TraceRadius, const struct FVector& MeshWorldLocation, const struct FRotator& QuatInverse, struct FVector& CachedLocation, struct FVector& CachedNormal, const float& IKCurveValue, const float& ClimbRadius, float& PrevFrameAlpha, struct FVector* OutOffset, struct FVector* OutNormal, bool* bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "CalucateClimbOffset");

	Params::KuroAnimInstance_CalucateClimbOffset Parms{};

	Parms.Character = Character;
	Parms.IKDirection = std::move(IKDirection);
	Parms.OffsetRelativeLocation = std::move(OffsetRelativeLocation);
	Parms.BoneLocation = std::move(BoneLocation);
	Parms.OffsetCorrection = OffsetCorrection;
	Parms.TraceRadius = TraceRadius;
	Parms.MeshWorldLocation = std::move(MeshWorldLocation);
	Parms.QuatInverse = std::move(QuatInverse);
	Parms.CachedLocation = std::move(CachedLocation);
	Parms.CachedNormal = std::move(CachedNormal);
	Parms.IKCurveValue = IKCurveValue;
	Parms.ClimbRadius = ClimbRadius;
	Parms.PrevFrameAlpha = PrevFrameAlpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Character = Parms.Character;
	CachedLocation = std::move(Parms.CachedLocation);
	CachedNormal = std::move(Parms.CachedNormal);
	PrevFrameAlpha = Parms.PrevFrameAlpha;

	if (OutOffset != nullptr)
		*OutOffset = std::move(Parms.OutOffset);

	if (OutNormal != nullptr)
		*OutNormal = std::move(Parms.OutNormal);

	if (bSuccess != nullptr)
		*bSuccess = Parms.bSuccess;
}


// Function KuroAnim.KuroAnimInstance.ClimbIKProcess
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          MeshWorldLocation                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         QuatInverse                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    IsClimbExitState                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OverallOffsetLocation                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ClimbIK                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacter*                       Character                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           Mesh                                                   (Parm, OutParm, ZeroConstructor, InstancedReference, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ClimbRadius                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LFootOffsetRelativeLocation                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LFootCachedLocation                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LFootCachedNormal                                      (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LFootOffsetLocation                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LFootNormalDirection                                   (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LFootPrevFrameAlpha                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RFootOffsetRelativeLocation                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RFootCachedLocation                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RFootCachedNormal                                      (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RFootOffsetLocation                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RFootNormalDirection                                   (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RFootPrevFrameAlpha                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LHandOffsetRelativeLocation                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LHandCachedLocation                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LHandCachedNormal                                      (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LHandOffsetLocation                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LHandNormalDirection                                   (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LHandPrevFrameAlpha                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RHandOffsetRelativeLocation                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RHandCachedLocation                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RHandCachedNormal                                      (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RHandOffsetLocation                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RHandNormalDirection                                   (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RHandPrevFrameAlpha                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroAnimInstance::ClimbIKProcess(class UAnimInstance* AnimInstance, const struct FVector& MeshWorldLocation, const struct FRotator& QuatInverse, const bool& IsClimbExitState, struct FVector& OverallOffsetLocation, float& ClimbIK, class ACharacter*& Character, class USkeletalMeshComponent*& Mesh, const float& ClimbRadius, const struct FVector& LFootOffsetRelativeLocation, struct FVector& LFootCachedLocation, struct FVector& LFootCachedNormal, struct FVector& LFootOffsetLocation, struct FVector& LFootNormalDirection, float& LFootPrevFrameAlpha, const struct FVector& RFootOffsetRelativeLocation, struct FVector& RFootCachedLocation, struct FVector& RFootCachedNormal, struct FVector& RFootOffsetLocation, struct FVector& RFootNormalDirection, float& RFootPrevFrameAlpha, const struct FVector& LHandOffsetRelativeLocation, struct FVector& LHandCachedLocation, struct FVector& LHandCachedNormal, struct FVector& LHandOffsetLocation, struct FVector& LHandNormalDirection, float& LHandPrevFrameAlpha, const struct FVector& RHandOffsetRelativeLocation, struct FVector& RHandCachedLocation, struct FVector& RHandCachedNormal, struct FVector& RHandOffsetLocation, struct FVector& RHandNormalDirection, float& RHandPrevFrameAlpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "ClimbIKProcess");

	Params::KuroAnimInstance_ClimbIKProcess Parms{};

	Parms.AnimInstance = AnimInstance;
	Parms.MeshWorldLocation = std::move(MeshWorldLocation);
	Parms.QuatInverse = std::move(QuatInverse);
	Parms.IsClimbExitState = IsClimbExitState;
	Parms.OverallOffsetLocation = std::move(OverallOffsetLocation);
	Parms.ClimbIK = ClimbIK;
	Parms.Character = Character;
	Parms.Mesh = Mesh;
	Parms.ClimbRadius = ClimbRadius;
	Parms.LFootOffsetRelativeLocation = std::move(LFootOffsetRelativeLocation);
	Parms.LFootCachedLocation = std::move(LFootCachedLocation);
	Parms.LFootCachedNormal = std::move(LFootCachedNormal);
	Parms.LFootOffsetLocation = std::move(LFootOffsetLocation);
	Parms.LFootNormalDirection = std::move(LFootNormalDirection);
	Parms.LFootPrevFrameAlpha = LFootPrevFrameAlpha;
	Parms.RFootOffsetRelativeLocation = std::move(RFootOffsetRelativeLocation);
	Parms.RFootCachedLocation = std::move(RFootCachedLocation);
	Parms.RFootCachedNormal = std::move(RFootCachedNormal);
	Parms.RFootOffsetLocation = std::move(RFootOffsetLocation);
	Parms.RFootNormalDirection = std::move(RFootNormalDirection);
	Parms.RFootPrevFrameAlpha = RFootPrevFrameAlpha;
	Parms.LHandOffsetRelativeLocation = std::move(LHandOffsetRelativeLocation);
	Parms.LHandCachedLocation = std::move(LHandCachedLocation);
	Parms.LHandCachedNormal = std::move(LHandCachedNormal);
	Parms.LHandOffsetLocation = std::move(LHandOffsetLocation);
	Parms.LHandNormalDirection = std::move(LHandNormalDirection);
	Parms.LHandPrevFrameAlpha = LHandPrevFrameAlpha;
	Parms.RHandOffsetRelativeLocation = std::move(RHandOffsetRelativeLocation);
	Parms.RHandCachedLocation = std::move(RHandCachedLocation);
	Parms.RHandCachedNormal = std::move(RHandCachedNormal);
	Parms.RHandOffsetLocation = std::move(RHandOffsetLocation);
	Parms.RHandNormalDirection = std::move(RHandNormalDirection);
	Parms.RHandPrevFrameAlpha = RHandPrevFrameAlpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	OverallOffsetLocation = std::move(Parms.OverallOffsetLocation);
	ClimbIK = Parms.ClimbIK;
	Character = Parms.Character;
	Mesh = Parms.Mesh;
	LFootCachedLocation = std::move(Parms.LFootCachedLocation);
	LFootCachedNormal = std::move(Parms.LFootCachedNormal);
	LFootOffsetLocation = std::move(Parms.LFootOffsetLocation);
	LFootNormalDirection = std::move(Parms.LFootNormalDirection);
	LFootPrevFrameAlpha = Parms.LFootPrevFrameAlpha;
	RFootCachedLocation = std::move(Parms.RFootCachedLocation);
	RFootCachedNormal = std::move(Parms.RFootCachedNormal);
	RFootOffsetLocation = std::move(Parms.RFootOffsetLocation);
	RFootNormalDirection = std::move(Parms.RFootNormalDirection);
	RFootPrevFrameAlpha = Parms.RFootPrevFrameAlpha;
	LHandCachedLocation = std::move(Parms.LHandCachedLocation);
	LHandCachedNormal = std::move(Parms.LHandCachedNormal);
	LHandOffsetLocation = std::move(Parms.LHandOffsetLocation);
	LHandNormalDirection = std::move(Parms.LHandNormalDirection);
	LHandPrevFrameAlpha = Parms.LHandPrevFrameAlpha;
	RHandCachedLocation = std::move(Parms.RHandCachedLocation);
	RHandCachedNormal = std::move(Parms.RHandCachedNormal);
	RHandOffsetLocation = std::move(Parms.RHandOffsetLocation);
	RHandNormalDirection = std::move(Parms.RHandNormalDirection);
	RHandPrevFrameAlpha = Parms.RHandPrevFrameAlpha;
}


// Function KuroAnim.KuroAnimInstance.GetDebugAnimNodeString
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroAnimInstance::GetDebugAnimNodeString()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "GetDebugAnimNodeString");

	Params::KuroAnimInstance_GetDebugAnimNodeString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroAnim.KuroAnimInstance.GroundIKProcess
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          MeshWorldLocation                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DegMovementSlop                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacter*                       Character                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           Mesh                                                   (Parm, OutParm, ZeroConstructor, InstancedReference, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpHill                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDownHill                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    HasMoveInput                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLFootNeedIK                                           (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LFootOffsetLocation                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LFootNormalDirection                                   (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       LFootHitResult                                         (Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bRFootNeedIK                                           (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RFootOffsetLocation                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RFootNormalDirection                                   (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       RFootHitResult                                         (Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    UseCurveFootLocation                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroAnimInstance::GroundIKProcess(const struct FVector& MeshWorldLocation, const float& DegMovementSlop, class ACharacter*& Character, class USkeletalMeshComponent*& Mesh, const bool& bUpHill, const bool& bDownHill, const float& Speed, const bool& HasMoveInput, bool& bLFootNeedIK, struct FVector& LFootOffsetLocation, struct FVector& LFootNormalDirection, struct FHitResult& LFootHitResult, bool& bRFootNeedIK, struct FVector& RFootOffsetLocation, struct FVector& RFootNormalDirection, struct FHitResult& RFootHitResult, bool UseCurveFootLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "GroundIKProcess");

	Params::KuroAnimInstance_GroundIKProcess Parms{};

	Parms.MeshWorldLocation = std::move(MeshWorldLocation);
	Parms.DegMovementSlop = DegMovementSlop;
	Parms.Character = Character;
	Parms.Mesh = Mesh;
	Parms.bUpHill = bUpHill;
	Parms.bDownHill = bDownHill;
	Parms.Speed = Speed;
	Parms.HasMoveInput = HasMoveInput;
	Parms.bLFootNeedIK = bLFootNeedIK;
	Parms.LFootOffsetLocation = std::move(LFootOffsetLocation);
	Parms.LFootNormalDirection = std::move(LFootNormalDirection);
	Parms.LFootHitResult = std::move(LFootHitResult);
	Parms.bRFootNeedIK = bRFootNeedIK;
	Parms.RFootOffsetLocation = std::move(RFootOffsetLocation);
	Parms.RFootNormalDirection = std::move(RFootNormalDirection);
	Parms.RFootHitResult = std::move(RFootHitResult);
	Parms.UseCurveFootLocation = UseCurveFootLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Character = Parms.Character;
	Mesh = Parms.Mesh;
	bLFootNeedIK = Parms.bLFootNeedIK;
	LFootOffsetLocation = std::move(Parms.LFootOffsetLocation);
	LFootNormalDirection = std::move(Parms.LFootNormalDirection);
	LFootHitResult = std::move(Parms.LFootHitResult);
	bRFootNeedIK = Parms.bRFootNeedIK;
	RFootOffsetLocation = std::move(Parms.RFootOffsetLocation);
	RFootNormalDirection = std::move(Parms.RFootNormalDirection);
	RFootHitResult = std::move(Parms.RFootHitResult);
}


// Function KuroAnim.KuroAnimInstance.IKInfoLerpProcess
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HipLerpSpeed                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         QuatInverse                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          OverallOffsetLocation                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OverallOffsetLocationBeUsed                            (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LFootOffsetRelativeLocation                            (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LFootNormalRelativeDirection                           (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LFootOffsetLocation                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LFootNormalDirection                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RFootOffsetRelativeLocation                            (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RFootNormalRelativeDirection                           (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RFootOffsetLocation                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RFootNormalDirection                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LHandOffsetRelativeLocation                            (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LHandNormalRelativeDirection                           (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LHandOffsetLocation                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LHandNormalDirection                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RHandOffsetRelativeLocation                            (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RHandNormalRelativeDirection                           (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RHandOffsetLocation                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RHandNormalDirection                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroAnimInstance::IKInfoLerpProcess(const float& DeltaTime, const float& HipLerpSpeed, const struct FRotator& QuatInverse, const struct FVector& OverallOffsetLocation, struct FVector& OverallOffsetLocationBeUsed, struct FVector& LFootOffsetRelativeLocation, struct FVector& LFootNormalRelativeDirection, const struct FVector& LFootOffsetLocation, const struct FVector& LFootNormalDirection, struct FVector& RFootOffsetRelativeLocation, struct FVector& RFootNormalRelativeDirection, const struct FVector& RFootOffsetLocation, const struct FVector& RFootNormalDirection, struct FVector& LHandOffsetRelativeLocation, struct FVector& LHandNormalRelativeDirection, const struct FVector& LHandOffsetLocation, const struct FVector& LHandNormalDirection, struct FVector& RHandOffsetRelativeLocation, struct FVector& RHandNormalRelativeDirection, const struct FVector& RHandOffsetLocation, const struct FVector& RHandNormalDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "IKInfoLerpProcess");

	Params::KuroAnimInstance_IKInfoLerpProcess Parms{};

	Parms.DeltaTime = DeltaTime;
	Parms.HipLerpSpeed = HipLerpSpeed;
	Parms.QuatInverse = std::move(QuatInverse);
	Parms.OverallOffsetLocation = std::move(OverallOffsetLocation);
	Parms.OverallOffsetLocationBeUsed = std::move(OverallOffsetLocationBeUsed);
	Parms.LFootOffsetRelativeLocation = std::move(LFootOffsetRelativeLocation);
	Parms.LFootNormalRelativeDirection = std::move(LFootNormalRelativeDirection);
	Parms.LFootOffsetLocation = std::move(LFootOffsetLocation);
	Parms.LFootNormalDirection = std::move(LFootNormalDirection);
	Parms.RFootOffsetRelativeLocation = std::move(RFootOffsetRelativeLocation);
	Parms.RFootNormalRelativeDirection = std::move(RFootNormalRelativeDirection);
	Parms.RFootOffsetLocation = std::move(RFootOffsetLocation);
	Parms.RFootNormalDirection = std::move(RFootNormalDirection);
	Parms.LHandOffsetRelativeLocation = std::move(LHandOffsetRelativeLocation);
	Parms.LHandNormalRelativeDirection = std::move(LHandNormalRelativeDirection);
	Parms.LHandOffsetLocation = std::move(LHandOffsetLocation);
	Parms.LHandNormalDirection = std::move(LHandNormalDirection);
	Parms.RHandOffsetRelativeLocation = std::move(RHandOffsetRelativeLocation);
	Parms.RHandNormalRelativeDirection = std::move(RHandNormalRelativeDirection);
	Parms.RHandOffsetLocation = std::move(RHandOffsetLocation);
	Parms.RHandNormalDirection = std::move(RHandNormalDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	OverallOffsetLocationBeUsed = std::move(Parms.OverallOffsetLocationBeUsed);
	LFootOffsetRelativeLocation = std::move(Parms.LFootOffsetRelativeLocation);
	LFootNormalRelativeDirection = std::move(Parms.LFootNormalRelativeDirection);
	RFootOffsetRelativeLocation = std::move(Parms.RFootOffsetRelativeLocation);
	RFootNormalRelativeDirection = std::move(Parms.RFootNormalRelativeDirection);
	LHandOffsetRelativeLocation = std::move(Parms.LHandOffsetRelativeLocation);
	LHandNormalRelativeDirection = std::move(Parms.LHandNormalRelativeDirection);
	RHandOffsetRelativeLocation = std::move(Parms.RHandOffsetRelativeLocation);
	RHandNormalRelativeDirection = std::move(Parms.RHandNormalRelativeDirection);
}


// Function KuroAnim.KuroAnimInstance.InterpLeanAmountTo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLeanAmount                      Current                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FLeanAmount                      Target                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InterpSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLeanAmount                      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FLeanAmount UKuroAnimInstance::InterpLeanAmountTo(const struct FLeanAmount& Current, const struct FLeanAmount& Target, float DeltaTime, float InterpSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "InterpLeanAmountTo");

	Params::KuroAnimInstance_InterpLeanAmountTo Parms{};

	Parms.Current = std::move(Current);
	Parms.Target = std::move(Target);
	Parms.DeltaTime = DeltaTime;
	Parms.InterpSpeed = InterpSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroAnim.KuroAnimInstance.IsContainExtraRibbonAnims
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroAnimInstance::IsContainExtraRibbonAnims()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "IsContainExtraRibbonAnims");

	Params::KuroAnimInstance_IsContainExtraRibbonAnims Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroAnim.KuroAnimInstance.OnComponentStart
// (Event, Public, BlueprintEvent)

void UKuroAnimInstance::OnComponentStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "OnComponentStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function KuroAnim.KuroAnimInstance.RegisterActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroAnimInstance::RegisterActor(class ACharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "RegisterActor");

	Params::KuroAnimInstance_RegisterActor Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroAnim.KuroAnimInstance.ResigterExtraRibbenOwnerAnimInstance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroAnimInstance::ResigterExtraRibbenOwnerAnimInstance(class UAnimInstance* AnimInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "ResigterExtraRibbenOwnerAnimInstance");

	Params::KuroAnimInstance_ResigterExtraRibbenOwnerAnimInstance Parms{};

	Parms.AnimInstance = AnimInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroAnim.KuroAnimInstance.SetBoneRotateToLocationInfoRunBegin
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   TurnAngle                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LookUpAngle                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        TurnLimit                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        LookUpLimit                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TurnOffset                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LookUpOffset                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroAnimInstance::SetBoneRotateToLocationInfoRunBegin(float TurnAngle, float LookUpAngle, const struct FVector2D& TurnLimit, const struct FVector2D& LookUpLimit, float TurnOffset, float LookUpOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "SetBoneRotateToLocationInfoRunBegin");

	Params::KuroAnimInstance_SetBoneRotateToLocationInfoRunBegin Parms{};

	Parms.TurnAngle = TurnAngle;
	Parms.LookUpAngle = LookUpAngle;
	Parms.TurnLimit = std::move(TurnLimit);
	Parms.LookUpLimit = std::move(LookUpLimit);
	Parms.TurnOffset = TurnOffset;
	Parms.LookUpOffset = LookUpOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroAnim.KuroAnimInstance.SetBoneRotateToLocationInfoRunEnd
// (Final, Native, Public, BlueprintCallable)

void UKuroAnimInstance::SetBoneRotateToLocationInfoRunEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "SetBoneRotateToLocationInfoRunEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroAnim.KuroAnimInstance.SetBoneRotateToLocationInfoRunTick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TurnAngle                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LookUpAngle                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroAnimInstance::SetBoneRotateToLocationInfoRunTick(float TurnAngle, float LookUpAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "SetBoneRotateToLocationInfoRunTick");

	Params::KuroAnimInstance_SetBoneRotateToLocationInfoRunTick Parms{};

	Parms.TurnAngle = TurnAngle;
	Parms.LookUpAngle = LookUpAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroAnim.KuroAnimInstance.SetBoneRotateToLocationInfoStopBegin
// (Final, Native, Public, BlueprintCallable)

void UKuroAnimInstance::SetBoneRotateToLocationInfoStopBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "SetBoneRotateToLocationInfoStopBegin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroAnim.KuroAnimInstance.SetBoneRotateToLocationInfoStopEnd
// (Final, Native, Public, BlueprintCallable)

void UKuroAnimInstance::SetBoneRotateToLocationInfoStopEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "SetBoneRotateToLocationInfoStopEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroAnim.KuroAnimInstance.SetDebugTraceType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDrawDebugTrace                         GroundTrace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         ClimbTrace                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroAnimInstance::SetDebugTraceType(EDrawDebugTrace GroundTrace, EDrawDebugTrace ClimbTrace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "SetDebugTraceType");

	Params::KuroAnimInstance_SetDebugTraceType Parms{};

	Parms.GroundTrace = GroundTrace;
	Parms.ClimbTrace = ClimbTrace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroAnim.KuroAnimInstance.SetFootOffset
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          SkeletionAbsoluteLocation                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          IKDirection                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BenchMarkDepth                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RotationCorrectedDistance                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacter*                       Character                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           Mesh                                                   (Parm, OutParm, ZeroConstructor, InstancedReference, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    HasMoveInput                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNeedIK                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OffsetLocation                                         (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalDirection                                        (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OutHitResult                                           (Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UKuroAnimInstance::SetFootOffset(const struct FVector& SkeletionAbsoluteLocation, const struct FVector& IKDirection, const float& BenchMarkDepth, const float& RotationCorrectedDistance, class ACharacter*& Character, class USkeletalMeshComponent*& Mesh, const bool& HasMoveInput, bool& bNeedIK, struct FVector& OffsetLocation, struct FVector& NormalDirection, struct FHitResult& OutHitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "SetFootOffset");

	Params::KuroAnimInstance_SetFootOffset Parms{};

	Parms.SkeletionAbsoluteLocation = std::move(SkeletionAbsoluteLocation);
	Parms.IKDirection = std::move(IKDirection);
	Parms.BenchMarkDepth = BenchMarkDepth;
	Parms.RotationCorrectedDistance = RotationCorrectedDistance;
	Parms.Character = Character;
	Parms.Mesh = Mesh;
	Parms.HasMoveInput = HasMoveInput;
	Parms.bNeedIK = bNeedIK;
	Parms.OffsetLocation = std::move(OffsetLocation);
	Parms.NormalDirection = std::move(NormalDirection);
	Parms.OutHitResult = std::move(OutHitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Character = Parms.Character;
	Mesh = Parms.Mesh;
	bNeedIK = Parms.bNeedIK;
	OffsetLocation = std::move(Parms.OffsetLocation);
	NormalDirection = std::move(Parms.NormalDirection);
	OutHitResult = std::move(Parms.OutHitResult);
}


// Function KuroAnim.KuroAnimInstance.StartABP
// (Native, Public, BlueprintCallable)

void UKuroAnimInstance::StartABP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "StartABP");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroAnim.KuroAnimInstance.UnRegisterActorAndResetInstance
// (Final, Native, Public, BlueprintCallable)

void UKuroAnimInstance::UnRegisterActorAndResetInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "UnRegisterActorAndResetInstance");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroAnim.KuroAnimInstance.UpdateABP
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroAnimInstance::UpdateABP(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "UpdateABP");

	Params::KuroAnimInstance_UpdateABP Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroAnim.KuroAnimInstance.UpdateAdditiveBlendInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUsingAdditiveBlend                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUsingWholeBodyBlend                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AdditiveBlendAlpha                                     (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAdditiveBlendAlpha              Plevis                                                 (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FAdditiveBlendAlpha              Spine                                                  (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FAdditiveBlendAlpha              Head                                                   (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FAdditiveBlendAlpha              ArmL                                                   (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FAdditiveBlendAlpha              ArmR                                                   (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FAdditiveBlendAlpha              Leg                                                    (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UKuroAnimInstance::UpdateAdditiveBlendInfo(class UAnimInstance* AnimInstance, const bool& bUsingAdditiveBlend, const bool& bUsingWholeBodyBlend, float& AdditiveBlendAlpha, struct FAdditiveBlendAlpha& Plevis, struct FAdditiveBlendAlpha& Spine, struct FAdditiveBlendAlpha& Head, struct FAdditiveBlendAlpha& ArmL, struct FAdditiveBlendAlpha& ArmR, struct FAdditiveBlendAlpha& Leg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "UpdateAdditiveBlendInfo");

	Params::KuroAnimInstance_UpdateAdditiveBlendInfo Parms{};

	Parms.AnimInstance = AnimInstance;
	Parms.bUsingAdditiveBlend = bUsingAdditiveBlend;
	Parms.bUsingWholeBodyBlend = bUsingWholeBodyBlend;
	Parms.AdditiveBlendAlpha = AdditiveBlendAlpha;
	Parms.Plevis = std::move(Plevis);
	Parms.Spine = std::move(Spine);
	Parms.Head = std::move(Head);
	Parms.ArmL = std::move(ArmL);
	Parms.ArmR = std::move(ArmR);
	Parms.Leg = std::move(Leg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	AdditiveBlendAlpha = Parms.AdditiveBlendAlpha;
	Plevis = std::move(Parms.Plevis);
	Spine = std::move(Parms.Spine);
	Head = std::move(Parms.Head);
	ArmL = std::move(Parms.ArmL);
	ArmR = std::move(Parms.ArmR);
	Leg = std::move(Parms.Leg);
}


// Function KuroAnim.KuroAnimInstance.UpdateBattleIdle
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   BattleIdleTime                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBattleIdle                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroAnimInstance::UpdateBattleIdle(const float& BattleIdleTime, bool& bBattleIdle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "UpdateBattleIdle");

	Params::KuroAnimInstance_UpdateBattleIdle Parms{};

	Parms.BattleIdleTime = BattleIdleTime;
	Parms.bBattleIdle = bBattleIdle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	bBattleIdle = Parms.bBattleIdle;
}


// Function KuroAnim.KuroAnimInstance.UpdateBindRoleInfo
// (Final, Native, Public, BlueprintCallable)

void UKuroAnimInstance::UpdateBindRoleInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "UpdateBindRoleInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroAnim.KuroAnimInstance.UpdateBooleanVar
// (Final, Native, Public, BlueprintCallable)

void UKuroAnimInstance::UpdateBooleanVar()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "UpdateBooleanVar");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroAnim.KuroAnimInstance.UpdateCameraStateMoveInfo
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Speed                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacter*                       Character                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         RoleRotator                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Acceleration                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RotatorMixed                                           (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RelativeAcceleration                                   (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLeanAmount                      LeanAmount                                             (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   GroundLeanAmountLerpSpeed                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         AimRotator                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   AimAngle                                               (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroAnimInstance::UpdateCameraStateMoveInfo(const struct FVector& Speed, class ACharacter*& Character, const struct FRotator& RoleRotator, const struct FVector& Acceleration, float& RotatorMixed, const float& DeltaTime, struct FVector& RelativeAcceleration, struct FLeanAmount& LeanAmount, const float& GroundLeanAmountLerpSpeed, const struct FRotator& AimRotator, float& AimAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "UpdateCameraStateMoveInfo");

	Params::KuroAnimInstance_UpdateCameraStateMoveInfo Parms{};

	Parms.Speed = std::move(Speed);
	Parms.Character = Character;
	Parms.RoleRotator = std::move(RoleRotator);
	Parms.Acceleration = std::move(Acceleration);
	Parms.RotatorMixed = RotatorMixed;
	Parms.DeltaTime = DeltaTime;
	Parms.RelativeAcceleration = std::move(RelativeAcceleration);
	Parms.LeanAmount = std::move(LeanAmount);
	Parms.GroundLeanAmountLerpSpeed = GroundLeanAmountLerpSpeed;
	Parms.AimRotator = std::move(AimRotator);
	Parms.AimAngle = AimAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Character = Parms.Character;
	RotatorMixed = Parms.RotatorMixed;
	RelativeAcceleration = std::move(Parms.RelativeAcceleration);
	LeanAmount = std::move(Parms.LeanAmount);
	AimAngle = Parms.AimAngle;
}


// Function KuroAnim.KuroAnimInstance.UpdateCharacterVar
// (Final, Native, Public, BlueprintCallable)

void UKuroAnimInstance::UpdateCharacterVar()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "UpdateCharacterVar");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroAnim.KuroAnimInstance.UpdateIKinfoInClimbState
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          MeshWorldLocation                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         QuatInverse                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          OverallOffsetLocation                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ClimbIK                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FastClimbDirection                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsFastClimbState                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacter*                       Character                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           Mesh                                                   (Parm, OutParm, ZeroConstructor, InstancedReference, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HipLerpSpeed                                           (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    HasMoveInput                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsClimbExitState                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ClimbRadius                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LFootOffsetRelativeLocation                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LFootCachedLocation                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LFootCachedNormal                                      (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LFootOffsetLocation                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LFootNormalDirection                                   (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LFootPrevFrameAlpha                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RFootOffsetRelativeLocation                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RFootCachedLocation                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RFootCachedNormal                                      (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RFootOffsetLocation                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RFootNormalDirection                                   (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RFootPrevFrameAlpha                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LHandOffsetRelativeLocation                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LHandCachedLocation                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LHandCachedNormal                                      (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LHandOffsetLocation                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LHandNormalDirection                                   (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LHandPrevFrameAlpha                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RHandOffsetRelativeLocation                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RHandCachedLocation                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RHandCachedNormal                                      (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RHandOffsetLocation                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RHandNormalDirection                                   (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RHandPrevFrameAlpha                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroAnimInstance::UpdateIKinfoInClimbState(class UAnimInstance* AnimInstance, const struct FVector& MeshWorldLocation, const struct FRotator& QuatInverse, struct FVector& OverallOffsetLocation, float& ClimbIK, const float& FastClimbDirection, const bool& IsFastClimbState, class ACharacter*& Character, class USkeletalMeshComponent*& Mesh, float& HipLerpSpeed, const float& Speed, const bool& HasMoveInput, const bool& IsClimbExitState, const float& ClimbRadius, const struct FVector& LFootOffsetRelativeLocation, struct FVector& LFootCachedLocation, struct FVector& LFootCachedNormal, struct FVector& LFootOffsetLocation, struct FVector& LFootNormalDirection, float& LFootPrevFrameAlpha, const struct FVector& RFootOffsetRelativeLocation, struct FVector& RFootCachedLocation, struct FVector& RFootCachedNormal, struct FVector& RFootOffsetLocation, struct FVector& RFootNormalDirection, float& RFootPrevFrameAlpha, const struct FVector& LHandOffsetRelativeLocation, struct FVector& LHandCachedLocation, struct FVector& LHandCachedNormal, struct FVector& LHandOffsetLocation, struct FVector& LHandNormalDirection, float& LHandPrevFrameAlpha, const struct FVector& RHandOffsetRelativeLocation, struct FVector& RHandCachedLocation, struct FVector& RHandCachedNormal, struct FVector& RHandOffsetLocation, struct FVector& RHandNormalDirection, float& RHandPrevFrameAlpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "UpdateIKinfoInClimbState");

	Params::KuroAnimInstance_UpdateIKinfoInClimbState Parms{};

	Parms.AnimInstance = AnimInstance;
	Parms.MeshWorldLocation = std::move(MeshWorldLocation);
	Parms.QuatInverse = std::move(QuatInverse);
	Parms.OverallOffsetLocation = std::move(OverallOffsetLocation);
	Parms.ClimbIK = ClimbIK;
	Parms.FastClimbDirection = FastClimbDirection;
	Parms.IsFastClimbState = IsFastClimbState;
	Parms.Character = Character;
	Parms.Mesh = Mesh;
	Parms.HipLerpSpeed = HipLerpSpeed;
	Parms.Speed = Speed;
	Parms.HasMoveInput = HasMoveInput;
	Parms.IsClimbExitState = IsClimbExitState;
	Parms.ClimbRadius = ClimbRadius;
	Parms.LFootOffsetRelativeLocation = std::move(LFootOffsetRelativeLocation);
	Parms.LFootCachedLocation = std::move(LFootCachedLocation);
	Parms.LFootCachedNormal = std::move(LFootCachedNormal);
	Parms.LFootOffsetLocation = std::move(LFootOffsetLocation);
	Parms.LFootNormalDirection = std::move(LFootNormalDirection);
	Parms.LFootPrevFrameAlpha = LFootPrevFrameAlpha;
	Parms.RFootOffsetRelativeLocation = std::move(RFootOffsetRelativeLocation);
	Parms.RFootCachedLocation = std::move(RFootCachedLocation);
	Parms.RFootCachedNormal = std::move(RFootCachedNormal);
	Parms.RFootOffsetLocation = std::move(RFootOffsetLocation);
	Parms.RFootNormalDirection = std::move(RFootNormalDirection);
	Parms.RFootPrevFrameAlpha = RFootPrevFrameAlpha;
	Parms.LHandOffsetRelativeLocation = std::move(LHandOffsetRelativeLocation);
	Parms.LHandCachedLocation = std::move(LHandCachedLocation);
	Parms.LHandCachedNormal = std::move(LHandCachedNormal);
	Parms.LHandOffsetLocation = std::move(LHandOffsetLocation);
	Parms.LHandNormalDirection = std::move(LHandNormalDirection);
	Parms.LHandPrevFrameAlpha = LHandPrevFrameAlpha;
	Parms.RHandOffsetRelativeLocation = std::move(RHandOffsetRelativeLocation);
	Parms.RHandCachedLocation = std::move(RHandCachedLocation);
	Parms.RHandCachedNormal = std::move(RHandCachedNormal);
	Parms.RHandOffsetLocation = std::move(RHandOffsetLocation);
	Parms.RHandNormalDirection = std::move(RHandNormalDirection);
	Parms.RHandPrevFrameAlpha = RHandPrevFrameAlpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	OverallOffsetLocation = std::move(Parms.OverallOffsetLocation);
	ClimbIK = Parms.ClimbIK;
	Character = Parms.Character;
	Mesh = Parms.Mesh;
	HipLerpSpeed = Parms.HipLerpSpeed;
	LFootCachedLocation = std::move(Parms.LFootCachedLocation);
	LFootCachedNormal = std::move(Parms.LFootCachedNormal);
	LFootOffsetLocation = std::move(Parms.LFootOffsetLocation);
	LFootNormalDirection = std::move(Parms.LFootNormalDirection);
	LFootPrevFrameAlpha = Parms.LFootPrevFrameAlpha;
	RFootCachedLocation = std::move(Parms.RFootCachedLocation);
	RFootCachedNormal = std::move(Parms.RFootCachedNormal);
	RFootOffsetLocation = std::move(Parms.RFootOffsetLocation);
	RFootNormalDirection = std::move(Parms.RFootNormalDirection);
	RFootPrevFrameAlpha = Parms.RFootPrevFrameAlpha;
	LHandCachedLocation = std::move(Parms.LHandCachedLocation);
	LHandCachedNormal = std::move(Parms.LHandCachedNormal);
	LHandOffsetLocation = std::move(Parms.LHandOffsetLocation);
	LHandNormalDirection = std::move(Parms.LHandNormalDirection);
	LHandPrevFrameAlpha = Parms.LHandPrevFrameAlpha;
	RHandCachedLocation = std::move(Parms.RHandCachedLocation);
	RHandCachedNormal = std::move(Parms.RHandCachedNormal);
	RHandOffsetLocation = std::move(Parms.RHandOffsetLocation);
	RHandNormalDirection = std::move(Parms.RHandNormalDirection);
	RHandPrevFrameAlpha = Parms.RHandPrevFrameAlpha;
}


// Function KuroAnim.KuroAnimInstance.UpdateIKInfoInGroundState
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// bool                                    HasWallForward                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          MeshWorldLocation                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsMoving                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DegMovementSlop                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpHill                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDownHill                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacter*                       Character                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           Mesh                                                   (Parm, OutParm, ZeroConstructor, InstancedReference, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    HasMoveInput                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RunWalkMix                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OverallOffsetLocation                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HipLerpSpeed                                           (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLFootNeedIK                                           (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LFootOffsetLocation                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LFootNormalDirection                                   (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       LFootHitResult                                         (Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bRFootNeedIK                                           (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RFootOffsetLocation                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RFootNormalDirection                                   (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       RFootHitResult                                         (Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    UseCurveFootLocation                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroAnimInstance::UpdateIKInfoInGroundState(const bool& HasWallForward, const struct FVector& MeshWorldLocation, const bool& IsMoving, const float& DegMovementSlop, bool& bUpHill, bool& bDownHill, class ACharacter*& Character, class USkeletalMeshComponent*& Mesh, const float& Speed, const bool& HasMoveInput, const float& RunWalkMix, struct FVector& OverallOffsetLocation, float& HipLerpSpeed, bool& bLFootNeedIK, struct FVector& LFootOffsetLocation, struct FVector& LFootNormalDirection, struct FHitResult& LFootHitResult, bool& bRFootNeedIK, struct FVector& RFootOffsetLocation, struct FVector& RFootNormalDirection, struct FHitResult& RFootHitResult, bool UseCurveFootLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "UpdateIKInfoInGroundState");

	Params::KuroAnimInstance_UpdateIKInfoInGroundState Parms{};

	Parms.HasWallForward = HasWallForward;
	Parms.MeshWorldLocation = std::move(MeshWorldLocation);
	Parms.IsMoving = IsMoving;
	Parms.DegMovementSlop = DegMovementSlop;
	Parms.bUpHill = bUpHill;
	Parms.bDownHill = bDownHill;
	Parms.Character = Character;
	Parms.Mesh = Mesh;
	Parms.Speed = Speed;
	Parms.HasMoveInput = HasMoveInput;
	Parms.RunWalkMix = RunWalkMix;
	Parms.OverallOffsetLocation = std::move(OverallOffsetLocation);
	Parms.HipLerpSpeed = HipLerpSpeed;
	Parms.bLFootNeedIK = bLFootNeedIK;
	Parms.LFootOffsetLocation = std::move(LFootOffsetLocation);
	Parms.LFootNormalDirection = std::move(LFootNormalDirection);
	Parms.LFootHitResult = std::move(LFootHitResult);
	Parms.bRFootNeedIK = bRFootNeedIK;
	Parms.RFootOffsetLocation = std::move(RFootOffsetLocation);
	Parms.RFootNormalDirection = std::move(RFootNormalDirection);
	Parms.RFootHitResult = std::move(RFootHitResult);
	Parms.UseCurveFootLocation = UseCurveFootLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	bUpHill = Parms.bUpHill;
	bDownHill = Parms.bDownHill;
	Character = Parms.Character;
	Mesh = Parms.Mesh;
	OverallOffsetLocation = std::move(Parms.OverallOffsetLocation);
	HipLerpSpeed = Parms.HipLerpSpeed;
	bLFootNeedIK = Parms.bLFootNeedIK;
	LFootOffsetLocation = std::move(Parms.LFootOffsetLocation);
	LFootNormalDirection = std::move(Parms.LFootNormalDirection);
	LFootHitResult = std::move(Parms.LFootHitResult);
	bRFootNeedIK = Parms.bRFootNeedIK;
	RFootOffsetLocation = std::move(Parms.RFootOffsetLocation);
	RFootNormalDirection = std::move(Parms.RFootNormalDirection);
	RFootHitResult = std::move(Parms.RFootHitResult);
}


// Function KuroAnim.KuroAnimInstance.UpdateIKinfoInOtherState
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class ACharacter*                       Character                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OverallOffsetLocation                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LFootOffsetLocation                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LFootNormalDirection                                   (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RFootOffsetLocation                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RFootNormalDirection                                   (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LHandNormalDirection                                   (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RHandNormalDirection                                   (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HipLerpSpeed                                           (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroAnimInstance::UpdateIKinfoInOtherState(class ACharacter*& Character, struct FVector& OverallOffsetLocation, struct FVector& LFootOffsetLocation, struct FVector& LFootNormalDirection, struct FVector& RFootOffsetLocation, struct FVector& RFootNormalDirection, struct FVector& LHandNormalDirection, struct FVector& RHandNormalDirection, float& HipLerpSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "UpdateIKinfoInOtherState");

	Params::KuroAnimInstance_UpdateIKinfoInOtherState Parms{};

	Parms.Character = Character;
	Parms.OverallOffsetLocation = std::move(OverallOffsetLocation);
	Parms.LFootOffsetLocation = std::move(LFootOffsetLocation);
	Parms.LFootNormalDirection = std::move(LFootNormalDirection);
	Parms.RFootOffsetLocation = std::move(RFootOffsetLocation);
	Parms.RFootNormalDirection = std::move(RFootNormalDirection);
	Parms.LHandNormalDirection = std::move(LHandNormalDirection);
	Parms.RHandNormalDirection = std::move(RHandNormalDirection);
	Parms.HipLerpSpeed = HipLerpSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Character = Parms.Character;
	OverallOffsetLocation = std::move(Parms.OverallOffsetLocation);
	LFootOffsetLocation = std::move(Parms.LFootOffsetLocation);
	LFootNormalDirection = std::move(Parms.LFootNormalDirection);
	RFootOffsetLocation = std::move(Parms.RFootOffsetLocation);
	RFootNormalDirection = std::move(Parms.RFootNormalDirection);
	LHandNormalDirection = std::move(Parms.LHandNormalDirection);
	RHandNormalDirection = std::move(Parms.RHandNormalDirection);
	HipLerpSpeed = Parms.HipLerpSpeed;
}


// Function KuroAnim.KuroAnimInstance.UpdateIKInfoLocalValue
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         MeshQuatInverse                                        (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          MeshWorldLocation                                      (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroAnimInstance::UpdateIKInfoLocalValue(class ACharacter* Character, struct FRotator& MeshQuatInverse, struct FVector& MeshWorldLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "UpdateIKInfoLocalValue");

	Params::KuroAnimInstance_UpdateIKInfoLocalValue Parms{};

	Parms.Character = Character;
	Parms.MeshQuatInverse = std::move(MeshQuatInverse);
	Parms.MeshWorldLocation = std::move(MeshWorldLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	MeshQuatInverse = std::move(Parms.MeshQuatInverse);
	MeshWorldLocation = std::move(Parms.MeshWorldLocation);
}


// Function KuroAnim.KuroAnimInstance.UpdateMoveInfoMixed
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   WalkRunMixed                                           (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Slop                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      AngleToStepFrequency                                   (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      AngleToStepLength                                      (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      WalkCurve                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      RunCurve                                               (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SpeedSize                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StepLengthMixed                                        (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimWalkSpeed                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimRunSpeed                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SprintSpeed                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StandRate                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroAnimInstance::UpdateMoveInfoMixed(float& WalkRunMixed, const float& DeltaTime, const float& Slop, class UCurveFloat*& AngleToStepFrequency, class UCurveFloat*& AngleToStepLength, class UCurveFloat*& WalkCurve, class UCurveFloat*& RunCurve, const float& SpeedSize, float& StepLengthMixed, const float& AnimWalkSpeed, const float& AnimRunSpeed, const float& SprintSpeed, float& StandRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "UpdateMoveInfoMixed");

	Params::KuroAnimInstance_UpdateMoveInfoMixed Parms{};

	Parms.WalkRunMixed = WalkRunMixed;
	Parms.DeltaTime = DeltaTime;
	Parms.Slop = Slop;
	Parms.AngleToStepFrequency = AngleToStepFrequency;
	Parms.AngleToStepLength = AngleToStepLength;
	Parms.WalkCurve = WalkCurve;
	Parms.RunCurve = RunCurve;
	Parms.SpeedSize = SpeedSize;
	Parms.StepLengthMixed = StepLengthMixed;
	Parms.AnimWalkSpeed = AnimWalkSpeed;
	Parms.AnimRunSpeed = AnimRunSpeed;
	Parms.SprintSpeed = SprintSpeed;
	Parms.StandRate = StandRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	WalkRunMixed = Parms.WalkRunMixed;
	AngleToStepFrequency = Parms.AngleToStepFrequency;
	AngleToStepLength = Parms.AngleToStepLength;
	WalkCurve = Parms.WalkCurve;
	RunCurve = Parms.RunCurve;
	StepLengthMixed = Parms.StepLengthMixed;
	StandRate = Parms.StandRate;
}


// Function KuroAnim.KuroAnimInstance.UpdateRoleInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                                    StateGround                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    StateGroundSprint                                      (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    StateGroundWalk                                        (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    StateGroundRun                                         (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    StateRunStop                                           (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    StateSprintStop                                        (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    StateWalkStop                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    RunStop                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    StateClimb                                             (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    StateAir                                               (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    StateAirGlide                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    StateWater                                             (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    StateView                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    StateAim                                               (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    StateFace                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroAnimInstance::UpdateRoleInfo(bool& StateGround, bool& StateGroundSprint, bool& StateGroundWalk, bool& StateGroundRun, bool& StateRunStop, bool& StateSprintStop, bool& StateWalkStop, bool& RunStop, bool& StateClimb, bool& StateAir, bool& StateAirGlide, bool& StateWater, bool& StateView, bool& StateAim, bool& StateFace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "UpdateRoleInfo");

	Params::KuroAnimInstance_UpdateRoleInfo Parms{};

	Parms.StateGround = StateGround;
	Parms.StateGroundSprint = StateGroundSprint;
	Parms.StateGroundWalk = StateGroundWalk;
	Parms.StateGroundRun = StateGroundRun;
	Parms.StateRunStop = StateRunStop;
	Parms.StateSprintStop = StateSprintStop;
	Parms.StateWalkStop = StateWalkStop;
	Parms.RunStop = RunStop;
	Parms.StateClimb = StateClimb;
	Parms.StateAir = StateAir;
	Parms.StateAirGlide = StateAirGlide;
	Parms.StateWater = StateWater;
	Parms.StateView = StateView;
	Parms.StateAim = StateAim;
	Parms.StateFace = StateFace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	StateGround = Parms.StateGround;
	StateGroundSprint = Parms.StateGroundSprint;
	StateGroundWalk = Parms.StateGroundWalk;
	StateGroundRun = Parms.StateGroundRun;
	StateRunStop = Parms.StateRunStop;
	StateSprintStop = Parms.StateSprintStop;
	StateWalkStop = Parms.StateWalkStop;
	RunStop = Parms.RunStop;
	StateClimb = Parms.StateClimb;
	StateAir = Parms.StateAir;
	StateAirGlide = Parms.StateAirGlide;
	StateWater = Parms.StateWater;
	StateView = Parms.StateView;
	StateAim = Parms.StateAim;
	StateFace = Parms.StateFace;
}


// Function KuroAnim.KuroAnimInstance.UpdateSkillMoveInfo
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         RoleRotator                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Speed                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacter*                       Character                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RotatorMixed                                           (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Acceleration                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RelativeAcceleration                                   (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLeanAmount                      LeanAmount                                             (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   GroundLeanAmountLerpSpeed                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         AimRotator                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   AimAngle                                               (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        AimMoveMixed                                           (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RotatorSpeed                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           SkillTarget                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          CachedActorLocation                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroAnimInstance::UpdateSkillMoveInfo(const float& DeltaTime, const struct FRotator& RoleRotator, const struct FVector& Speed, class ACharacter*& Character, float& RotatorMixed, const struct FVector& Acceleration, struct FVector& RelativeAcceleration, struct FLeanAmount& LeanAmount, const float& GroundLeanAmountLerpSpeed, const struct FRotator& AimRotator, float& AimAngle, struct FVector2D& AimMoveMixed, const float& RotatorSpeed, class AActor* SkillTarget, const struct FVector& CachedActorLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroAnimInstance", "UpdateSkillMoveInfo");

	Params::KuroAnimInstance_UpdateSkillMoveInfo Parms{};

	Parms.DeltaTime = DeltaTime;
	Parms.RoleRotator = std::move(RoleRotator);
	Parms.Speed = std::move(Speed);
	Parms.Character = Character;
	Parms.RotatorMixed = RotatorMixed;
	Parms.Acceleration = std::move(Acceleration);
	Parms.RelativeAcceleration = std::move(RelativeAcceleration);
	Parms.LeanAmount = std::move(LeanAmount);
	Parms.GroundLeanAmountLerpSpeed = GroundLeanAmountLerpSpeed;
	Parms.AimRotator = std::move(AimRotator);
	Parms.AimAngle = AimAngle;
	Parms.AimMoveMixed = std::move(AimMoveMixed);
	Parms.RotatorSpeed = RotatorSpeed;
	Parms.SkillTarget = SkillTarget;
	Parms.CachedActorLocation = std::move(CachedActorLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Character = Parms.Character;
	RotatorMixed = Parms.RotatorMixed;
	RelativeAcceleration = std::move(Parms.RelativeAcceleration);
	LeanAmount = std::move(Parms.LeanAmount);
	AimAngle = Parms.AimAngle;
	AimMoveMixed = std::move(Parms.AimMoveMixed);
}


// Function KuroAnim.KuroTrackRecorder.GetMainGuid
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGuid                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGuid UKuroTrackRecorder::GetMainGuid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroTrackRecorder", "GetMainGuid");

	Params::KuroTrackRecorder_GetMainGuid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroAnim.KuroTrackRecorder.GetShadow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UKuroTrackRecorder::GetShadow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroTrackRecorder", "GetShadow");

	Params::KuroTrackRecorder_GetShadow Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroAnim.KuroAnimMathLibrary.LookRotation_ForwardFirst
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Forward                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Up                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKuroAnimMathLibrary::LookRotation_ForwardFirst(const struct FVector& Forward, const struct FVector& Up)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroAnimMathLibrary", "LookRotation_ForwardFirst");

	Params::KuroAnimMathLibrary_LookRotation_ForwardFirst Parms{};

	Parms.Forward = std::move(Forward);
	Parms.Up = std::move(Up);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroAnim.KuroAnimMathLibrary.LookRotation_UpFirst
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Forward                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Up                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKuroAnimMathLibrary::LookRotation_UpFirst(const struct FVector& Forward, const struct FVector& Up)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroAnimMathLibrary", "LookRotation_UpFirst");

	Params::KuroAnimMathLibrary_LookRotation_UpFirst Parms{};

	Parms.Forward = std::move(Forward);
	Parms.Up = std::move(Up);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroAnim.KuroAnimMathLibrary.Quat_FindBetween
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          V1                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          V2                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKuroAnimMathLibrary::Quat_FindBetween(const struct FVector& V1, const struct FVector& V2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroAnimMathLibrary", "Quat_FindBetween");

	Params::KuroAnimMathLibrary_Quat_FindBetween Parms{};

	Parms.V1 = std::move(V1);
	Parms.V2 = std::move(V2);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroAnim.KuroAnimLibrary.EndAnimNotifyStates
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroAnimLibrary::EndAnimNotifyStates(class UAnimInstance* AnimInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroAnimLibrary", "EndAnimNotifyStates");

	Params::KuroAnimLibrary_EndAnimNotifyStates Parms{};

	Parms.AnimInstance = AnimInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroAnim.KuroRecordEffect.OnPlay
// (Event, Public, BlueprintEvent)

void AKuroRecordEffect::OnPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroRecordEffect", "OnPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function KuroAnim.KuroRecordEffect.OnStop
// (Event, Public, BlueprintEvent)

void AKuroRecordEffect::OnStop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroRecordEffect", "OnStop");

	UObject::ProcessEvent(Func, nullptr);
}


// Function KuroAnim.KuroRecordEffect.Play
// (Final, Native, Public, BlueprintCallable)

void AKuroRecordEffect::Play()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroRecordEffect", "Play");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroAnim.KuroRecordEffect.Stop
// (Final, Native, Public, BlueprintCallable)

void AKuroRecordEffect::Stop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroRecordEffect", "Stop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroAnim.KuroRecorderLibrary.CopyLevelSequence
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class ULevelSequence*                   SourceSequence                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevelSequence*                   TargetSequence                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeOffset                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class FName, struct FGuid>         RetargetAttached                                       (Parm, NativeAccessSpecifierPublic)
// TSet<class UClass*>                     IgnoreClasses                                          (Parm, NativeAccessSpecifierPublic)
// struct FTransform                       StartTransform                                         (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FGuid                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGuid UKuroRecorderLibrary::CopyLevelSequence(class ULevelSequence* SourceSequence, class ULevelSequence* TargetSequence, float TimeOffset, const TMap<class FName, struct FGuid>& RetargetAttached, const TSet<class UClass*>& IgnoreClasses, const struct FTransform& StartTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroRecorderLibrary", "CopyLevelSequence");

	Params::KuroRecorderLibrary_CopyLevelSequence Parms{};

	Parms.SourceSequence = SourceSequence;
	Parms.TargetSequence = TargetSequence;
	Parms.TimeOffset = TimeOffset;
	Parms.RetargetAttached = std::move(RetargetAttached);
	Parms.IgnoreClasses = std::move(IgnoreClasses);
	Parms.StartTransform = std::move(StartTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

