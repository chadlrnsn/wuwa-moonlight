#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroUtility

#include "Basic.hpp"

#include "CoreUObject_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "KuroUtility_structs.hpp"


namespace SDK
{

// Class KuroUtility.AsyncLoadState
// 0x0020 (0x0050 - 0x0030)
class UAsyncLoadState final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             ClassLoadedDelegate;                               // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ObjectLoadedDelegate;                              // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void AsyncLoadClass(const class FString& InPath, class UObject* UserData);
	void AsyncLoadObject(const class FString& InPath, class UObject* UserData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncLoadState">();
	}
	static class UAsyncLoadState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncLoadState>();
	}
};
static_assert(alignof(UAsyncLoadState) == 0x000008, "Wrong alignment on UAsyncLoadState");
static_assert(sizeof(UAsyncLoadState) == 0x000050, "Wrong size on UAsyncLoadState");
static_assert(offsetof(UAsyncLoadState, ClassLoadedDelegate) == 0x000030, "Member 'UAsyncLoadState::ClassLoadedDelegate' has a wrong offset!");
static_assert(offsetof(UAsyncLoadState, ObjectLoadedDelegate) == 0x000040, "Member 'UAsyncLoadState::ObjectLoadedDelegate' has a wrong offset!");

// Class KuroUtility.HoldPreloadObject
// 0x0060 (0x0090 - 0x0030)
class UHoldPreloadObject final : public UObject
{
public:
	TArray<class UObject*>                        CommonAssets;                                      // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<int32, struct FPreloadObjectCollection>  EntityAssetMap;                                    // 0x0040(0x0050)(NativeAccessSpecifierPrivate)

public:
	void AddCommonAsset(class UObject* InObject);
	bool AddEntityAsset(const int32 EntityId, class UObject* InObject);
	void Clear();
	void ClearCommonAsset();
	void ClearEntityAssetMap();
	TArray<class UObject*> GetCommonAssetArray();
	bool GetEntityAssetArray(const int32 EntityId, TArray<class UObject*>* OutAssets);
	bool RemoveEntityAssets(const int32 EntityId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HoldPreloadObject">();
	}
	static class UHoldPreloadObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHoldPreloadObject>();
	}
};
static_assert(alignof(UHoldPreloadObject) == 0x000008, "Wrong alignment on UHoldPreloadObject");
static_assert(sizeof(UHoldPreloadObject) == 0x000090, "Wrong size on UHoldPreloadObject");
static_assert(offsetof(UHoldPreloadObject, CommonAssets) == 0x000030, "Member 'UHoldPreloadObject::CommonAssets' has a wrong offset!");
static_assert(offsetof(UHoldPreloadObject, EntityAssetMap) == 0x000040, "Member 'UHoldPreloadObject::EntityAssetMap' has a wrong offset!");

// Class KuroUtility.KuroActor
// 0x0000 (0x02A8 - 0x02A8)
class AKuroActor : public AActor
{
public:
	void ReceiveKuroActorBack();
	void ReceiveKuroActorGet();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroActor">();
	}
	static class AKuroActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroActor>();
	}
};
static_assert(alignof(AKuroActor) == 0x000008, "Wrong alignment on AKuroActor");
static_assert(sizeof(AKuroActor) == 0x0002A8, "Wrong size on AKuroActor");

// Class KuroUtility.KuroActorComponent
// 0x0000 (0x00C0 - 0x00C0)
class UKuroActorComponent final : public UActorComponent
{
public:
	void EditorTickComponent(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroActorComponent">();
	}
	static class UKuroActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroActorComponent>();
	}
};
static_assert(alignof(UKuroActorComponent) == 0x000008, "Wrong alignment on UKuroActorComponent");
static_assert(sizeof(UKuroActorComponent) == 0x0000C0, "Wrong size on UKuroActorComponent");

// Class KuroUtility.KuroActorEventBinder
// 0x0010 (0x0040 - 0x0030)
class UKuroActorEventBinder final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             Callback;                                          // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroActorEventBinder">();
	}
	static class UKuroActorEventBinder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroActorEventBinder>();
	}
};
static_assert(alignof(UKuroActorEventBinder) == 0x000008, "Wrong alignment on UKuroActorEventBinder");
static_assert(sizeof(UKuroActorEventBinder) == 0x000040, "Wrong size on UKuroActorEventBinder");
static_assert(offsetof(UKuroActorEventBinder, Callback) == 0x000030, "Member 'UKuroActorEventBinder::Callback' has a wrong offset!");

// Class KuroUtility.KuroActorManager
// 0x0000 (0x0030 - 0x0030)
class UKuroActorManager final : public UBlueprintFunctionLibrary
{
public:
	static void Clear();
	static bool ClearAcquiredComponents(class AActor* Actor);
	static void DestroyActor(class AActor* Actor);
	static TArray<class FString> GetAllAcquiredComponents(class AActor* Actor);
	static class ULevelSequence* GetDummySequence();
	static int32 GetResourceSizeBytes(class AActor* Actor, bool IsExclusive);
	static void InitActorManager();
	static bool IsActorPoolEnable();
	static bool IsPooledActor(const class AActor* Actor);
	static void RegisterActorSkipProperties(class UClass* Param_Class, const TArray<struct FPropertyPair>& Properties);
	static bool ResetActorToDefault(class AActor* Actor);
	static void ResetClassPropertyCache(class UClass* Param_Class);
	static void ResetDelegates(class AActor* Actor);
	static void ResetUberGraph(class UObject* Obj);
	static void ResetUObjectByCDO(class UObject* Obj);
	static class AActor* SpawnActor(const class UObject* WorldContextObject, const TSubclassOf<class AActor> ActorClass, const struct FTransform& SpawnTransform, ESpawnActorCollisionHandlingMethod CollisionHandlingOverride, class AActor* Owner, class APawn* Instigator, bool bAsPoolActor);
	static void UnregisterComponent(class UActorComponent* Componet);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroActorManager">();
	}
	static class UKuroActorManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroActorManager>();
	}
};
static_assert(alignof(UKuroActorManager) == 0x000008, "Wrong alignment on UKuroActorManager");
static_assert(sizeof(UKuroActorManager) == 0x000030, "Wrong size on UKuroActorManager");

// Class KuroUtility.KuroApplicationLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroApplicationLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool AddApplicationLifetimeDelegate(const TDelegate<void(int32 Type)>& InDelegate);
	static bool AddEditorPreEndPIEDelegate(const TDelegate<void(bool bSimulateInEditor)>& InDelegate);
	static bool Test(int32 Type);
	static bool UnBind();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroApplicationLibrary">();
	}
	static class UKuroApplicationLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroApplicationLibrary>();
	}
};
static_assert(alignof(UKuroApplicationLibrary) == 0x000008, "Wrong alignment on UKuroApplicationLibrary");
static_assert(sizeof(UKuroApplicationLibrary) == 0x000030, "Wrong size on UKuroApplicationLibrary");

// Class KuroUtility.KuroBlockingVolume
// 0x0010 (0x02F0 - 0x02E0)
class AKuroBlockingVolume final : public AVolume
{
public:
	class FName                                   VolumeId;                                          // 0x02E0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A3F[0x4];                                     // 0x02EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroBlockingVolume">();
	}
	static class AKuroBlockingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroBlockingVolume>();
	}
};
static_assert(alignof(AKuroBlockingVolume) == 0x000008, "Wrong alignment on AKuroBlockingVolume");
static_assert(sizeof(AKuroBlockingVolume) == 0x0002F0, "Wrong size on AKuroBlockingVolume");
static_assert(offsetof(AKuroBlockingVolume, VolumeId) == 0x0002E0, "Member 'AKuroBlockingVolume::VolumeId' has a wrong offset!");

// Class KuroUtility.KuroBooleanEventBinder
// 0x0010 (0x0040 - 0x0030)
class UKuroBooleanEventBinder final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             Callback;                                          // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroBooleanEventBinder">();
	}
	static class UKuroBooleanEventBinder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroBooleanEventBinder>();
	}
};
static_assert(alignof(UKuroBooleanEventBinder) == 0x000008, "Wrong alignment on UKuroBooleanEventBinder");
static_assert(sizeof(UKuroBooleanEventBinder) == 0x000040, "Wrong size on UKuroBooleanEventBinder");
static_assert(offsetof(UKuroBooleanEventBinder, Callback) == 0x000030, "Member 'UKuroBooleanEventBinder::Callback' has a wrong offset!");

// Class KuroUtility.KuroBpDataAsset
// 0x0000 (0x0038 - 0x0038)
class UKuroBpDataAsset : public UPrimaryDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroBpDataAsset">();
	}
	static class UKuroBpDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroBpDataAsset>();
	}
};
static_assert(alignof(UKuroBpDataAsset) == 0x000008, "Wrong alignment on UKuroBpDataAsset");
static_assert(sizeof(UKuroBpDataAsset) == 0x000038, "Wrong size on UKuroBpDataAsset");

// Class KuroUtility.KuroBpDataAssetGroup
// 0x0010 (0x0048 - 0x0038)
class UKuroBpDataAssetGroup final : public UDataAsset
{
public:
	TArray<class UKuroBpDataAsset*>               Data;                                              // 0x0038(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroBpDataAssetGroup">();
	}
	static class UKuroBpDataAssetGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroBpDataAssetGroup>();
	}
};
static_assert(alignof(UKuroBpDataAssetGroup) == 0x000008, "Wrong alignment on UKuroBpDataAssetGroup");
static_assert(sizeof(UKuroBpDataAssetGroup) == 0x000048, "Wrong size on UKuroBpDataAssetGroup");
static_assert(offsetof(UKuroBpDataAssetGroup, Data) == 0x000038, "Member 'UKuroBpDataAssetGroup::Data' has a wrong offset!");

// Class KuroUtility.KuroStateMachineBase
// 0x0070 (0x00A8 - 0x0038)
class UKuroStateMachineBase : public UPrimaryDataAsset
{
public:
	class FString                                 Name_KuroStateMachineBase;                         // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class UKuroStateMachineConditionBase*> Transitions;                                       // 0x0048(0x0050)(Edit, BlueprintVisible, ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UKuroStateMachineBase*>          Children;                                          // 0x0098(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroStateMachineBase">();
	}
	static class UKuroStateMachineBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroStateMachineBase>();
	}
};
static_assert(alignof(UKuroStateMachineBase) == 0x000008, "Wrong alignment on UKuroStateMachineBase");
static_assert(sizeof(UKuroStateMachineBase) == 0x0000A8, "Wrong size on UKuroStateMachineBase");
static_assert(offsetof(UKuroStateMachineBase, Name_KuroStateMachineBase) == 0x000038, "Member 'UKuroStateMachineBase::Name_KuroStateMachineBase' has a wrong offset!");
static_assert(offsetof(UKuroStateMachineBase, Transitions) == 0x000048, "Member 'UKuroStateMachineBase::Transitions' has a wrong offset!");
static_assert(offsetof(UKuroStateMachineBase, Children) == 0x000098, "Member 'UKuroStateMachineBase::Children' has a wrong offset!");

// Class KuroUtility.KuroStateMachineGroup
// 0x0010 (0x0048 - 0x0038)
class UKuroStateMachineGroup final : public UDataAsset
{
public:
	TArray<class UKuroStateMachineBase*>          StateMachineList;                                  // 0x0038(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroStateMachineGroup">();
	}
	static class UKuroStateMachineGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroStateMachineGroup>();
	}
};
static_assert(alignof(UKuroStateMachineGroup) == 0x000008, "Wrong alignment on UKuroStateMachineGroup");
static_assert(sizeof(UKuroStateMachineGroup) == 0x000048, "Wrong size on UKuroStateMachineGroup");
static_assert(offsetof(UKuroStateMachineGroup, StateMachineList) == 0x000038, "Member 'UKuroStateMachineGroup::StateMachineList' has a wrong offset!");

// Class KuroUtility.KuroStateMachineConditionBase
// 0x0000 (0x0038 - 0x0038)
class UKuroStateMachineConditionBase : public UPrimaryDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroStateMachineConditionBase">();
	}
	static class UKuroStateMachineConditionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroStateMachineConditionBase>();
	}
};
static_assert(alignof(UKuroStateMachineConditionBase) == 0x000008, "Wrong alignment on UKuroStateMachineConditionBase");
static_assert(sizeof(UKuroStateMachineConditionBase) == 0x000038, "Wrong size on UKuroStateMachineConditionBase");

// Class KuroUtility.KuroStateMachineConditionAnd
// 0x0010 (0x0048 - 0x0038)
class UKuroStateMachineConditionAnd final : public UKuroStateMachineConditionBase
{
public:
	TArray<class UKuroStateMachineConditionBase*> Conditions;                                        // 0x0038(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroStateMachineConditionAnd">();
	}
	static class UKuroStateMachineConditionAnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroStateMachineConditionAnd>();
	}
};
static_assert(alignof(UKuroStateMachineConditionAnd) == 0x000008, "Wrong alignment on UKuroStateMachineConditionAnd");
static_assert(sizeof(UKuroStateMachineConditionAnd) == 0x000048, "Wrong size on UKuroStateMachineConditionAnd");
static_assert(offsetof(UKuroStateMachineConditionAnd, Conditions) == 0x000038, "Member 'UKuroStateMachineConditionAnd::Conditions' has a wrong offset!");

// Class KuroUtility.KuroStateMachineConditionOr
// 0x0010 (0x0048 - 0x0038)
class UKuroStateMachineConditionOr final : public UKuroStateMachineConditionBase
{
public:
	TArray<class UKuroStateMachineConditionBase*> Conditions;                                        // 0x0038(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroStateMachineConditionOr">();
	}
	static class UKuroStateMachineConditionOr* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroStateMachineConditionOr>();
	}
};
static_assert(alignof(UKuroStateMachineConditionOr) == 0x000008, "Wrong alignment on UKuroStateMachineConditionOr");
static_assert(sizeof(UKuroStateMachineConditionOr) == 0x000048, "Wrong size on UKuroStateMachineConditionOr");
static_assert(offsetof(UKuroStateMachineConditionOr, Conditions) == 0x000038, "Member 'UKuroStateMachineConditionOr::Conditions' has a wrong offset!");

// Class KuroUtility.KuroCollectActorComponent
// 0x0008 (0x00C8 - 0x00C0)
class UKuroCollectActorComponent final : public UActorComponent
{
public:
	ECollectActorType                             CollectActorType;                                  // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A40[0x7];                                     // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class AActor* GetActorWithTag(class FName Tag, ECollectActorType Type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroCollectActorComponent">();
	}
	static class UKuroCollectActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroCollectActorComponent>();
	}
};
static_assert(alignof(UKuroCollectActorComponent) == 0x000008, "Wrong alignment on UKuroCollectActorComponent");
static_assert(sizeof(UKuroCollectActorComponent) == 0x0000C8, "Wrong size on UKuroCollectActorComponent");
static_assert(offsetof(UKuroCollectActorComponent, CollectActorType) == 0x0000C0, "Member 'UKuroCollectActorComponent::CollectActorType' has a wrong offset!");

// Class KuroUtility.KuroCompressLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroCompressLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void CompressFileOrFolder(const class FString& Path, const class FString& DestPath, const TDelegate<void(float Rate)>& OnProgress, const TDelegate<void(TArray<class FString>& SuccessedPaths)>& OnCompressComplete, const TDelegate<void()>& OnFail, int64 MaxSingleFileReadSize);
	static void CompressFilesOrFoldersAsync(const TArray<class FString>& Paths, const class FString& DestPath, const TDelegate<void(float Rate)>& OnProgress, const TDelegate<void(TArray<class FString>& SuccessedPaths)>& OnCompressComplete, const TDelegate<void()>& OnFail, bool bAutoIncludeFilesUnderFolder, int64 MaxSingleFileReadSize);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroCompressLibrary">();
	}
	static class UKuroCompressLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroCompressLibrary>();
	}
};
static_assert(alignof(UKuroCompressLibrary) == 0x000008, "Wrong alignment on UKuroCompressLibrary");
static_assert(sizeof(UKuroCompressLibrary) == 0x000030, "Wrong size on UKuroCompressLibrary");

// Class KuroUtility.KuroEntityActor
// 0x0008 (0x02B0 - 0x02A8)
class AKuroEntityActor final : public AKuroActor
{
public:
	int32                                         EntityId;                                          // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A43[0x4];                                     // 0x02AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroEntityActor">();
	}
	static class AKuroEntityActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroEntityActor>();
	}
};
static_assert(alignof(AKuroEntityActor) == 0x000008, "Wrong alignment on AKuroEntityActor");
static_assert(sizeof(AKuroEntityActor) == 0x0002B0, "Wrong size on AKuroEntityActor");
static_assert(offsetof(AKuroEntityActor, EntityId) == 0x0002A8, "Member 'AKuroEntityActor::EntityId' has a wrong offset!");

// Class KuroUtility.KuroIntEventBinder
// 0x0010 (0x0040 - 0x0030)
class UKuroIntEventBinder final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             Callback;                                          // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroIntEventBinder">();
	}
	static class UKuroIntEventBinder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroIntEventBinder>();
	}
};
static_assert(alignof(UKuroIntEventBinder) == 0x000008, "Wrong alignment on UKuroIntEventBinder");
static_assert(sizeof(UKuroIntEventBinder) == 0x000040, "Wrong size on UKuroIntEventBinder");
static_assert(offsetof(UKuroIntEventBinder, Callback) == 0x000030, "Member 'UKuroIntEventBinder::Callback' has a wrong offset!");

// Class KuroUtility.KuroJsStatsLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroJsStatsLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroJsStatsLibrary">();
	}
	static class UKuroJsStatsLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroJsStatsLibrary>();
	}
};
static_assert(alignof(UKuroJsStatsLibrary) == 0x000008, "Wrong alignment on UKuroJsStatsLibrary");
static_assert(sizeof(UKuroJsStatsLibrary) == 0x000030, "Wrong size on UKuroJsStatsLibrary");

// Class KuroUtility.KuroMathLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroMathLibrary final : public UBlueprintFunctionLibrary
{
public:
	static int64 BitwiseLeftShift(int64 Source, int32 Bit);
	static int64 BitwiseRightShift(int64 Source, int32 Bit);
	static int32 IntBitwiseAnd(int32 Num1, int32 Num2);
	static int32 IntBitwiseNot(int32 Num);
	static int32 IntBitwiseOr(int32 Num1, int32 Num2);
	static int32 IntBitwiseXOr(int32 Num1, int32 Num2);
	static int64 KuroStringToInt64(const class FString& StringNum);
	static int64 LongBitwiseAnd(int64 Num1, int64 Num2);
	static int64 LongBitwiseNot(int64 Num);
	static int64 LongBitwiseOr(int64 Num1, int64 Num2);
	static int64 LongBitwiseXOr(int64 Num1, int64 Num2);
	static struct FVector2D Max(const struct FVector2D& A, const struct FVector2D& B);
	static struct FVector2D Min(const struct FVector2D& A, const struct FVector2D& B);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroMathLibrary">();
	}
	static class UKuroMathLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroMathLibrary>();
	}
};
static_assert(alignof(UKuroMathLibrary) == 0x000008, "Wrong alignment on UKuroMathLibrary");
static_assert(sizeof(UKuroMathLibrary) == 0x000030, "Wrong size on UKuroMathLibrary");

// Class KuroUtility.KuroMemoryLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroMemoryLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void PrintUObjectMemoryInfo(class UObject* Object);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroMemoryLibrary">();
	}
	static class UKuroMemoryLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroMemoryLibrary>();
	}
};
static_assert(alignof(UKuroMemoryLibrary) == 0x000008, "Wrong alignment on UKuroMemoryLibrary");
static_assert(sizeof(UKuroMemoryLibrary) == 0x000030, "Wrong size on UKuroMemoryLibrary");

// Class KuroUtility.KuroMeshTextureFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroMeshTextureFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool AddMeshesBundleStreamedAllMipsDelegate(const TDelegate<void(TArray<class USkeletalMesh*>& SkeletalMeshes, TArray<class UStaticMesh*>& StaticMeshes)>& InDelegate);
	static bool AddSkeletalStreamedAllMipsDelegate(const TDelegate<void(class USkeletalMesh* SkeletalMesh)>& InDelegate);
	static bool AddStaticMeshStreamedAllMipsDelegate(const TDelegate<void(class UStaticMesh* StaticMesh)>& InDelegate);
	static int32 ForceMeshesBundleStreamingInAllMips(const TArray<class USkeletalMesh*>& MeshBundleSkeletalMeshes, const TArray<class UStaticMesh*>& MeshBundleStaticMeshes, const TDelegate<void(TArray<class USkeletalMesh*>& SkeletalMeshes, TArray<class UStaticMesh*>& StaticMeshes)>& InDelegate);
	static void HandleMeshesComponentsBundleStreaming(const TArray<class USkeletalMesh*>& MeshBundleSkeletalMeshes, const TArray<class UStaticMesh*>& MeshBundleStaticMeshes, const bool bStartForceStreamIn);
	static void HandleSkeletalMeshComponentStreaming(class USkeletalMesh* SkeletalMesh, const bool bStartForceStreamIn);
	static void HandleStaticMeshComponentStreaming(class UStaticMesh* StaticMesh, const bool bStartForceStreamIn);
	static bool IsSkeletalMeshComponentStreamingComplete(class USkeletalMesh* SkeletalMesh);
	static bool IsStaticMeshComponentStreamingComplete(class UStaticMesh* StaticMesh);
	static bool StopMeshesBundleStreamingInAllMips(const int32 UniqueInstanceID);
	static bool UnbindMeshesBundleStreamedAllMipsDelegate();
	static bool UnbindSkeletalStreamedAllMipsDelegate();
	static bool UnbindStaticMeshStreamedAllMipsDelegate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroMeshTextureFunctionLibrary">();
	}
	static class UKuroMeshTextureFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroMeshTextureFunctionLibrary>();
	}
};
static_assert(alignof(UKuroMeshTextureFunctionLibrary) == 0x000008, "Wrong alignment on UKuroMeshTextureFunctionLibrary");
static_assert(sizeof(UKuroMeshTextureFunctionLibrary) == 0x000030, "Wrong size on UKuroMeshTextureFunctionLibrary");

// Class KuroUtility.KuroPerceptionEventBinder
// 0x0010 (0x0040 - 0x0030)
class UKuroPerceptionEventBinder final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             Callback;                                          // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroPerceptionEventBinder">();
	}
	static class UKuroPerceptionEventBinder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroPerceptionEventBinder>();
	}
};
static_assert(alignof(UKuroPerceptionEventBinder) == 0x000008, "Wrong alignment on UKuroPerceptionEventBinder");
static_assert(sizeof(UKuroPerceptionEventBinder) == 0x000040, "Wrong size on UKuroPerceptionEventBinder");
static_assert(offsetof(UKuroPerceptionEventBinder, Callback) == 0x000030, "Member 'UKuroPerceptionEventBinder::Callback' has a wrong offset!");

// Class KuroUtility.KuroPhysicsLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroPhysicsLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool GetHitPoint(const struct FVector& StartLocation, const struct FVector& EndLocation, class AActor* Actor, class UPrimitiveComponent* TraceComp, class UKuroHitResult* HitResult, float DrawDuration, bool ForceTrace);
	static bool GetSphereHitPoint(const struct FVector& StartLocation, const struct FVector& EndLocation, class AActor* Actor, class UPrimitiveComponent* TraceComp, float Radius, class UKuroHitResult* HitResult, float DrawDuration, bool ForceTrace);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroPhysicsLibrary">();
	}
	static class UKuroPhysicsLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroPhysicsLibrary>();
	}
};
static_assert(alignof(UKuroPhysicsLibrary) == 0x000008, "Wrong alignment on UKuroPhysicsLibrary");
static_assert(sizeof(UKuroPhysicsLibrary) == 0x000030, "Wrong size on UKuroPhysicsLibrary");

// Class KuroUtility.KuroPolypartition
// 0x0000 (0x0030 - 0x0030)
class UKuroPolypartition final : public UBlueprintFunctionLibrary
{
public:
	static TArray<int32> BuildTriangleByVertex2D(const TArray<struct FVector2D>& Points);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroPolypartition">();
	}
	static class UKuroPolypartition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroPolypartition>();
	}
};
static_assert(alignof(UKuroPolypartition) == 0x000008, "Wrong alignment on UKuroPolypartition");
static_assert(sizeof(UKuroPolypartition) == 0x000030, "Wrong size on UKuroPolypartition");

// Class KuroUtility.KuroSilenceGameMode
// 0x0008 (0x03A0 - 0x0398)
class AKuroSilenceGameMode final : public AGameMode
{
public:
	uint8                                         Pad_1A53[0x8];                                     // 0x0398(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GameInitialized();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroSilenceGameMode">();
	}
	static class AKuroSilenceGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroSilenceGameMode>();
	}
};
static_assert(alignof(AKuroSilenceGameMode) == 0x000008, "Wrong alignment on AKuroSilenceGameMode");
static_assert(sizeof(AKuroSilenceGameMode) == 0x0003A0, "Wrong size on AKuroSilenceGameMode");

// Class KuroUtility.KuroStaticAndroidLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroStaticAndroidLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddAndroidScreenChangeDelegate(const TDelegate<void()>& Handler);
	static void ClearAndroidScreenChangeDelegate();
	static bool GetDeviceIsEmulator();
	static bool GetDeviceIsRooted();
	static void OpenAppWithUrl(const class FString& Schema, const class FString& FailSchema);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroStaticAndroidLibrary">();
	}
	static class UKuroStaticAndroidLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroStaticAndroidLibrary>();
	}
};
static_assert(alignof(UKuroStaticAndroidLibrary) == 0x000008, "Wrong alignment on UKuroStaticAndroidLibrary");
static_assert(sizeof(UKuroStaticAndroidLibrary) == 0x000030, "Wrong size on UKuroStaticAndroidLibrary");

// Class KuroUtility.KuroStaticiOSLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroStaticiOSLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool GetDeviceJailbroken();
	static void OpenAppWithUrl(const class FString& Url, const class FString& FailUrl);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroStaticiOSLibrary">();
	}
	static class UKuroStaticiOSLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroStaticiOSLibrary>();
	}
};
static_assert(alignof(UKuroStaticiOSLibrary) == 0x000008, "Wrong alignment on UKuroStaticiOSLibrary");
static_assert(sizeof(UKuroStaticiOSLibrary) == 0x000030, "Wrong size on UKuroStaticiOSLibrary");

// Class KuroUtility.KuroStaticLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroStaticLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddToRoot(class UObject* InObject);
	static void ApplyChangeToBlueprint(class AActor* Actor);
	static class FString Base64Decode(const class FString& InString);
	static class FString Base64Encode(const class FString& InString);
	static void BindCustomGetTimeBetweenGarbageCollectionPassesDelegate(const TDelegate<void(float MBFree, float ExtraDevelopmentMemorySize, int32 NumObjects)>& Delegate);
	static void ClearCustomGetTimeBetweenGarbageCollectionPassesDelegate();
	static void ClearPlayerInputCache(class APlayerController** PC);
	static EObjectTypeQuery ConvertToObjectType(const ECollisionChannel InCollisionChannel);
	static ETraceTypeQuery ConvertToTraceType(const ECollisionChannel InCollisionChannel);
	static bool CopyFile(const class FString& SourcePath, const class FString& DstPath);
	static bool CountCurFrame();
	static void CountCurMemory();
	static bool DeleteFile(const class FString& Path, const bool bRequireExists, const bool bEvenReadOnly, const bool bQuiet);
	static bool DeleteFolder(const class FString& Path, const bool bRequireExists, const bool bTree);
	static void DestroyObject(class UObject* Object);
	static bool DirectoryExists(const class FString& Path);
	static void DoGameViewPortMouseEnter(class UGameViewportClient* InViewport, int32 X, int32 Y);
	static bool EncompassesPoint(class AVolume* Volume, const struct FVector& Point, float SphereRadius);
	static bool ExecProcess(const class FString& URL, const class FString& Params_0, int32* ReturnCode, class FString* OutStd, class FString* OutErr);
	static bool ExecuteFunctionByName(class UObject* Object, const class FString& FunctionName, class FString* Result);
	static void ExitGame(bool Force);
	static bool FileExists(const class FString& Path);
	static void ForceGarbageCollection(bool bFullPurge);
	static struct FDateTime FromUnixTimestamp(const int32 Timestamp);
	static int32 GetActorCount();
	static void GetAnimAssets(const class UAnimBlueprint* InAnimBlueprint, TSet<class UAnimationAsset*>* OutAnimationAssets);
	static void GetAnimAssetsByAnimBlueprintClass(const TSubclassOf<class UAnimInstance>& InAnimClass, TSet<class UAnimationAsset*>* OutAnimationAssets);
	static void GetAnimAssetsByAnimInstance(const class UAnimInstance* InAnimInstance, TSet<class UAnimationAsset*>* OutAnimationAssets);
	static void GetAnimMontageNotifies(const class UAnimMontage* AnimMontage, TArray<struct FAnimNotifyEvent>* OutNotifies);
	static void GetAnimSequenceNotifies(const class UAnimSequenceBase* AnimSequence, TArray<struct FAnimNotifyEvent>* OutNotifies);
	static void GetAnimSequencesByAnimMontage(const class UAnimMontage* AnimMontage, TArray<class UAnimSequenceBase*>* OutAnimSequences);
	static float GetAvailablePhysicalGB();
	static float GetAvailableVirtualGB();
	static int32 GetBatteryLevel();
	static class FString GetBlueprintCallstack();
	static bool GetCameraShakeInfo(TSubclassOf<class UCameraShakeBase> CameraShakeClass, struct FCameraShakeInfo* OutInfo);
	static void GetCharacterAnimClass(const TSubclassOf<class AActor>& InActorClass, TSubclassOf<class UAnimInstance>* OutAnimClass);
	static void GetCreatureGenDirectoryByMap(const class FString& Path, const int32 MapID, bool* Exist, class FString* Directory);
	static class FString GetCultureRegion();
	static float GetCurCPUFrequency();
	static class UObject* GetDefaultObject(class UClass* Param_Class);
	static class FString GetDeviceCPU();
	static TArray<class FString> GetDirectories(const class FString& Path);
	static TArray<class FString> GetFiles(const class FString& Path, const class FString& Extension);
	static TArray<class FString> GetFilesRecursive(const class FString& Path, const class FString& Filter, bool Files, bool Directories);
	static struct FVector GetFirstLocationFromSeqTrack(class UMovieScene3DTransformTrack* TransformTrack);
	static struct FVector GetFrameInfo();
	static class UGameViewportClient* GetGameViewPort();
	static float GetGPUFrameTime();
	static class FString GetGPUInfo();
	static class FString GetLevelPath(const class UObject* WorldContextObject);
	static class AActor* GetLevelPrefabShowActor(class AActor* Actor);
	static class FString GetLLMInfo();
	static void GetLocalHostAddresses(TArray<class FString>* OutAddresses, const bool bAppendPort);
	static class FString GetMacAddress();
	static TArray<struct FVector> GetNavPointData(class UObject* WorldContextObject, int32 XNumber, int32 YNumber, int32 Dis, class ANavigationData* NavData, const struct FVector& Point, const struct FVector& QueryExtent, TSubclassOf<class UNavigationQueryFilter> FilterClass);
	static float GetPeakUsedPhysicalGB();
	static float GetPeakUsedVirtualGB();
	static float GetPIEStartTimeInSeconds();
	static float GetPlatformTimeInSeconds();
	static float GetRawFrameTime();
	static float GetRawGameThreadTime();
	static float GetRawRenderThreadTime();
	static float GetRawRHITTime();
	static TArray<class UMovieSceneTrack*> GetSequenceTracksForObjectBindingID(const class ALevelSequenceActor* Actor, class FName TagName);
	static struct FVector2D GetSlateApplicationCursorPos();
	static void GetSlotNamesByAnimMontage(const class UAnimMontage* AnimMontage, TArray<class FName>* OutSlotNames);
	static struct FRotator GetSplineRotationAtSplinePoint(class USplineComponent* Spline, int32 PointIndex, ESplineCoordinateSpace CoordinateSpace);
	static class FString GetStatUnitInfo();
	static int32 GetTotalMemoryGB();
	static class UMovieSceneTrack* GetTrackByClass(const TArray<class UMovieSceneTrack*>& Tracks, TSubclassOf<class UMovieSceneTrack> Param_Class);
	static float GetUsedMemoryGB();
	static float GetUsedPhysicalGB();
	static float GetUsedVirtualGB();
	static float GetUseMemoryProportion();
	static struct FVector2D GetViewPortMousePosition();
	static class FString HashStringWithSHA1(const class FString& InString);
	static void IcmpPing(const class FString& IpAddress, float Timeout, const TDelegate<void(const class FString& Address, float Time, int32 ResponseState)>& InDelegate);
	static bool IsAsyncLoadingThreadEnabled();
	static bool IsBuildShipping();
	static bool IsBuildTest();
	static bool IsEditor(const class UObject* WorldContextObject);
	static bool IsForegroundWindow();
	static bool IsImplementInterface(class UClass* InClass, class UClass* InInterfaceClass);
	static bool IsModuleLoaded(const class FString& ModelName);
	static bool IsObjectClassByName(class UObject* Object, class FName ClassName);
	static bool IsViewportFocus();
	static bool IsWithEditor();
	static bool IsWorldTearingDown(const class UWorld* World);
	static bool KuroEnableCustomAffinity();
	static class FString KuroFormatText(const class FString& Format, const TArray<class FString>& Parameters);
	static TArray<class FString> LoadFilesRecursive(const class FString& Path, const class FString& Filter, bool Files, bool Directories);
	static bool LoadFileToString(class FString* Result, const class FString& Filename);
	static TArray<class FString> LoadFileToStringArray(const class FString& FileRevisionPath);
	static bool MakeDirectory(const class FString& Path, const bool bTree);
	static class FString Md5HashAnsiString(const class FString& InString);
	static void PerceptionConfigureSense(class UAIPerceptionComponent* AIPerception, class UAISenseConfig* AISenseConfig);
	static void RegisterCustomCommandProcessor(const class FString& Category, const TDelegate<void(const class FString& Command)>& Processor);
	static void RemoveFromRoot(class UObject* InObject);
	static bool SaveStringToFile(const class FString& SaveText, const class FString& FileName, const bool bWithBom);
	static void SetActorModify(class AActor* Actor);
	static void SetActorPermanent(class AActor* Actor, const bool bIsPermanent, const bool bWithAllChildren);
	static void SetBaseAndSaveBaseLocation(class UCharacterMovementComponent* CharacterMovementComp, class UPrimitiveComponent* NewBase);
	static void SetCursorVisibility(bool Visible);
	static void SetEditorWidgetSkipTick(bool bSkipTick);
	static void SetGameThreadAffinity(bool bIsInFighting);
	static void SetHttpThreadActiveMinimumSleepTimeInSeconds(float InHttpThreadActiveMinimumSleepTimeInSeconds);
	static void SetHttpThreadIdleMinimumSleepTimeInSeconds(float InHttpThreadIdleMinimumSleepTimeInSeconds);
	static void SetMontageANIndex(const class UAnimMontage* AnimMontage);
	static void SetSplinePointsWithType(class USplineComponent* Spline, const TArray<struct FVector>& Points, ESplineCoordinateSpace CoordinateSpace, ESplinePointType Type, bool bUpdateSpline);
	static void SetStaticMeshVelocity(const TArray<class AActor*>& Actors, const struct FVector& NewVelocity);
	static void SetThreadAffinity(const class FString& ThreadName, int32 AffinityHigh, int32 AffinityLow);
	static void SetThreadPolicy(const class FString& ThreadName, int32 Policy);
	static void SetThreadPriority(const class FString& ThreadName, int32 Priority);
	static void SetThreadPriorityAndPolicy(const class FString& ThreadName, int32 Priority, int32 Policy);
	static void SetThreadPriorityAndPolicyAndAffinity(const class FString& ThreadName, int32 Priority, int32 Policy, int32 AffinityHigh, int32 AffinityLow);
	static void ShowSoftwareCursor(bool Visible);
	static class AActor* SpawnActorFromAnother(class AActor* Actor, class AActor* Parent);
	static void StopAllMontagesBySlotName(class UAnimInstance* UAnimInstance, const class FName InSlotName, const float InBlendOutTime);
	static bool ToggleSequenceNodeActiveByTag(const class ALevelSequenceActor* Actor, class FName TagName, bool bActive);
	static int32 ToUnixTimestamp(const struct FDateTime& InDataTime);
	static void UnRegisterCustomCommandProcessor(const class FString& Category);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroStaticLibrary">();
	}
	static class UKuroStaticLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroStaticLibrary>();
	}
};
static_assert(alignof(UKuroStaticLibrary) == 0x000008, "Wrong alignment on UKuroStaticLibrary");
static_assert(sizeof(UKuroStaticLibrary) == 0x000030, "Wrong size on UKuroStaticLibrary");

// Class KuroUtility.KuroStaticPS5Library
// 0x0000 (0x0030 - 0x0030)
class UKuroStaticPS5Library final : public UBlueprintFunctionLibrary
{
public:
	static class FString GetAccountIdByUserId(class FString* UserId);
	static int32 GetAuthCode(class FString* ClientId, class FString* Scope, class FString* AuthCode, int32* IssuerId);
	static TArray<struct FBasicPresenceData> GetBasicPresence(class FString* AccountId);
	static struct FBlockUserData GetBlockUserList(int32* Offset, int32* Limit);
	static int32 GetIdToken(class FString* ClientId, class FString* ClientSecret, class FString* Scope, class FString* IdToken);
	static class FString GetOnlineIdByUserId(class FString* UserId);
	static struct FTrophyInfoData GetTrophyList(class FString* UserId, int32* InputOffset, int32 Length);
	static int32 HidePsStoreIcon();
	static int32 InitWebApi(class FString* UserId);
	static void OpenWebBrowser(class FString* Url);
	static int32 ShowPsStoreIcon(int32 Position);
	static int32 UnlockTrophy(class FString* UserId, int32 TrophyId);
	static int32 UpdateTrophyProgress(class FString* UserId, int32 TrophyId, int32 Progress);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroStaticPS5Library">();
	}
	static class UKuroStaticPS5Library* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroStaticPS5Library>();
	}
};
static_assert(alignof(UKuroStaticPS5Library) == 0x000008, "Wrong alignment on UKuroStaticPS5Library");
static_assert(sizeof(UKuroStaticPS5Library) == 0x000030, "Wrong size on UKuroStaticPS5Library");

// Class KuroUtility.KuroTencentCOSLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroTencentCOSLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ClearAllProgressCallback();
	static void EnableAuthorization(bool Enable);
	static void EnableAutoSendWhenExit();
	static int32 GetAllFileNumNeedToSend();
	static int32 GetSendedFileNum();
	static void InterruptSending();
	static bool IsSending();
	static void SendFileToTencentCOS(const class FString& Path, const class FString& RemoteURI, const class FString& SecretID, const class FString& SecretKey, const class FString& BucketName, const class FString& Region);
	static void SendLogToTencentCOS(const TDelegate<void(int32 State, float Rate)>& OnProgress);
	static void SetAdmissibleValue(int32 SingleLogSizeInMb);
	static void SetFilesToSend(const TArray<class FString>& FilePaths);
	static void SetHandleFunc(const TDelegate<void(TArray<class FString>& FileNames)>& PrepareFunc, const TDelegate<void(TArray<class FString>& SendedFiles)>& PostSend);
	static void SetIsAutoSend(bool bIsAutoSend);
	static void SetSendLogConfig(const class FString& SecretID, const class FString& SecretKey, const class FString& BucketName, const class FString& Region);
	static void SetSendLogZipName(const class FString& ZipFileName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroTencentCOSLibrary">();
	}
	static class UKuroTencentCOSLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroTencentCOSLibrary>();
	}
};
static_assert(alignof(UKuroTencentCOSLibrary) == 0x000008, "Wrong alignment on UKuroTencentCOSLibrary");
static_assert(sizeof(UKuroTencentCOSLibrary) == 0x000030, "Wrong size on UKuroTencentCOSLibrary");

// Class KuroUtility.KuroTickableManager
// 0x0018 (0x0048 - 0x0030)
class UKuroTickableManager final : public UObject
{
public:
	uint8                                         Pad_1A7B[0x18];                                    // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CreateTickableFunc(class UObject* InOwner, TDelegate<void(float DeltaSeconds)> TickableHandler);
	void RemoveTickableFunc(class UObject* InOwner);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroTickableManager">();
	}
	static class UKuroTickableManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroTickableManager>();
	}
};
static_assert(alignof(UKuroTickableManager) == 0x000008, "Wrong alignment on UKuroTickableManager");
static_assert(sizeof(UKuroTickableManager) == 0x000048, "Wrong size on UKuroTickableManager");

// Class KuroUtility.KuroTriggerVolume
// 0x0010 (0x02F0 - 0x02E0)
class AKuroTriggerVolume final : public AVolume
{
public:
	class FName                                   VolumeId;                                          // 0x02E0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A7C[0x4];                                     // 0x02EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroTriggerVolume">();
	}
	static class AKuroTriggerVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroTriggerVolume>();
	}
};
static_assert(alignof(AKuroTriggerVolume) == 0x000008, "Wrong alignment on AKuroTriggerVolume");
static_assert(sizeof(AKuroTriggerVolume) == 0x0002F0, "Wrong size on AKuroTriggerVolume");
static_assert(offsetof(AKuroTriggerVolume, VolumeId) == 0x0002E0, "Member 'AKuroTriggerVolume::VolumeId' has a wrong offset!");

// Class KuroUtility.KuroTriggerVolumeManager
// 0x0070 (0x00A8 - 0x0038)
class UKuroTriggerVolumeManager final : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnTriggerVolumeAddToSubsystem;                     // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTriggerVolumeRemoveFromSubsystem;                // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<class FName, class AActor*>              KuroTriggerVolumeMap;                              // 0x0058(0x0050)(NativeAccessSpecifierPrivate)

public:
	class AActor* GetKuroTriggerVolume(class FName ActorKey);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroTriggerVolumeManager">();
	}
	static class UKuroTriggerVolumeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroTriggerVolumeManager>();
	}
};
static_assert(alignof(UKuroTriggerVolumeManager) == 0x000008, "Wrong alignment on UKuroTriggerVolumeManager");
static_assert(sizeof(UKuroTriggerVolumeManager) == 0x0000A8, "Wrong size on UKuroTriggerVolumeManager");
static_assert(offsetof(UKuroTriggerVolumeManager, OnTriggerVolumeAddToSubsystem) == 0x000038, "Member 'UKuroTriggerVolumeManager::OnTriggerVolumeAddToSubsystem' has a wrong offset!");
static_assert(offsetof(UKuroTriggerVolumeManager, OnTriggerVolumeRemoveFromSubsystem) == 0x000048, "Member 'UKuroTriggerVolumeManager::OnTriggerVolumeRemoveFromSubsystem' has a wrong offset!");
static_assert(offsetof(UKuroTriggerVolumeManager, KuroTriggerVolumeMap) == 0x000058, "Member 'UKuroTriggerVolumeManager::KuroTriggerVolumeMap' has a wrong offset!");

// Class KuroUtility.KuroWaterVolume
// 0x0000 (0x02E0 - 0x02E0)
class AKuroWaterVolume final : public AVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroWaterVolume">();
	}
	static class AKuroWaterVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroWaterVolume>();
	}
};
static_assert(alignof(AKuroWaterVolume) == 0x000008, "Wrong alignment on AKuroWaterVolume");
static_assert(sizeof(AKuroWaterVolume) == 0x0002E0, "Wrong size on AKuroWaterVolume");

// Class KuroUtility.LoadMapNotify
// 0x0158 (0x0188 - 0x0030)
class ULoadMapNotify final : public UObject
{
public:
	uint8                                         Pad_1A7E[0x158];                                   // 0x0030(0x0158)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindBeginLoadMap(TDelegate<void(const class FString& MapName)> BeginLoadMapHandler);
	void BindBeginTravelLoadMap(TDelegate<void(const class FString& MapName)> BeginTravelLoadMapHandler);
	void BindEndLoadMap(TDelegate<void(const class FString& MapName)> EndLoadMapHandler);
	void BindEndLoadTransitionMap(TDelegate<void()> EndLoadTransitionMapHandler);
	void BindLoadStreamLevel(const TDelegate<void(int32 LinkId, class FName& LevelName, class ULevelStreaming* StreamingLevel)> LoadStreamLevelHandler);
	void BindUnLoadStreamLevel(const TDelegate<void(int32 LinkId, class FName& LevelName)> UnLoadStreamLevelHandler);
	void Clear();
	int32 LoadStreamLevel(const class FName& Path, bool bMakeVisibleAfterLoad, bool bShouldBlockOnLoad);
	void OnLoadStreamLevel(const int32 LinkID);
	void OnUnLoadStreamLevel(const int32 LinkID);
	int32 UnloadStreamLevel(const class FName& Path, bool bShouldBlockOnLoad);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadMapNotify">();
	}
	static class ULoadMapNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadMapNotify>();
	}
};
static_assert(alignof(ULoadMapNotify) == 0x000008, "Wrong alignment on ULoadMapNotify");
static_assert(sizeof(ULoadMapNotify) == 0x000188, "Wrong size on ULoadMapNotify");

// Class KuroUtility.KuroTickManager
// 0x0048 (0x0078 - 0x0030)
class UKuroTickManager final : public UObject
{
public:
	uint8                                         Pad_1A81[0x48];                                    // 0x0030(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddPrerequisiteActorComponent(const ETickingGroup TickingGroup, class UActorComponent* ActorComp);
	bool AddTick(const ETickingGroup TickingGroup, const TDelegate<void(float DeltaSeconds)> TickHandler);
	void CleanSkeletalMeshProxyTickFunction(class USkeletalMeshComponent* SkelComp);
	void ClearTick();
	void RemovePrerequisiteActorComponent(const ETickingGroup TickingGroup, class UActorComponent* ActorComp);
	bool RemoveTick(const ETickingGroup TickingGroup);
	void SetSkeletalMeshProxyTickFunction(const ETickingGroup TickingGroup, class USkeletalMeshComponent* SkelComp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroTickManager">();
	}
	static class UKuroTickManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroTickManager>();
	}
};
static_assert(alignof(UKuroTickManager) == 0x000008, "Wrong alignment on UKuroTickManager");
static_assert(sizeof(UKuroTickManager) == 0x000078, "Wrong size on UKuroTickManager");

}

