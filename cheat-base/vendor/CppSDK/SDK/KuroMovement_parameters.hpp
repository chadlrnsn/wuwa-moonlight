#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroMovement

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "KuroMovement_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK::Params
{

// Function KuroMovement.KuroClimbObject.ClimbBlock
// 0x0001 (0x0001 - 0x0000)
struct KuroClimbObject_ClimbBlock final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroClimbObject_ClimbBlock) == 0x000001, "Wrong alignment on KuroClimbObject_ClimbBlock");
static_assert(sizeof(KuroClimbObject_ClimbBlock) == 0x000001, "Wrong size on KuroClimbObject_ClimbBlock");
static_assert(offsetof(KuroClimbObject_ClimbBlock, ReturnValue) == 0x000000, "Member 'KuroClimbObject_ClimbBlock::ReturnValue' has a wrong offset!");

// Function KuroMovement.KuroClimbObject.GetSafetyLocation
// 0x000C (0x000C - 0x0000)
struct KuroClimbObject_GetSafetyLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroClimbObject_GetSafetyLocation) == 0x000004, "Wrong alignment on KuroClimbObject_GetSafetyLocation");
static_assert(sizeof(KuroClimbObject_GetSafetyLocation) == 0x00000C, "Wrong size on KuroClimbObject_GetSafetyLocation");
static_assert(offsetof(KuroClimbObject_GetSafetyLocation, ReturnValue) == 0x000000, "Member 'KuroClimbObject_GetSafetyLocation::ReturnValue' has a wrong offset!");

// Function KuroMovement.KuroClimbObject.GetSecondMoveOffset
// 0x000C (0x000C - 0x0000)
struct KuroClimbObject_GetSecondMoveOffset final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroClimbObject_GetSecondMoveOffset) == 0x000004, "Wrong alignment on KuroClimbObject_GetSecondMoveOffset");
static_assert(sizeof(KuroClimbObject_GetSecondMoveOffset) == 0x00000C, "Wrong size on KuroClimbObject_GetSecondMoveOffset");
static_assert(offsetof(KuroClimbObject_GetSecondMoveOffset, ReturnValue) == 0x000000, "Member 'KuroClimbObject_GetSecondMoveOffset::ReturnValue' has a wrong offset!");

// Function KuroMovement.KuroClimbObject.InitBase
// 0x0038 (0x0038 - 0x0000)
struct KuroClimbObject_InitBase final
{
public:
	class UShapeComponent*                        InShapeComp;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             InClimbChannel;                                    // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181C[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        BaseLocations;                                     // 0x0010(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         InSphereRadius;                                    // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InActorToWallDist;                                 // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InDetectLength;                                    // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InSafetyHalfHeight;                                // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InSafetyRadius;                                    // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181D[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroClimbObject_InitBase) == 0x000008, "Wrong alignment on KuroClimbObject_InitBase");
static_assert(sizeof(KuroClimbObject_InitBase) == 0x000038, "Wrong size on KuroClimbObject_InitBase");
static_assert(offsetof(KuroClimbObject_InitBase, InShapeComp) == 0x000000, "Member 'KuroClimbObject_InitBase::InShapeComp' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_InitBase, InClimbChannel) == 0x000008, "Member 'KuroClimbObject_InitBase::InClimbChannel' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_InitBase, BaseLocations) == 0x000010, "Member 'KuroClimbObject_InitBase::BaseLocations' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_InitBase, InSphereRadius) == 0x000020, "Member 'KuroClimbObject_InitBase::InSphereRadius' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_InitBase, InActorToWallDist) == 0x000024, "Member 'KuroClimbObject_InitBase::InActorToWallDist' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_InitBase, InDetectLength) == 0x000028, "Member 'KuroClimbObject_InitBase::InDetectLength' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_InitBase, InSafetyHalfHeight) == 0x00002C, "Member 'KuroClimbObject_InitBase::InSafetyHalfHeight' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_InitBase, InSafetyRadius) == 0x000030, "Member 'KuroClimbObject_InitBase::InSafetyRadius' has a wrong offset!");

// Function KuroMovement.KuroClimbObject.InitBlockUps
// 0x0030 (0x0030 - 0x0000)
struct KuroClimbObject_InitBlockUps final
{
public:
	struct FVector                                InBlockUpOffset;                                   // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InBlockUpDetectRadius;                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InBlockUpDetectDistance;                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InBlockUpBackDistance;                             // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InBlockUpBackMin;                                  // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InBlockUpFinalMove;                                // 0x001C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlockUpVerticalRangeMin;                           // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlockUpVerticalRangeMax;                           // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroClimbObject_InitBlockUps) == 0x000004, "Wrong alignment on KuroClimbObject_InitBlockUps");
static_assert(sizeof(KuroClimbObject_InitBlockUps) == 0x000030, "Wrong size on KuroClimbObject_InitBlockUps");
static_assert(offsetof(KuroClimbObject_InitBlockUps, InBlockUpOffset) == 0x000000, "Member 'KuroClimbObject_InitBlockUps::InBlockUpOffset' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_InitBlockUps, InBlockUpDetectRadius) == 0x00000C, "Member 'KuroClimbObject_InitBlockUps::InBlockUpDetectRadius' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_InitBlockUps, InBlockUpDetectDistance) == 0x000010, "Member 'KuroClimbObject_InitBlockUps::InBlockUpDetectDistance' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_InitBlockUps, InBlockUpBackDistance) == 0x000014, "Member 'KuroClimbObject_InitBlockUps::InBlockUpBackDistance' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_InitBlockUps, InBlockUpBackMin) == 0x000018, "Member 'KuroClimbObject_InitBlockUps::InBlockUpBackMin' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_InitBlockUps, InBlockUpFinalMove) == 0x00001C, "Member 'KuroClimbObject_InitBlockUps::InBlockUpFinalMove' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_InitBlockUps, BlockUpVerticalRangeMin) == 0x000028, "Member 'KuroClimbObject_InitBlockUps::BlockUpVerticalRangeMin' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_InitBlockUps, BlockUpVerticalRangeMax) == 0x00002C, "Member 'KuroClimbObject_InitBlockUps::BlockUpVerticalRangeMax' has a wrong offset!");

// Function KuroMovement.KuroClimbObject.InitClimbSafety
// 0x000C (0x000C - 0x0000)
struct KuroClimbObject_InitClimbSafety final
{
public:
	float                                         InRadius;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InHalfHeight;                                      // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InMaxOffset;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroClimbObject_InitClimbSafety) == 0x000004, "Wrong alignment on KuroClimbObject_InitClimbSafety");
static_assert(sizeof(KuroClimbObject_InitClimbSafety) == 0x00000C, "Wrong size on KuroClimbObject_InitClimbSafety");
static_assert(offsetof(KuroClimbObject_InitClimbSafety, InRadius) == 0x000000, "Member 'KuroClimbObject_InitClimbSafety::InRadius' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_InitClimbSafety, InHalfHeight) == 0x000004, "Member 'KuroClimbObject_InitClimbSafety::InHalfHeight' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_InitClimbSafety, InMaxOffset) == 0x000008, "Member 'KuroClimbObject_InitClimbSafety::InMaxOffset' has a wrong offset!");

// Function KuroMovement.KuroClimbObject.InitSprintVault
// 0x003C (0x003C - 0x0000)
struct KuroClimbObject_InitSprintVault final
{
public:
	float                                         InForwardBlockHeight;                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InForwardBlockRadius;                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InForwardBlockDistanceMin;                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InForwardBlockDistanceMax;                         // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InSprintVaultMoveOffset;                           // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InHeightMin;                                       // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InHeightMax;                                       // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InSprintVaultLongNeedDistance;                     // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InSprintVaultLongHeight;                           // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               InBlockChannel;                                    // 0x002C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181E[0x3];                                     // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SprintVaultLongMin;                                // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintVaultLongMax;                                // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintVaultBlockMaxAngle;                          // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroClimbObject_InitSprintVault) == 0x000004, "Wrong alignment on KuroClimbObject_InitSprintVault");
static_assert(sizeof(KuroClimbObject_InitSprintVault) == 0x00003C, "Wrong size on KuroClimbObject_InitSprintVault");
static_assert(offsetof(KuroClimbObject_InitSprintVault, InForwardBlockHeight) == 0x000000, "Member 'KuroClimbObject_InitSprintVault::InForwardBlockHeight' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_InitSprintVault, InForwardBlockRadius) == 0x000004, "Member 'KuroClimbObject_InitSprintVault::InForwardBlockRadius' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_InitSprintVault, InForwardBlockDistanceMin) == 0x000008, "Member 'KuroClimbObject_InitSprintVault::InForwardBlockDistanceMin' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_InitSprintVault, InForwardBlockDistanceMax) == 0x00000C, "Member 'KuroClimbObject_InitSprintVault::InForwardBlockDistanceMax' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_InitSprintVault, InSprintVaultMoveOffset) == 0x000010, "Member 'KuroClimbObject_InitSprintVault::InSprintVaultMoveOffset' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_InitSprintVault, InHeightMin) == 0x00001C, "Member 'KuroClimbObject_InitSprintVault::InHeightMin' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_InitSprintVault, InHeightMax) == 0x000020, "Member 'KuroClimbObject_InitSprintVault::InHeightMax' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_InitSprintVault, InSprintVaultLongNeedDistance) == 0x000024, "Member 'KuroClimbObject_InitSprintVault::InSprintVaultLongNeedDistance' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_InitSprintVault, InSprintVaultLongHeight) == 0x000028, "Member 'KuroClimbObject_InitSprintVault::InSprintVaultLongHeight' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_InitSprintVault, InBlockChannel) == 0x00002C, "Member 'KuroClimbObject_InitSprintVault::InBlockChannel' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_InitSprintVault, SprintVaultLongMin) == 0x000030, "Member 'KuroClimbObject_InitSprintVault::SprintVaultLongMin' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_InitSprintVault, SprintVaultLongMax) == 0x000034, "Member 'KuroClimbObject_InitSprintVault::SprintVaultLongMax' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_InitSprintVault, SprintVaultBlockMaxAngle) == 0x000038, "Member 'KuroClimbObject_InitSprintVault::SprintVaultBlockMaxAngle' has a wrong offset!");

// Function KuroMovement.KuroClimbObject.InitUpArrives
// 0x0030 (0x0030 - 0x0000)
struct KuroClimbObject_InitUpArrives final
{
public:
	TArray<struct FVector>                        InUpArriveMoveOffsets;                             // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 InHeightMins;                                      // 0x0010(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 InHeightMaxs;                                      // 0x0020(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroClimbObject_InitUpArrives) == 0x000008, "Wrong alignment on KuroClimbObject_InitUpArrives");
static_assert(sizeof(KuroClimbObject_InitUpArrives) == 0x000030, "Wrong size on KuroClimbObject_InitUpArrives");
static_assert(offsetof(KuroClimbObject_InitUpArrives, InUpArriveMoveOffsets) == 0x000000, "Member 'KuroClimbObject_InitUpArrives::InUpArriveMoveOffsets' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_InitUpArrives, InHeightMins) == 0x000010, "Member 'KuroClimbObject_InitUpArrives::InHeightMins' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_InitUpArrives, InHeightMaxs) == 0x000020, "Member 'KuroClimbObject_InitUpArrives::InHeightMaxs' has a wrong offset!");

// Function KuroMovement.KuroClimbObject.NeedFollowHangOnStartingClimb
// 0x0001 (0x0001 - 0x0000)
struct KuroClimbObject_NeedFollowHangOnStartingClimb final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroClimbObject_NeedFollowHangOnStartingClimb) == 0x000001, "Wrong alignment on KuroClimbObject_NeedFollowHangOnStartingClimb");
static_assert(sizeof(KuroClimbObject_NeedFollowHangOnStartingClimb) == 0x000001, "Wrong size on KuroClimbObject_NeedFollowHangOnStartingClimb");
static_assert(offsetof(KuroClimbObject_NeedFollowHangOnStartingClimb, ReturnValue) == 0x000000, "Member 'KuroClimbObject_NeedFollowHangOnStartingClimb::ReturnValue' has a wrong offset!");

// Function KuroMovement.KuroClimbObject.ProcessClimbing
// 0x0060 (0x0060 - 0x0000)
struct KuroClimbObject_ProcessClimbing final
{
public:
	struct FVector                                MoveSpeed;                                         // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTryMove;                                         // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181F[0x3];                                     // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugDrawDuration;                                 // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1820[0x8];                                     // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             OutTrans;                                          // 0x0020(0x0030)(Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0050(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1821[0xF];                                     // 0x0051(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroClimbObject_ProcessClimbing) == 0x000010, "Wrong alignment on KuroClimbObject_ProcessClimbing");
static_assert(sizeof(KuroClimbObject_ProcessClimbing) == 0x000060, "Wrong size on KuroClimbObject_ProcessClimbing");
static_assert(offsetof(KuroClimbObject_ProcessClimbing, MoveSpeed) == 0x000000, "Member 'KuroClimbObject_ProcessClimbing::MoveSpeed' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_ProcessClimbing, DeltaTime) == 0x00000C, "Member 'KuroClimbObject_ProcessClimbing::DeltaTime' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_ProcessClimbing, IsTryMove) == 0x000010, "Member 'KuroClimbObject_ProcessClimbing::IsTryMove' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_ProcessClimbing, DebugDrawDuration) == 0x000014, "Member 'KuroClimbObject_ProcessClimbing::DebugDrawDuration' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_ProcessClimbing, OutTrans) == 0x000020, "Member 'KuroClimbObject_ProcessClimbing::OutTrans' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_ProcessClimbing, ReturnValue) == 0x000050, "Member 'KuroClimbObject_ProcessClimbing::ReturnValue' has a wrong offset!");

// Function KuroMovement.KuroClimbObject.SyncFromOther
// 0x0008 (0x0008 - 0x0000)
struct KuroClimbObject_SyncFromOther final
{
public:
	class UKuroClimbObject*                       Other;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroClimbObject_SyncFromOther) == 0x000008, "Wrong alignment on KuroClimbObject_SyncFromOther");
static_assert(sizeof(KuroClimbObject_SyncFromOther) == 0x000008, "Wrong size on KuroClimbObject_SyncFromOther");
static_assert(offsetof(KuroClimbObject_SyncFromOther, Other) == 0x000000, "Member 'KuroClimbObject_SyncFromOther::Other' has a wrong offset!");

// Function KuroMovement.KuroClimbObject.TryClimbingArrives
// 0x0050 (0x0050 - 0x0000)
struct KuroClimbObject_TryClimbingArrives final
{
public:
	struct FVector                                InputDirect;                                       // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebugDrawDuration;                                 // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             OutTrans;                                          // 0x0010(0x0030)(Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          NeedTryBlockUp;                                    // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EClimbingArriveType                           ReturnValue;                                       // 0x0041(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1822[0xE];                                     // 0x0042(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroClimbObject_TryClimbingArrives) == 0x000010, "Wrong alignment on KuroClimbObject_TryClimbingArrives");
static_assert(sizeof(KuroClimbObject_TryClimbingArrives) == 0x000050, "Wrong size on KuroClimbObject_TryClimbingArrives");
static_assert(offsetof(KuroClimbObject_TryClimbingArrives, InputDirect) == 0x000000, "Member 'KuroClimbObject_TryClimbingArrives::InputDirect' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_TryClimbingArrives, DebugDrawDuration) == 0x00000C, "Member 'KuroClimbObject_TryClimbingArrives::DebugDrawDuration' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_TryClimbingArrives, OutTrans) == 0x000010, "Member 'KuroClimbObject_TryClimbingArrives::OutTrans' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_TryClimbingArrives, NeedTryBlockUp) == 0x000040, "Member 'KuroClimbObject_TryClimbingArrives::NeedTryBlockUp' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_TryClimbingArrives, ReturnValue) == 0x000041, "Member 'KuroClimbObject_TryClimbingArrives::ReturnValue' has a wrong offset!");

// Function KuroMovement.KuroClimbObject.TrySprintVault
// 0x0050 (0x0050 - 0x0000)
struct KuroClimbObject_TrySprintVault final
{
public:
	float                                         DebugDrawDuration;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1823[0xC];                                     // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             OutTrans;                                          // 0x0010(0x0030)(Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         OutLongOffset;                                     // 0x0040(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESprintVaultType                              ReturnValue;                                       // 0x0044(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1824[0xB];                                     // 0x0045(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroClimbObject_TrySprintVault) == 0x000010, "Wrong alignment on KuroClimbObject_TrySprintVault");
static_assert(sizeof(KuroClimbObject_TrySprintVault) == 0x000050, "Wrong size on KuroClimbObject_TrySprintVault");
static_assert(offsetof(KuroClimbObject_TrySprintVault, DebugDrawDuration) == 0x000000, "Member 'KuroClimbObject_TrySprintVault::DebugDrawDuration' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_TrySprintVault, OutTrans) == 0x000010, "Member 'KuroClimbObject_TrySprintVault::OutTrans' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_TrySprintVault, OutLongOffset) == 0x000040, "Member 'KuroClimbObject_TrySprintVault::OutLongOffset' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_TrySprintVault, ReturnValue) == 0x000044, "Member 'KuroClimbObject_TrySprintVault::ReturnValue' has a wrong offset!");

// Function KuroMovement.KuroClimbObject.TryStartClimb
// 0x0080 (0x0080 - 0x0000)
struct KuroClimbObject_TryStartClimb final
{
public:
	struct FTransform                             Trans;                                             // 0x0000(0x0030)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         DebugDrawDuration;                                 // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1825[0xC];                                     // 0x0034(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             OutTrans;                                          // 0x0040(0x0030)(Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0070(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1826[0xF];                                     // 0x0071(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroClimbObject_TryStartClimb) == 0x000010, "Wrong alignment on KuroClimbObject_TryStartClimb");
static_assert(sizeof(KuroClimbObject_TryStartClimb) == 0x000080, "Wrong size on KuroClimbObject_TryStartClimb");
static_assert(offsetof(KuroClimbObject_TryStartClimb, Trans) == 0x000000, "Member 'KuroClimbObject_TryStartClimb::Trans' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_TryStartClimb, DebugDrawDuration) == 0x000030, "Member 'KuroClimbObject_TryStartClimb::DebugDrawDuration' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_TryStartClimb, OutTrans) == 0x000040, "Member 'KuroClimbObject_TryStartClimb::OutTrans' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_TryStartClimb, ReturnValue) == 0x000070, "Member 'KuroClimbObject_TryStartClimb::ReturnValue' has a wrong offset!");

// Function KuroMovement.KuroClimbObject.TryUpArrives
// 0x0050 (0x0050 - 0x0000)
struct KuroClimbObject_TryUpArrives final
{
public:
	struct FVector                                InputDirect;                                       // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebugDrawDuration;                                 // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             OutTrans;                                          // 0x0010(0x0030)(Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EClimbingArriveType                           ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1827[0xF];                                     // 0x0041(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroClimbObject_TryUpArrives) == 0x000010, "Wrong alignment on KuroClimbObject_TryUpArrives");
static_assert(sizeof(KuroClimbObject_TryUpArrives) == 0x000050, "Wrong size on KuroClimbObject_TryUpArrives");
static_assert(offsetof(KuroClimbObject_TryUpArrives, InputDirect) == 0x000000, "Member 'KuroClimbObject_TryUpArrives::InputDirect' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_TryUpArrives, DebugDrawDuration) == 0x00000C, "Member 'KuroClimbObject_TryUpArrives::DebugDrawDuration' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_TryUpArrives, OutTrans) == 0x000010, "Member 'KuroClimbObject_TryUpArrives::OutTrans' has a wrong offset!");
static_assert(offsetof(KuroClimbObject_TryUpArrives, ReturnValue) == 0x000040, "Member 'KuroClimbObject_TryUpArrives::ReturnValue' has a wrong offset!");

// Function KuroMovement.KuroDebugMovementComponent.KuroDebugMovementBaseRecordToString
// 0x0058 (0x0058 - 0x0000)
struct KuroDebugMovementComponent_KuroDebugMovementBaseRecordToString final
{
public:
	struct FBaseRecord                            Record;                                            // 0x0000(0x0044)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1829[0x4];                                     // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0048(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroDebugMovementComponent_KuroDebugMovementBaseRecordToString) == 0x000008, "Wrong alignment on KuroDebugMovementComponent_KuroDebugMovementBaseRecordToString");
static_assert(sizeof(KuroDebugMovementComponent_KuroDebugMovementBaseRecordToString) == 0x000058, "Wrong size on KuroDebugMovementComponent_KuroDebugMovementBaseRecordToString");
static_assert(offsetof(KuroDebugMovementComponent_KuroDebugMovementBaseRecordToString, Record) == 0x000000, "Member 'KuroDebugMovementComponent_KuroDebugMovementBaseRecordToString::Record' has a wrong offset!");
static_assert(offsetof(KuroDebugMovementComponent_KuroDebugMovementBaseRecordToString, ReturnValue) == 0x000048, "Member 'KuroDebugMovementComponent_KuroDebugMovementBaseRecordToString::ReturnValue' has a wrong offset!");

// Function KuroMovement.KuroDebugMovementComponent.GetCurrentFrameIndex
// 0x0004 (0x0004 - 0x0000)
struct KuroDebugMovementComponent_GetCurrentFrameIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroDebugMovementComponent_GetCurrentFrameIndex) == 0x000004, "Wrong alignment on KuroDebugMovementComponent_GetCurrentFrameIndex");
static_assert(sizeof(KuroDebugMovementComponent_GetCurrentFrameIndex) == 0x000004, "Wrong size on KuroDebugMovementComponent_GetCurrentFrameIndex");
static_assert(offsetof(KuroDebugMovementComponent_GetCurrentFrameIndex, ReturnValue) == 0x000000, "Member 'KuroDebugMovementComponent_GetCurrentFrameIndex::ReturnValue' has a wrong offset!");

// Function KuroMovement.KuroDebugMovementComponent.GetFrameCountInfo
// 0x0010 (0x0010 - 0x0000)
struct KuroDebugMovementComponent_GetFrameCountInfo final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroDebugMovementComponent_GetFrameCountInfo) == 0x000008, "Wrong alignment on KuroDebugMovementComponent_GetFrameCountInfo");
static_assert(sizeof(KuroDebugMovementComponent_GetFrameCountInfo) == 0x000010, "Wrong size on KuroDebugMovementComponent_GetFrameCountInfo");
static_assert(offsetof(KuroDebugMovementComponent_GetFrameCountInfo, ReturnValue) == 0x000000, "Member 'KuroDebugMovementComponent_GetFrameCountInfo::ReturnValue' has a wrong offset!");

// Function KuroMovement.KuroDebugMovementComponent.GetMaxRecordFrameCount
// 0x0004 (0x0004 - 0x0000)
struct KuroDebugMovementComponent_GetMaxRecordFrameCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroDebugMovementComponent_GetMaxRecordFrameCount) == 0x000004, "Wrong alignment on KuroDebugMovementComponent_GetMaxRecordFrameCount");
static_assert(sizeof(KuroDebugMovementComponent_GetMaxRecordFrameCount) == 0x000004, "Wrong size on KuroDebugMovementComponent_GetMaxRecordFrameCount");
static_assert(offsetof(KuroDebugMovementComponent_GetMaxRecordFrameCount, ReturnValue) == 0x000000, "Member 'KuroDebugMovementComponent_GetMaxRecordFrameCount::ReturnValue' has a wrong offset!");

// Function KuroMovement.KuroDebugMovementComponent.GetPreviousRecord
// 0x0110 (0x0110 - 0x0000)
struct KuroDebugMovementComponent_GetPreviousRecord final
{
public:
	int32                                         PreNum;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_182A[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSingleFrameDebugInfo                  ReturnValue;                                       // 0x0008(0x0108)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroDebugMovementComponent_GetPreviousRecord) == 0x000008, "Wrong alignment on KuroDebugMovementComponent_GetPreviousRecord");
static_assert(sizeof(KuroDebugMovementComponent_GetPreviousRecord) == 0x000110, "Wrong size on KuroDebugMovementComponent_GetPreviousRecord");
static_assert(offsetof(KuroDebugMovementComponent_GetPreviousRecord, PreNum) == 0x000000, "Member 'KuroDebugMovementComponent_GetPreviousRecord::PreNum' has a wrong offset!");
static_assert(offsetof(KuroDebugMovementComponent_GetPreviousRecord, ReturnValue) == 0x000008, "Member 'KuroDebugMovementComponent_GetPreviousRecord::ReturnValue' has a wrong offset!");

// Function KuroMovement.KuroDebugMovementComponent.GetRecentRecords
// 0x0010 (0x0010 - 0x0000)
struct KuroDebugMovementComponent_GetRecentRecords final
{
public:
	TArray<struct FSingleFrameDebugInfo>          ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroDebugMovementComponent_GetRecentRecords) == 0x000008, "Wrong alignment on KuroDebugMovementComponent_GetRecentRecords");
static_assert(sizeof(KuroDebugMovementComponent_GetRecentRecords) == 0x000010, "Wrong size on KuroDebugMovementComponent_GetRecentRecords");
static_assert(offsetof(KuroDebugMovementComponent_GetRecentRecords, ReturnValue) == 0x000000, "Member 'KuroDebugMovementComponent_GetRecentRecords::ReturnValue' has a wrong offset!");

// Function KuroMovement.KuroDebugMovementComponent.GetRecordFrames
// 0x0004 (0x0004 - 0x0000)
struct KuroDebugMovementComponent_GetRecordFrames final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroDebugMovementComponent_GetRecordFrames) == 0x000004, "Wrong alignment on KuroDebugMovementComponent_GetRecordFrames");
static_assert(sizeof(KuroDebugMovementComponent_GetRecordFrames) == 0x000004, "Wrong size on KuroDebugMovementComponent_GetRecordFrames");
static_assert(offsetof(KuroDebugMovementComponent_GetRecordFrames, ReturnValue) == 0x000000, "Member 'KuroDebugMovementComponent_GetRecordFrames::ReturnValue' has a wrong offset!");

// Function KuroMovement.KuroDebugMovementComponent.RecordModifyInfo
// 0x0020 (0x0020 - 0x0000)
struct KuroDebugMovementComponent_RecordModifyInfo final
{
public:
	class FString                                 Context;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CustomVector;                                      // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKDMRecordType                                Type;                                              // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_182B[0x3];                                     // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroDebugMovementComponent_RecordModifyInfo) == 0x000008, "Wrong alignment on KuroDebugMovementComponent_RecordModifyInfo");
static_assert(sizeof(KuroDebugMovementComponent_RecordModifyInfo) == 0x000020, "Wrong size on KuroDebugMovementComponent_RecordModifyInfo");
static_assert(offsetof(KuroDebugMovementComponent_RecordModifyInfo, Context) == 0x000000, "Member 'KuroDebugMovementComponent_RecordModifyInfo::Context' has a wrong offset!");
static_assert(offsetof(KuroDebugMovementComponent_RecordModifyInfo, CustomVector) == 0x000010, "Member 'KuroDebugMovementComponent_RecordModifyInfo::CustomVector' has a wrong offset!");
static_assert(offsetof(KuroDebugMovementComponent_RecordModifyInfo, Type) == 0x00001C, "Member 'KuroDebugMovementComponent_RecordModifyInfo::Type' has a wrong offset!");

// Function KuroMovement.KuroDebugMovementComponent.SetDebug
// 0x0002 (0x0002 - 0x0000)
struct KuroDebugMovementComponent_SetDebug final
{
public:
	bool                                          bDebug;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDetial;                                           // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroDebugMovementComponent_SetDebug) == 0x000001, "Wrong alignment on KuroDebugMovementComponent_SetDebug");
static_assert(sizeof(KuroDebugMovementComponent_SetDebug) == 0x000002, "Wrong size on KuroDebugMovementComponent_SetDebug");
static_assert(offsetof(KuroDebugMovementComponent_SetDebug, bDebug) == 0x000000, "Member 'KuroDebugMovementComponent_SetDebug::bDebug' has a wrong offset!");
static_assert(offsetof(KuroDebugMovementComponent_SetDebug, bDetial) == 0x000001, "Member 'KuroDebugMovementComponent_SetDebug::bDetial' has a wrong offset!");

// Function KuroMovement.KuroMoveTrigger.OnEndOverlap
// 0x0020 (0x0020 - 0x0000)
struct KuroMoveTrigger_OnEndOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_182D[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMoveTrigger_OnEndOverlap) == 0x000008, "Wrong alignment on KuroMoveTrigger_OnEndOverlap");
static_assert(sizeof(KuroMoveTrigger_OnEndOverlap) == 0x000020, "Wrong size on KuroMoveTrigger_OnEndOverlap");
static_assert(offsetof(KuroMoveTrigger_OnEndOverlap, OverlappedComponent) == 0x000000, "Member 'KuroMoveTrigger_OnEndOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(KuroMoveTrigger_OnEndOverlap, OtherActor) == 0x000008, "Member 'KuroMoveTrigger_OnEndOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(KuroMoveTrigger_OnEndOverlap, OtherComp) == 0x000010, "Member 'KuroMoveTrigger_OnEndOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(KuroMoveTrigger_OnEndOverlap, OtherBodyIndex) == 0x000018, "Member 'KuroMoveTrigger_OnEndOverlap::OtherBodyIndex' has a wrong offset!");

// Function KuroMovement.KuroMoveTrigger.OnEnterOverlap
// 0x00B8 (0x00B8 - 0x0000)
struct KuroMoveTrigger_OnEnterOverlap final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_182E[0x3];                                     // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0094)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_182F[0x4];                                     // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMoveTrigger_OnEnterOverlap) == 0x000008, "Wrong alignment on KuroMoveTrigger_OnEnterOverlap");
static_assert(sizeof(KuroMoveTrigger_OnEnterOverlap) == 0x0000B8, "Wrong size on KuroMoveTrigger_OnEnterOverlap");
static_assert(offsetof(KuroMoveTrigger_OnEnterOverlap, OverlappedComponent) == 0x000000, "Member 'KuroMoveTrigger_OnEnterOverlap::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(KuroMoveTrigger_OnEnterOverlap, OtherActor) == 0x000008, "Member 'KuroMoveTrigger_OnEnterOverlap::OtherActor' has a wrong offset!");
static_assert(offsetof(KuroMoveTrigger_OnEnterOverlap, OtherComp) == 0x000010, "Member 'KuroMoveTrigger_OnEnterOverlap::OtherComp' has a wrong offset!");
static_assert(offsetof(KuroMoveTrigger_OnEnterOverlap, OtherBodyIndex) == 0x000018, "Member 'KuroMoveTrigger_OnEnterOverlap::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(KuroMoveTrigger_OnEnterOverlap, bFromSweep) == 0x00001C, "Member 'KuroMoveTrigger_OnEnterOverlap::bFromSweep' has a wrong offset!");
static_assert(offsetof(KuroMoveTrigger_OnEnterOverlap, SweepResult) == 0x000020, "Member 'KuroMoveTrigger_OnEnterOverlap::SweepResult' has a wrong offset!");

// Function KuroMovement.KuroMovementBPLibrary.KuroSki
// 0x0048 (0x0048 - 0x0000)
struct KuroMovementBPLibrary_KuroSki final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1830[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterMovementComponent*            CharMoveComp;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PrevBlockNormal;                                   // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x001C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpeedParams;                                       // 0x0028(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IgnoreStepHeight;                                  // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SpeedReduceCurve;                                  // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1831[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMovementBPLibrary_KuroSki) == 0x000008, "Wrong alignment on KuroMovementBPLibrary_KuroSki");
static_assert(sizeof(KuroMovementBPLibrary_KuroSki) == 0x000048, "Wrong size on KuroMovementBPLibrary_KuroSki");
static_assert(offsetof(KuroMovementBPLibrary_KuroSki, DeltaTime) == 0x000000, "Member 'KuroMovementBPLibrary_KuroSki::DeltaTime' has a wrong offset!");
static_assert(offsetof(KuroMovementBPLibrary_KuroSki, CharMoveComp) == 0x000008, "Member 'KuroMovementBPLibrary_KuroSki::CharMoveComp' has a wrong offset!");
static_assert(offsetof(KuroMovementBPLibrary_KuroSki, PrevBlockNormal) == 0x000010, "Member 'KuroMovementBPLibrary_KuroSki::PrevBlockNormal' has a wrong offset!");
static_assert(offsetof(KuroMovementBPLibrary_KuroSki, Direction) == 0x00001C, "Member 'KuroMovementBPLibrary_KuroSki::Direction' has a wrong offset!");
static_assert(offsetof(KuroMovementBPLibrary_KuroSki, SpeedParams) == 0x000028, "Member 'KuroMovementBPLibrary_KuroSki::SpeedParams' has a wrong offset!");
static_assert(offsetof(KuroMovementBPLibrary_KuroSki, IgnoreStepHeight) == 0x000034, "Member 'KuroMovementBPLibrary_KuroSki::IgnoreStepHeight' has a wrong offset!");
static_assert(offsetof(KuroMovementBPLibrary_KuroSki, SpeedReduceCurve) == 0x000038, "Member 'KuroMovementBPLibrary_KuroSki::SpeedReduceCurve' has a wrong offset!");
static_assert(offsetof(KuroMovementBPLibrary_KuroSki, ReturnValue) == 0x000040, "Member 'KuroMovementBPLibrary_KuroSki::ReturnValue' has a wrong offset!");

// Function KuroMovement.KuroMovementBPLibrary.KuroSoar
// 0x0038 (0x0038 - 0x0000)
struct KuroMovementBPLibrary_KuroSoar final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1832[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterMovementComponent*            CharMoveComp;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirFriction;                                       // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Aerodynamics;                                      // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Gravity;                                           // 0x0018(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SoarPlaneNormal;                                   // 0x0024(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1833[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMovementBPLibrary_KuroSoar) == 0x000008, "Wrong alignment on KuroMovementBPLibrary_KuroSoar");
static_assert(sizeof(KuroMovementBPLibrary_KuroSoar) == 0x000038, "Wrong size on KuroMovementBPLibrary_KuroSoar");
static_assert(offsetof(KuroMovementBPLibrary_KuroSoar, DeltaSeconds) == 0x000000, "Member 'KuroMovementBPLibrary_KuroSoar::DeltaSeconds' has a wrong offset!");
static_assert(offsetof(KuroMovementBPLibrary_KuroSoar, CharMoveComp) == 0x000008, "Member 'KuroMovementBPLibrary_KuroSoar::CharMoveComp' has a wrong offset!");
static_assert(offsetof(KuroMovementBPLibrary_KuroSoar, AirFriction) == 0x000010, "Member 'KuroMovementBPLibrary_KuroSoar::AirFriction' has a wrong offset!");
static_assert(offsetof(KuroMovementBPLibrary_KuroSoar, Aerodynamics) == 0x000014, "Member 'KuroMovementBPLibrary_KuroSoar::Aerodynamics' has a wrong offset!");
static_assert(offsetof(KuroMovementBPLibrary_KuroSoar, Gravity) == 0x000018, "Member 'KuroMovementBPLibrary_KuroSoar::Gravity' has a wrong offset!");
static_assert(offsetof(KuroMovementBPLibrary_KuroSoar, SoarPlaneNormal) == 0x000024, "Member 'KuroMovementBPLibrary_KuroSoar::SoarPlaneNormal' has a wrong offset!");
static_assert(offsetof(KuroMovementBPLibrary_KuroSoar, ReturnValue) == 0x000030, "Member 'KuroMovementBPLibrary_KuroSoar::ReturnValue' has a wrong offset!");

// Function KuroMovement.KuroMoveTriggerController.RegisterController
// 0x0008 (0x0008 - 0x0000)
struct KuroMoveTriggerController_RegisterController final
{
public:
	class AKuroMoveTriggerController*             ControllerPtr;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMoveTriggerController_RegisterController) == 0x000008, "Wrong alignment on KuroMoveTriggerController_RegisterController");
static_assert(sizeof(KuroMoveTriggerController_RegisterController) == 0x000008, "Wrong size on KuroMoveTriggerController_RegisterController");
static_assert(offsetof(KuroMoveTriggerController_RegisterController, ControllerPtr) == 0x000000, "Member 'KuroMoveTriggerController_RegisterController::ControllerPtr' has a wrong offset!");

}

