#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: LGUI

#include "Basic.hpp"

#include "KuroCurve_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "LGUI_structs.hpp"
#include "LTween_structs.hpp"
#include "Slate_structs.hpp"
#include "SlateCore_structs.hpp"
#include "Niagara_classes.hpp"
#include "InputCore_structs.hpp"


namespace SDK
{

// Class LGUI.PrefabActorHierarchyData
// 0x0000 (0x0030 - 0x0030)
class UPrefabActorHierarchyData final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PrefabActorHierarchyData">();
	}
	static class UPrefabActorHierarchyData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPrefabActorHierarchyData>();
	}
};
static_assert(alignof(UPrefabActorHierarchyData) == 0x000008, "Wrong alignment on UPrefabActorHierarchyData");
static_assert(sizeof(UPrefabActorHierarchyData) == 0x000030, "Wrong size on UPrefabActorHierarchyData");

// Class LGUI.GuideHookRegistry
// 0x0050 (0x0110 - 0x00C0)
class UGuideHookRegistry final : public UActorComponent
{
public:
	TMap<class FString, TWeakObjectPtr<class AActor>> GuideHookComponents;                               // 0x00C0(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuideHookRegistry">();
	}
	static class UGuideHookRegistry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuideHookRegistry>();
	}
};
static_assert(alignof(UGuideHookRegistry) == 0x000008, "Wrong alignment on UGuideHookRegistry");
static_assert(sizeof(UGuideHookRegistry) == 0x000110, "Wrong size on UGuideHookRegistry");
static_assert(offsetof(UGuideHookRegistry, GuideHookComponents) == 0x0000C0, "Member 'UGuideHookRegistry::GuideHookComponents' has a wrong offset!");

// Class LGUI.LGUIBehaviour
// 0x0040 (0x0100 - 0x00C0)
class ULGUIBehaviour : public UActorComponent
{
public:
	bool                                          Enable;                                            // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10D1[0x7];                                     // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(float DeltaTime)>              OnLateUpdate;                                      // 0x00C8(0x0028)(Edit, ZeroConstructor, InstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_10D2[0x4];                                     // 0x00F0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UUIItem>                 RootUIComp;                                        // 0x00F4(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10D3[0x4];                                     // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AwakeBP();
	class AActor* InstantiateActor(class AActor* OriginObject, class USceneComponent* Parent);
	class AActor* InstantiatePrefab(class ULGUIPrefab* OriginObject, class USceneComponent* Parent);
	class AActor* InstantiatePrefabWithTransform(class ULGUIPrefab* OriginObject, class USceneComponent* Parent, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale);
	void LateUpdateBP(float DeltaTime);
	void OnDestroyBP();
	void OnDisableBP();
	void OnEnableBP();
	void OnUIActiveInHierarchyBP(bool ActiveOrInactive);
	void OnUIAttachmentChangedBP();
	void OnUIChildAcitveInHierarchyBP(class UUIItem* Child, bool AtiveOrInactive);
	void OnUIChildAttachmentChangedBP(class UUIItem* Child, bool AttachOrDetach);
	void OnUIChildHierarchyIndexChangedBP(class UUIItem* Child);
	void OnUIDimensionsChangedBP(bool PositionChanged, bool SizeChanged);
	void OnUIInteractionStateChangedBP(bool InteractableOrNot);
	void SetEnable(bool Value);
	void StartBP();
	void UpdateBP(float DeltaTime);

	bool CheckRootUIComponent() const;
	bool GetEnable() const;
	bool GetIsActiveAndEnable() const;
	class UUIItem* GetRootComponent() const;
	class USceneComponent* GetRootSceneComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIBehaviour">();
	}
	static class ULGUIBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIBehaviour>();
	}
};
static_assert(alignof(ULGUIBehaviour) == 0x000008, "Wrong alignment on ULGUIBehaviour");
static_assert(sizeof(ULGUIBehaviour) == 0x000100, "Wrong size on ULGUIBehaviour");
static_assert(offsetof(ULGUIBehaviour, Enable) == 0x0000C0, "Member 'ULGUIBehaviour::Enable' has a wrong offset!");
static_assert(offsetof(ULGUIBehaviour, OnLateUpdate) == 0x0000C8, "Member 'ULGUIBehaviour::OnLateUpdate' has a wrong offset!");
static_assert(offsetof(ULGUIBehaviour, RootUIComp) == 0x0000F4, "Member 'ULGUIBehaviour::RootUIComp' has a wrong offset!");

// Class LGUI.UISafeZone
// 0x00B0 (0x01B0 - 0x0100)
class UUISafeZone final : public ULGUIBehaviour
{
public:
	ESafeZoneAdaptionStrategy                     AdaptionStrategy;                                  // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10D7[0x3];                                     // 0x0101(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMargin                                Padding;                                           // 0x0104(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_10D8[0x10];                                    // 0x0114(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMargin                                DefaultMargin;                                     // 0x0124(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FMargin                                PadMargin;                                         // 0x0134(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_10D9[0x4];                                     // 0x0144(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FMargin>           CustomDeviceMargins;                               // 0x0148(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_10DA[0x18];                                    // 0x0198(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetWidthAndHeightRadio(float Left, float Right, float Top, float Bottom);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISafeZone">();
	}
	static class UUISafeZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISafeZone>();
	}
};
static_assert(alignof(UUISafeZone) == 0x000008, "Wrong alignment on UUISafeZone");
static_assert(sizeof(UUISafeZone) == 0x0001B0, "Wrong size on UUISafeZone");
static_assert(offsetof(UUISafeZone, AdaptionStrategy) == 0x000100, "Member 'UUISafeZone::AdaptionStrategy' has a wrong offset!");
static_assert(offsetof(UUISafeZone, Padding) == 0x000104, "Member 'UUISafeZone::Padding' has a wrong offset!");
static_assert(offsetof(UUISafeZone, DefaultMargin) == 0x000124, "Member 'UUISafeZone::DefaultMargin' has a wrong offset!");
static_assert(offsetof(UUISafeZone, PadMargin) == 0x000134, "Member 'UUISafeZone::PadMargin' has a wrong offset!");
static_assert(offsetof(UUISafeZone, CustomDeviceMargins) == 0x000148, "Member 'UUISafeZone::CustomDeviceMargins' has a wrong offset!");

// Class LGUI.LGUIPrefabHelperObject
// 0x0000 (0x0030 - 0x0030)
class ULGUIPrefabHelperObject final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPrefabHelperObject">();
	}
	static class ULGUIPrefabHelperObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPrefabHelperObject>();
	}
};
static_assert(alignof(ULGUIPrefabHelperObject) == 0x000008, "Wrong alignment on ULGUIPrefabHelperObject");
static_assert(sizeof(ULGUIPrefabHelperObject) == 0x000030, "Wrong size on ULGUIPrefabHelperObject");

// Class LGUI.KuroWorldMapUIParams
// 0x0020 (0x00E0 - 0x00C0)
class UKuroWorldMapUIParams final : public UActorComponent
{
public:
	int32                                         MarkMenuRectSize;                                  // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              FocusMark_AnchoredPosition;                        // 0x00C4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TweenTime;                                         // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELTweenEase                                   TweenTypeEase;                                     // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10DB[0x3];                                     // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GamePadTweenTime;                                  // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamePadMoveSpeed;                                  // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10DC[0x4];                                     // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroWorldMapUIParams">();
	}
	static class UKuroWorldMapUIParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroWorldMapUIParams>();
	}
};
static_assert(alignof(UKuroWorldMapUIParams) == 0x000008, "Wrong alignment on UKuroWorldMapUIParams");
static_assert(sizeof(UKuroWorldMapUIParams) == 0x0000E0, "Wrong size on UKuroWorldMapUIParams");
static_assert(offsetof(UKuroWorldMapUIParams, MarkMenuRectSize) == 0x0000C0, "Member 'UKuroWorldMapUIParams::MarkMenuRectSize' has a wrong offset!");
static_assert(offsetof(UKuroWorldMapUIParams, FocusMark_AnchoredPosition) == 0x0000C4, "Member 'UKuroWorldMapUIParams::FocusMark_AnchoredPosition' has a wrong offset!");
static_assert(offsetof(UKuroWorldMapUIParams, TweenTime) == 0x0000CC, "Member 'UKuroWorldMapUIParams::TweenTime' has a wrong offset!");
static_assert(offsetof(UKuroWorldMapUIParams, TweenTypeEase) == 0x0000D0, "Member 'UKuroWorldMapUIParams::TweenTypeEase' has a wrong offset!");
static_assert(offsetof(UKuroWorldMapUIParams, GamePadTweenTime) == 0x0000D4, "Member 'UKuroWorldMapUIParams::GamePadTweenTime' has a wrong offset!");
static_assert(offsetof(UKuroWorldMapUIParams, GamePadMoveSpeed) == 0x0000D8, "Member 'UKuroWorldMapUIParams::GamePadMoveSpeed' has a wrong offset!");

// Class LGUI.LGUIPrefabHelperActor
// 0x0000 (0x02A8 - 0x02A8)
class ALGUIPrefabHelperActor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPrefabHelperActor">();
	}
	static class ALGUIPrefabHelperActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALGUIPrefabHelperActor>();
	}
};
static_assert(alignof(ALGUIPrefabHelperActor) == 0x000008, "Wrong alignment on ALGUIPrefabHelperActor");
static_assert(sizeof(ALGUIPrefabHelperActor) == 0x0002A8, "Wrong size on ALGUIPrefabHelperActor");

// Class LGUI.LGUIBaseRayEmitter
// 0x0030 (0x00F0 - 0x00C0)
class ULGUIBaseRayEmitter : public UActorComponent
{
public:
	float                                         ClickThreshold;                                    // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          HoldToDrag;                                        // 0x00C4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10DD[0x3];                                     // 0x00C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HoldToDragTime;                                    // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10DE[0x24];                                    // 0x00CC(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetClickThreshold();
	void GetInitialValue(float* OutClickThreshold, bool* OutHoldToDrag, float* OutHoldToDragTime);
	void SetClickThreshold(float Value);
	void SetInitialValue(float InClickThreshold, bool InHoldToDrag, float InHoldToDragTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIBaseRayEmitter">();
	}
	static class ULGUIBaseRayEmitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIBaseRayEmitter>();
	}
};
static_assert(alignof(ULGUIBaseRayEmitter) == 0x000008, "Wrong alignment on ULGUIBaseRayEmitter");
static_assert(sizeof(ULGUIBaseRayEmitter) == 0x0000F0, "Wrong size on ULGUIBaseRayEmitter");
static_assert(offsetof(ULGUIBaseRayEmitter, ClickThreshold) == 0x0000C0, "Member 'ULGUIBaseRayEmitter::ClickThreshold' has a wrong offset!");
static_assert(offsetof(ULGUIBaseRayEmitter, HoldToDrag) == 0x0000C4, "Member 'ULGUIBaseRayEmitter::HoldToDrag' has a wrong offset!");
static_assert(offsetof(ULGUIBaseRayEmitter, HoldToDragTime) == 0x0000C8, "Member 'ULGUIBaseRayEmitter::HoldToDragTime' has a wrong offset!");

// Class LGUI.UILayoutBase
// 0x0070 (0x0170 - 0x0100)
class UUILayoutBase : public ULGUIBehaviour
{
public:
	uint8                                         Pad_10E1[0x20];                                    // 0x0100(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GridAnimationStartTime;                            // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GridAnimationInterval;                             // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsInAnimation;                                     // 0x0128(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsScaleCalculated;                                // 0x0129(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10E2[0x1E];                                    // 0x012A(0x001E)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(class UUILayoutBase* Layout)>  OnRebuildLayoutDelegate;                           // 0x0148(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)

public:
	void SetGridAnimationInterval(float Value);
	void SetGridAnimationStartTime(float Value);
	void SetInAnimation(bool State);

	float GetGridAnimationInterval() const;
	float GetGridAnimationStartTime() const;
	bool GetInAnimation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILayoutBase">();
	}
	static class UUILayoutBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILayoutBase>();
	}
};
static_assert(alignof(UUILayoutBase) == 0x000008, "Wrong alignment on UUILayoutBase");
static_assert(sizeof(UUILayoutBase) == 0x000170, "Wrong size on UUILayoutBase");
static_assert(offsetof(UUILayoutBase, GridAnimationStartTime) == 0x000120, "Member 'UUILayoutBase::GridAnimationStartTime' has a wrong offset!");
static_assert(offsetof(UUILayoutBase, GridAnimationInterval) == 0x000124, "Member 'UUILayoutBase::GridAnimationInterval' has a wrong offset!");
static_assert(offsetof(UUILayoutBase, IsInAnimation) == 0x000128, "Member 'UUILayoutBase::IsInAnimation' has a wrong offset!");
static_assert(offsetof(UUILayoutBase, bIsScaleCalculated) == 0x000129, "Member 'UUILayoutBase::bIsScaleCalculated' has a wrong offset!");
static_assert(offsetof(UUILayoutBase, OnRebuildLayoutDelegate) == 0x000148, "Member 'UUILayoutBase::OnRebuildLayoutDelegate' has a wrong offset!");

// Class LGUI.UISizeControlByOther
// 0x0038 (0x01A8 - 0x0170)
class UUISizeControlByOther final : public UUILayoutBase
{
public:
	TWeakObjectPtr<class AUIBaseActor>            TargetActor;                                       // 0x0170(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ControlWidth;                                      // 0x0178(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ControlHeight;                                     // 0x0179(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UseWidthRange;                                     // 0x017A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UseHeightRange;                                    // 0x017B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxWidth;                                          // 0x017C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinWidth;                                          // 0x0180(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxHeight;                                         // 0x0184(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinHeight;                                         // 0x0188(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AdditionalWidth;                                   // 0x018C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AdditionalHeight;                                  // 0x0190(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UUIItem>                 TargetUIItem;                                      // 0x0194(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UUISizeControlByOtherHelper> HelperComp;                                        // 0x019C(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10E3[0x4];                                     // 0x01A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAdditionalHeight(float Value);
	void SetAdditionalWidth(float Value);
	void SetControlHeight(bool Value);
	void SetControlWidth(bool Value);
	void SetTargetActor(class AUIBaseActor* NewTargetActor);

	float GetAdditionalHeight() const;
	float GetAdditionalWidth() const;
	bool GetControlHeight() const;
	bool GetControlWidth() const;
	class AUIBaseActor* GetTargetActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISizeControlByOther">();
	}
	static class UUISizeControlByOther* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISizeControlByOther>();
	}
};
static_assert(alignof(UUISizeControlByOther) == 0x000008, "Wrong alignment on UUISizeControlByOther");
static_assert(sizeof(UUISizeControlByOther) == 0x0001A8, "Wrong size on UUISizeControlByOther");
static_assert(offsetof(UUISizeControlByOther, TargetActor) == 0x000170, "Member 'UUISizeControlByOther::TargetActor' has a wrong offset!");
static_assert(offsetof(UUISizeControlByOther, ControlWidth) == 0x000178, "Member 'UUISizeControlByOther::ControlWidth' has a wrong offset!");
static_assert(offsetof(UUISizeControlByOther, ControlHeight) == 0x000179, "Member 'UUISizeControlByOther::ControlHeight' has a wrong offset!");
static_assert(offsetof(UUISizeControlByOther, UseWidthRange) == 0x00017A, "Member 'UUISizeControlByOther::UseWidthRange' has a wrong offset!");
static_assert(offsetof(UUISizeControlByOther, UseHeightRange) == 0x00017B, "Member 'UUISizeControlByOther::UseHeightRange' has a wrong offset!");
static_assert(offsetof(UUISizeControlByOther, MaxWidth) == 0x00017C, "Member 'UUISizeControlByOther::MaxWidth' has a wrong offset!");
static_assert(offsetof(UUISizeControlByOther, MinWidth) == 0x000180, "Member 'UUISizeControlByOther::MinWidth' has a wrong offset!");
static_assert(offsetof(UUISizeControlByOther, MaxHeight) == 0x000184, "Member 'UUISizeControlByOther::MaxHeight' has a wrong offset!");
static_assert(offsetof(UUISizeControlByOther, MinHeight) == 0x000188, "Member 'UUISizeControlByOther::MinHeight' has a wrong offset!");
static_assert(offsetof(UUISizeControlByOther, AdditionalWidth) == 0x00018C, "Member 'UUISizeControlByOther::AdditionalWidth' has a wrong offset!");
static_assert(offsetof(UUISizeControlByOther, AdditionalHeight) == 0x000190, "Member 'UUISizeControlByOther::AdditionalHeight' has a wrong offset!");
static_assert(offsetof(UUISizeControlByOther, TargetUIItem) == 0x000194, "Member 'UUISizeControlByOther::TargetUIItem' has a wrong offset!");
static_assert(offsetof(UUISizeControlByOther, HelperComp) == 0x00019C, "Member 'UUISizeControlByOther::HelperComp' has a wrong offset!");

// Class LGUI.LGUIPrefabHelperComponent
// 0x0000 (0x0220 - 0x0220)
class ULGUIPrefabHelperComponent final : public USceneComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPrefabHelperComponent">();
	}
	static class ULGUIPrefabHelperComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPrefabHelperComponent>();
	}
};
static_assert(alignof(ULGUIPrefabHelperComponent) == 0x000010, "Wrong alignment on ULGUIPrefabHelperComponent");
static_assert(sizeof(ULGUIPrefabHelperComponent) == 0x000220, "Wrong size on ULGUIPrefabHelperComponent");

// Class LGUI.LGUI_CenterScreenRayemitter
// 0x0008 (0x00F8 - 0x00F0)
class ULGUI_CenterScreenRayemitter final : public ULGUIBaseRayEmitter
{
public:
	uint8                                         Pad_10E4[0x8];                                     // 0x00F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUI_CenterScreenRayemitter">();
	}
	static class ULGUI_CenterScreenRayemitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUI_CenterScreenRayemitter>();
	}
};
static_assert(alignof(ULGUI_CenterScreenRayemitter) == 0x000008, "Wrong alignment on ULGUI_CenterScreenRayemitter");
static_assert(sizeof(ULGUI_CenterScreenRayemitter) == 0x0000F8, "Wrong size on ULGUI_CenterScreenRayemitter");

// Class LGUI.LGUIPrefabV2
// 0x0058 (0x0088 - 0x0030)
class ULGUIPrefabV2 final : public UObject
{
public:
	TArray<class UObject*>                        ReferenceAssetListForBuild;                        // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UClass*>                         ReferenceClassListForBuild;                        // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           ReferenceNameListForBuild;                         // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	EPrefabVersion                                PrefabVersion;                                     // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10E5[0x3];                                     // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  Guid;                                              // 0x0064(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10E6[0x4];                                     // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 BinaryDataForBuild;                                // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	class AActor* LoadPrefab(class UObject* WorldContextObject, class USceneComponent* InParent, bool bForceUseRuntimeData, bool SetRelativeTransformToIdentity);
	class AActor* LoadPrefabWithTransform(class UObject* WorldContextObject, class USceneComponent* InParent, bool bForceUseRuntimeData, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPrefabV2">();
	}
	static class ULGUIPrefabV2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPrefabV2>();
	}
};
static_assert(alignof(ULGUIPrefabV2) == 0x000008, "Wrong alignment on ULGUIPrefabV2");
static_assert(sizeof(ULGUIPrefabV2) == 0x000088, "Wrong size on ULGUIPrefabV2");
static_assert(offsetof(ULGUIPrefabV2, ReferenceAssetListForBuild) == 0x000030, "Member 'ULGUIPrefabV2::ReferenceAssetListForBuild' has a wrong offset!");
static_assert(offsetof(ULGUIPrefabV2, ReferenceClassListForBuild) == 0x000040, "Member 'ULGUIPrefabV2::ReferenceClassListForBuild' has a wrong offset!");
static_assert(offsetof(ULGUIPrefabV2, ReferenceNameListForBuild) == 0x000050, "Member 'ULGUIPrefabV2::ReferenceNameListForBuild' has a wrong offset!");
static_assert(offsetof(ULGUIPrefabV2, PrefabVersion) == 0x000060, "Member 'ULGUIPrefabV2::PrefabVersion' has a wrong offset!");
static_assert(offsetof(ULGUIPrefabV2, Guid) == 0x000064, "Member 'ULGUIPrefabV2::Guid' has a wrong offset!");
static_assert(offsetof(ULGUIPrefabV2, BinaryDataForBuild) == 0x000078, "Member 'ULGUIPrefabV2::BinaryDataForBuild' has a wrong offset!");

// Class LGUI.LGUI_MainViewportMouseRayEmitter
// 0x0008 (0x00F8 - 0x00F0)
class ULGUI_MainViewportMouseRayEmitter final : public ULGUIBaseRayEmitter
{
public:
	uint8                                         Pad_10E9[0x8];                                     // 0x00F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUI_MainViewportMouseRayEmitter">();
	}
	static class ULGUI_MainViewportMouseRayEmitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUI_MainViewportMouseRayEmitter>();
	}
};
static_assert(alignof(ULGUI_MainViewportMouseRayEmitter) == 0x000008, "Wrong alignment on ULGUI_MainViewportMouseRayEmitter");
static_assert(sizeof(ULGUI_MainViewportMouseRayEmitter) == 0x0000F8, "Wrong size on ULGUI_MainViewportMouseRayEmitter");

// Class LGUI.UISelectableGroupComponent
// 0x0030 (0x0130 - 0x0100)
class UUISelectableGroupComponent final : public ULGUIBehaviour
{
public:
	uint8                                         Pad_10EA[0x8];                                     // 0x0100(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          AllowEventBubbleUp;                                // 0x0108(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10EB[0x3];                                     // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UUISelectableComponent>  Selected;                                          // 0x010C(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UUISelectableComponent>  Highlighted;                                       // 0x0114(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10EC[0x4];                                     // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class UUISelectableComponent>> SelectableComponents;                              // 0x0120(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void OnComponentHighlighted(class UUISelectableComponent* Component);
	void OnComponentSelected(class UUISelectableComponent* Component);
	void OnComponentUnhighlighted();
	void OnComponentUnselected();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISelectableGroupComponent">();
	}
	static class UUISelectableGroupComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISelectableGroupComponent>();
	}
};
static_assert(alignof(UUISelectableGroupComponent) == 0x000008, "Wrong alignment on UUISelectableGroupComponent");
static_assert(sizeof(UUISelectableGroupComponent) == 0x000130, "Wrong size on UUISelectableGroupComponent");
static_assert(offsetof(UUISelectableGroupComponent, AllowEventBubbleUp) == 0x000108, "Member 'UUISelectableGroupComponent::AllowEventBubbleUp' has a wrong offset!");
static_assert(offsetof(UUISelectableGroupComponent, Selected) == 0x00010C, "Member 'UUISelectableGroupComponent::Selected' has a wrong offset!");
static_assert(offsetof(UUISelectableGroupComponent, Highlighted) == 0x000114, "Member 'UUISelectableGroupComponent::Highlighted' has a wrong offset!");
static_assert(offsetof(UUISelectableGroupComponent, SelectableComponents) == 0x000120, "Member 'UUISelectableGroupComponent::SelectableComponents' has a wrong offset!");

// Class LGUI.LGUIScaleAdaptation
// 0x0008 (0x0108 - 0x0100)
class ULGUIScaleAdaptation final : public ULGUIBehaviour
{
public:
	float                                         ScaleAdapatationPercent;                           // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartRadio;                                        // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIScaleAdaptation">();
	}
	static class ULGUIScaleAdaptation* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIScaleAdaptation>();
	}
};
static_assert(alignof(ULGUIScaleAdaptation) == 0x000008, "Wrong alignment on ULGUIScaleAdaptation");
static_assert(sizeof(ULGUIScaleAdaptation) == 0x000108, "Wrong size on ULGUIScaleAdaptation");
static_assert(offsetof(ULGUIScaleAdaptation, ScaleAdapatationPercent) == 0x000100, "Member 'ULGUIScaleAdaptation::ScaleAdapatationPercent' has a wrong offset!");
static_assert(offsetof(ULGUIScaleAdaptation, StartRadio) == 0x000104, "Member 'ULGUIScaleAdaptation::StartRadio' has a wrong offset!");

// Class LGUI.LGUIBaseInputModule
// 0x0000 (0x00C0 - 0x00C0)
class ULGUIBaseInputModule : public UActorComponent
{
public:
	void ClearEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIBaseInputModule">();
	}
	static class ULGUIBaseInputModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIBaseInputModule>();
	}
};
static_assert(alignof(ULGUIBaseInputModule) == 0x000008, "Wrong alignment on ULGUIBaseInputModule");
static_assert(sizeof(ULGUIBaseInputModule) == 0x0000C0, "Wrong size on ULGUIBaseInputModule");

// Class LGUI.LGUI_PointerInputModule
// 0x0040 (0x0100 - 0x00C0)
class ULGUI_PointerInputModule : public ULGUIBaseInputModule
{
public:
	class ULGUIEventSystem*                       EventSystem;                                       // 0x00C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10ED[0x38];                                    // 0x00C8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UUIItem* GetNowHitComponent();
	class ULGUIPointerEventData* GetPointerEventData(int32 PointerId, bool CreateIfNotExist);
	void InputNavigation(ELGUINavigationDirection Direction, bool PressOrRelease);
	void InputTriggerForNavigation(bool TriggerPress);
	bool IsPointerEventDataLineTrace(class ULGUIPointerEventData* InPointerEventData);
	struct FLGUIDelegateHandleWrapper RegisterInputChangeEvent(const TDelegate<void(ELGUIPointerInputType Type)>& PointerInputChange);
	void SwitchToNavigationInputType();
	void UnregisterInputChangeEvent(const struct FLGUIDelegateHandleWrapper& DelegateHandle);
	void UpdateNavigation(class USceneComponent* NewSelectable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUI_PointerInputModule">();
	}
	static class ULGUI_PointerInputModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUI_PointerInputModule>();
	}
};
static_assert(alignof(ULGUI_PointerInputModule) == 0x000008, "Wrong alignment on ULGUI_PointerInputModule");
static_assert(sizeof(ULGUI_PointerInputModule) == 0x000100, "Wrong size on ULGUI_PointerInputModule");
static_assert(offsetof(ULGUI_PointerInputModule, EventSystem) == 0x0000C0, "Member 'ULGUI_PointerInputModule::EventSystem' has a wrong offset!");

// Class LGUI.LGUI_SceneCapture2DMouseRayEmitter
// 0x0018 (0x0108 - 0x00F0)
class ULGUI_SceneCapture2DMouseRayEmitter final : public ULGUIBaseRayEmitter
{
public:
	class ASceneCapture2D*                        SceneCaptureActor;                                 // 0x00F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneCaptureComponent2D*               SceneCaptureComp;                                  // 0x00F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10F0[0x8];                                     // 0x0100(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void DeprojectViewPointToWorldForSceneCapture2D(class USceneCaptureComponent2D* InSceneCapture2D, const struct FVector2D& InViewPoint01, struct FVector* OutRayOrigin, struct FVector* OutRayDirection);
	static bool ProjectWorldToViewPointForSceneCapture2D(class USceneCaptureComponent2D* InSceneCapture2D, const struct FVector& InWorldPosition, struct FVector2D* OutViewPoint);

	class USceneCaptureComponent2D* GetSceneCapture2DComponent();
	void SetSceneCapture2DComponent(class USceneCaptureComponent2D* InComp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUI_SceneCapture2DMouseRayEmitter">();
	}
	static class ULGUI_SceneCapture2DMouseRayEmitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUI_SceneCapture2DMouseRayEmitter>();
	}
};
static_assert(alignof(ULGUI_SceneCapture2DMouseRayEmitter) == 0x000008, "Wrong alignment on ULGUI_SceneCapture2DMouseRayEmitter");
static_assert(sizeof(ULGUI_SceneCapture2DMouseRayEmitter) == 0x000108, "Wrong size on ULGUI_SceneCapture2DMouseRayEmitter");
static_assert(offsetof(ULGUI_SceneCapture2DMouseRayEmitter, SceneCaptureActor) == 0x0000F0, "Member 'ULGUI_SceneCapture2DMouseRayEmitter::SceneCaptureActor' has a wrong offset!");
static_assert(offsetof(ULGUI_SceneCapture2DMouseRayEmitter, SceneCaptureComp) == 0x0000F8, "Member 'ULGUI_SceneCapture2DMouseRayEmitter::SceneCaptureComp' has a wrong offset!");

// Class LGUI.LGUI_SceneComponentRayEmitter
// 0x0018 (0x0108 - 0x00F0)
class ULGUI_SceneComponentRayEmitter final : public ULGUIBaseRayEmitter
{
public:
	class AActor*                                 TargetActor;                                       // 0x00F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESceneComponentRayDirection                   RayDirectionType;                                  // 0x00F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ClickThresholdRelateToRayDistance;                 // 0x00F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10F2[0x6];                                     // 0x00FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        CacheTargetSceneComponent;                         // 0x0100(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class AActor* GetTargetActor();
	class USceneComponent* GetTargetSceneComponent();
	void SetTargetActor(class AActor* InActor);
	void SetTargetSceneComponent(class USceneComponent* InSceneComp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUI_SceneComponentRayEmitter">();
	}
	static class ULGUI_SceneComponentRayEmitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUI_SceneComponentRayEmitter>();
	}
};
static_assert(alignof(ULGUI_SceneComponentRayEmitter) == 0x000008, "Wrong alignment on ULGUI_SceneComponentRayEmitter");
static_assert(sizeof(ULGUI_SceneComponentRayEmitter) == 0x000108, "Wrong size on ULGUI_SceneComponentRayEmitter");
static_assert(offsetof(ULGUI_SceneComponentRayEmitter, TargetActor) == 0x0000F0, "Member 'ULGUI_SceneComponentRayEmitter::TargetActor' has a wrong offset!");
static_assert(offsetof(ULGUI_SceneComponentRayEmitter, RayDirectionType) == 0x0000F8, "Member 'ULGUI_SceneComponentRayEmitter::RayDirectionType' has a wrong offset!");
static_assert(offsetof(ULGUI_SceneComponentRayEmitter, ClickThresholdRelateToRayDistance) == 0x0000F9, "Member 'ULGUI_SceneComponentRayEmitter::ClickThresholdRelateToRayDistance' has a wrong offset!");
static_assert(offsetof(ULGUI_SceneComponentRayEmitter, CacheTargetSceneComponent) == 0x000100, "Member 'ULGUI_SceneComponentRayEmitter::CacheTargetSceneComponent' has a wrong offset!");

// Class LGUI.LGUI_ScreenSpaceUIMouseRayemitter
// 0x0010 (0x0100 - 0x00F0)
class ULGUI_ScreenSpaceUIMouseRayemitter final : public ULGUIBaseRayEmitter
{
public:
	uint8                                         Pad_10F3[0x8];                                     // 0x00F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ULGUICanvas*                            RenderCanvas;                                      // 0x00F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUI_ScreenSpaceUIMouseRayemitter">();
	}
	static class ULGUI_ScreenSpaceUIMouseRayemitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUI_ScreenSpaceUIMouseRayemitter>();
	}
};
static_assert(alignof(ULGUI_ScreenSpaceUIMouseRayemitter) == 0x000008, "Wrong alignment on ULGUI_ScreenSpaceUIMouseRayemitter");
static_assert(sizeof(ULGUI_ScreenSpaceUIMouseRayemitter) == 0x000100, "Wrong size on ULGUI_ScreenSpaceUIMouseRayemitter");
static_assert(offsetof(ULGUI_ScreenSpaceUIMouseRayemitter, RenderCanvas) == 0x0000F8, "Member 'ULGUI_ScreenSpaceUIMouseRayemitter::RenderCanvas' has a wrong offset!");

// Class LGUI.LGUI_StandaloneInputModule
// 0x0020 (0x0120 - 0x0100)
class ULGUI_StandaloneInputModule final : public ULGUI_PointerInputModule
{
public:
	bool                                          bOverrideMousePosition;                            // 0x0100(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10F4[0x1F];                                    // 0x0101(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EInputKeyType GetCurrentInputKeyType();
	void InputOverrideMousePosition(const struct FVector2D& InMousePosition);
	void InputScroll(const float& InAxisValue);
	void InputTrigger(bool InTriggerPress, EMouseButtonType InMouseButtonType);
	void ResetNowIsTriggerPressed(int32 PointerID);
	void SetCurrentInputKeyType(EInputKeyType InputKeyType);
	void SetIsForceChange(const bool Value);
	void SetIsUseMouse(const bool Value);
	bool SimulationLineTrace(int32 PointerID, class UUIItem* UIItem, const struct FVector2D& ClickPivot);
	bool SimulationPointerDownUp(int32 PointerID, class UUIItem* UIItem, bool IsPressed, const struct FVector2D& ClickPivot);
	void SimulationPointerTrigger(int32 PointerID, bool IsPressed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUI_StandaloneInputModule">();
	}
	static class ULGUI_StandaloneInputModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUI_StandaloneInputModule>();
	}
};
static_assert(alignof(ULGUI_StandaloneInputModule) == 0x000008, "Wrong alignment on ULGUI_StandaloneInputModule");
static_assert(sizeof(ULGUI_StandaloneInputModule) == 0x000120, "Wrong size on ULGUI_StandaloneInputModule");
static_assert(offsetof(ULGUI_StandaloneInputModule, bOverrideMousePosition) == 0x000100, "Member 'ULGUI_StandaloneInputModule::bOverrideMousePosition' has a wrong offset!");

// Class LGUI.LGUI_TouchInputModule
// 0x0000 (0x0100 - 0x0100)
class ULGUI_TouchInputModule final : public ULGUI_PointerInputModule
{
public:
	void InputScroll(const float& InAxisValue);
	void InputTouchMoved(int32 InTouchID, const struct FVector& InTouchPointPosition);
	void InputTouchTrigger(bool InTouchPress, int32 InTouchID, const struct FVector& InTouchPointPosition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUI_TouchInputModule">();
	}
	static class ULGUI_TouchInputModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUI_TouchInputModule>();
	}
};
static_assert(alignof(ULGUI_TouchInputModule) == 0x000008, "Wrong alignment on ULGUI_TouchInputModule");
static_assert(sizeof(ULGUI_TouchInputModule) == 0x000100, "Wrong size on ULGUI_TouchInputModule");

// Class LGUI.LGUIBaseRaycaster
// 0x0030 (0x0250 - 0x0220)
class ULGUIBaseRaycaster : public USceneComponent
{
public:
	uint8                                         Pad_10FC[0x20];                                    // 0x0218(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Depth;                                             // 0x0238(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RayLength;                                         // 0x023C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               TraceChannel;                                      // 0x0240(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELGUIEventFireType                            EventFireType;                                     // 0x0241(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10FD[0x6];                                     // 0x0242(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ULGUIBaseRayEmitter*                    RayEmitter;                                        // 0x0248(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ActivateRaycaster();
	void DeactivateRaycaster();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIBaseRaycaster">();
	}
	static class ULGUIBaseRaycaster* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIBaseRaycaster>();
	}
};
static_assert(alignof(ULGUIBaseRaycaster) == 0x000010, "Wrong alignment on ULGUIBaseRaycaster");
static_assert(sizeof(ULGUIBaseRaycaster) == 0x000250, "Wrong size on ULGUIBaseRaycaster");
static_assert(offsetof(ULGUIBaseRaycaster, Depth) == 0x000238, "Member 'ULGUIBaseRaycaster::Depth' has a wrong offset!");
static_assert(offsetof(ULGUIBaseRaycaster, RayLength) == 0x00023C, "Member 'ULGUIBaseRaycaster::RayLength' has a wrong offset!");
static_assert(offsetof(ULGUIBaseRaycaster, TraceChannel) == 0x000240, "Member 'ULGUIBaseRaycaster::TraceChannel' has a wrong offset!");
static_assert(offsetof(ULGUIBaseRaycaster, EventFireType) == 0x000241, "Member 'ULGUIBaseRaycaster::EventFireType' has a wrong offset!");
static_assert(offsetof(ULGUIBaseRaycaster, RayEmitter) == 0x000248, "Member 'ULGUIBaseRaycaster::RayEmitter' has a wrong offset!");

// Class LGUI.LGUI_UIRaycaster
// 0x0020 (0x0270 - 0x0250)
#pragma pack(push, 0x1)
class alignas(0x10) ULGUI_UIRaycaster : public ULGUIBaseRaycaster
{
public:
	uint8                                         Pad_10FE[0x10];                                    // 0x0250(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EUIRaycastSortType                            UiSortType;                                        // 0x0260(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10FF[0x3];                                     // 0x0261(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UiSortDependOnDistanceThreshold;                   // 0x0264(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUI_UIRaycaster">();
	}
	static class ULGUI_UIRaycaster* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUI_UIRaycaster>();
	}
};
#pragma pack(pop)
static_assert(alignof(ULGUI_UIRaycaster) == 0x000010, "Wrong alignment on ULGUI_UIRaycaster");
static_assert(sizeof(ULGUI_UIRaycaster) == 0x000270, "Wrong size on ULGUI_UIRaycaster");
static_assert(offsetof(ULGUI_UIRaycaster, UiSortType) == 0x000260, "Member 'ULGUI_UIRaycaster::UiSortType' has a wrong offset!");
static_assert(offsetof(ULGUI_UIRaycaster, UiSortDependOnDistanceThreshold) == 0x000264, "Member 'ULGUI_UIRaycaster::UiSortDependOnDistanceThreshold' has a wrong offset!");

// Class LGUI.LGUI_WorldRaycaster
// 0x0010 (0x0260 - 0x0250)
class ULGUI_WorldRaycaster : public ULGUIBaseRaycaster
{
public:
	uint8                                         Pad_1100[0x10];                                    // 0x0250(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUI_WorldRaycaster">();
	}
	static class ULGUI_WorldRaycaster* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUI_WorldRaycaster>();
	}
};
static_assert(alignof(ULGUI_WorldRaycaster) == 0x000010, "Wrong alignment on ULGUI_WorldRaycaster");
static_assert(sizeof(ULGUI_WorldRaycaster) == 0x000260, "Wrong size on ULGUI_WorldRaycaster");

// Class LGUI.LGUIAtlasManager
// 0x0058 (0x0088 - 0x0030)
class ULGUIAtlasManager final : public UObject
{
public:
	TMap<class FName, struct FLGUIAtlasData>      AtlasMap;                                          // 0x0030(0x0050)(Edit, Transient, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1101[0x8];                                     // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void DisposeAtlasByPackingTag(class FName InPackingTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIAtlasManager">();
	}
	static class ULGUIAtlasManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIAtlasManager>();
	}
};
static_assert(alignof(ULGUIAtlasManager) == 0x000008, "Wrong alignment on ULGUIAtlasManager");
static_assert(sizeof(ULGUIAtlasManager) == 0x000088, "Wrong size on ULGUIAtlasManager");
static_assert(offsetof(ULGUIAtlasManager, AtlasMap) == 0x000030, "Member 'ULGUIAtlasManager::AtlasMap' has a wrong offset!");

// Class LGUI.LGUIBaseEventData
// 0x0010 (0x0040 - 0x0030)
class ULGUIBaseEventData : public UObject
{
public:
	class USceneComponent*                        SelectedComponent;                                 // 0x0030(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPointerEventType                             EventType;                                         // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1102[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString ToString() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIBaseEventData">();
	}
	static class ULGUIBaseEventData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIBaseEventData>();
	}
};
static_assert(alignof(ULGUIBaseEventData) == 0x000008, "Wrong alignment on ULGUIBaseEventData");
static_assert(sizeof(ULGUIBaseEventData) == 0x000040, "Wrong size on ULGUIBaseEventData");
static_assert(offsetof(ULGUIBaseEventData, SelectedComponent) == 0x000030, "Member 'ULGUIBaseEventData::SelectedComponent' has a wrong offset!");
static_assert(offsetof(ULGUIBaseEventData, EventType) == 0x000038, "Member 'ULGUIBaseEventData::EventType' has a wrong offset!");

// Class LGUI.LGUIBPLibrary
// 0x0000 (0x0030 - 0x0030)
class ULGUIBPLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class ULTweener* AlphaFrom(class UUIItem* Target, float StartValue, float Duration, float Delay, ELTweenEase Ease);
	static class ULTweener* AlphaTo(class UUIItem* Target, float EndValue, float Duration, float Delay, ELTweenEase Ease);
	static class ULTweener* AnchorOffsetTo(class UUIItem* Target, const struct FVector2D& EndValue, float Duration, float Delay, ELTweenEase Ease);
	static class ULTweener* AnchorOffsetXTo(class UUIItem* Target, float EndValue, float Duration, float Delay, ELTweenEase Ease);
	static class ULTweener* AnchorOffsetYTo(class UUIItem* Target, float EndValue, float Duration, float Delay, ELTweenEase Ease);
	static TArray<class AActor*> BatchDuplicateActors(class AActor* Src, int32 Num, class USceneComponent* Parent);
	static void ClipBoardCopy(const class FString& Str);
	static void ClipBoardPaste(class FString* Target);
	static class ULTweener* ColorFrom(class UUIItem* Target, const struct FColor& StartValue, float Duration, float Delay, ELTweenEase Ease);
	static class ULTweener* ColorTo(class UUIItem* Target, const struct FColor& EndValue, float Duration, float Delay, ELTweenEase Ease);
	static void CopySequenceBindingFromParent(class UUIItem* Target, const struct FSoftObjectPath& LevelSequencePath);
	static class UTexture2D* CreateTransientTexture2D(float Width, float Height, class FName InName);
	static void DeleteActor(class AActor* Target, bool WithHierarchy);
	static bool DeleteFile(const class FString& Path);
	static void DestroyActorWithHierarchy(class AActor* Target, bool WithHierarchy);
	static class AActor* DuplicateActor(class AActor* Target, class USceneComponent* Parent);
	static void FreeUnusedResourcesInRenderTargetPool();
	static TArray<class AActor*> GetAllAttachChildrenOfActor(class AActor* Actor, bool bIncludeAllChildren);
	static class UActorComponent* GetComponentInChildren(class AActor* InActor, TSubclassOf<class UActorComponent> ComponentClass, bool IncludeSelf);
	static class UActorComponent* GetComponentInParent(class AActor* InActor, TSubclassOf<class UActorComponent> ComponentClass, bool IncludeSelf);
	static TArray<class UActorComponent*> GetComponentsInChildren(class AActor* InActor, TSubclassOf<class UActorComponent> ComponentClass, bool IncludeSelf);
	static TArray<class UActorComponent*> GetComponentsInChildrenWithHirerarchyIndex(class AUIBaseActor* InActor, TSubclassOf<class UActorComponent> ComponentClass, bool IncludeSelf);
	static bool GetFullPathOfActor(class UObject* WorldContextObject, class AActor* Actor, class FString* PathString);
	static class UUIItem* GetPrefabRoot(class UUIItem* InUiItem);
	static class FString GetRelativePathWithRoot(class UUIItem* Target, class UUIItem* Root);
	static void GetSpriteBorderSize(const struct FLGUISpriteInfo& SpriteInfo, int32* borderLeft, int32* borderRight, int32* borderTop, int32* borderBottom);
	static void GetSpriteBorderUV(const struct FLGUISpriteInfo& SpriteInfo, float* borderUV0X, float* borderUV0Y, float* borderUV3X, float* borderUV3Y);
	static void GetSpriteSize(const struct FLGUISpriteInfo& SpriteInfo, int32* Width, int32* Height);
	static void GetSpriteUV(const struct FLGUISpriteInfo& SpriteInfo, float* UV0X, float* UV0Y, float* UV3X, float* UV3Y);
	static int64 GetStringHashValue(const class FString& Str);
	static struct FVector2D GetUIItemCornerPositionInViewPort(EUiItemCornerType Corner, class UObject* WorldContextObject, class UUIItem* Item);
	static struct FVector2D GetUIItemPositionInViewPort(class UObject* WorldContextObject, class UUIItem* Item, bool bIsScaledByBPI);
	static class UUIItem* GetUIItemWithPath(class UObject* WorldContextObject, const class FString& FullItemPath);
	static class UUIItem* GetUIItemWithRelativePath(class UUIItem* ParentItem, const class FString& RelativePath);
	static bool GetWorldUISceneRendering(class UObject* WorldContextObject);
	static class ULTweener* HeightTo(class UUIItem* Target, float EndValue, float Duration, float Delay, ELTweenEase Ease);
	static void K2_LGUICompRef_GetComponent(const struct FLGUIComponentReference& InLGUICompRef, class UActorComponent** OutResult);
	static class AActor* LGUICompRef_GetActor(const struct FLGUIComponentReference& InLGUIComponentReference);
	static class UActorComponent* LGUICompRef_GetComponent(const struct FLGUIComponentReference& InLGUIComponentReference, TSubclassOf<class UActorComponent> InComponentType);
	static TSubclassOf<class UActorComponent> LGUICompRef_GetComponentClass(const struct FLGUIComponentReference& InLGUIComponentReference);
	static void LGUIDrawableEvent_Actor_Execute(const struct FLGUIDrawableEvent_Actor& InEvent, class AActor* InParameter);
	static struct FLGUIDelegateHandleWrapper LGUIDrawableEvent_Actor_Register(const struct FLGUIDrawableEvent_Actor& InEvent, TDelegate<void(class AActor* Value)> InDelegate);
	static void LGUIDrawableEvent_Actor_Unregister(const struct FLGUIDrawableEvent_Actor& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIDrawableEvent_Bool_Execute(const struct FLGUIDrawableEvent_Bool& InEvent, bool InParameter);
	static struct FLGUIDelegateHandleWrapper LGUIDrawableEvent_Bool_Register(const struct FLGUIDrawableEvent_Bool& InEvent, TDelegate<void(bool Value)> InDelegate);
	static void LGUIDrawableEvent_Bool_Unregister(const struct FLGUIDrawableEvent_Bool& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIDrawableEvent_Class_Execute(const struct FLGUIDrawableEvent_Class& InEvent, class UClass* InParameter);
	static struct FLGUIDelegateHandleWrapper LGUIDrawableEvent_Class_Register(const struct FLGUIDrawableEvent_Class& InEvent, TDelegate<void(class UClass* Value)> InDelegate);
	static void LGUIDrawableEvent_Class_Unregister(const struct FLGUIDrawableEvent_Class& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIDrawableEvent_Color_Execute(const struct FLGUIDrawableEvent_Color& InEvent, const struct FColor& InParameter);
	static struct FLGUIDelegateHandleWrapper LGUIDrawableEvent_Color_Register(const struct FLGUIDrawableEvent_Color& InEvent, TDelegate<void(const struct FColor& Value)> InDelegate);
	static void LGUIDrawableEvent_Color_Unregister(const struct FLGUIDrawableEvent_Color& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIDrawableEvent_Empty_Execute(const struct FLGUIDrawableEvent_Empty& InEvent);
	static struct FLGUIDelegateHandleWrapper LGUIDrawableEvent_Empty_Register(const struct FLGUIDrawableEvent_Empty& InEvent, TDelegate<void()> InDelegate);
	static void LGUIDrawableEvent_Empty_Unregister(const struct FLGUIDrawableEvent_Empty& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIDrawableEvent_Float_Execute(const struct FLGUIDrawableEvent_Float& InEvent, float InParameter);
	static struct FLGUIDelegateHandleWrapper LGUIDrawableEvent_Float_Register(const struct FLGUIDrawableEvent_Float& InEvent, TDelegate<void(float Value)> InDelegate);
	static void LGUIDrawableEvent_Float_Unregister(const struct FLGUIDrawableEvent_Float& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIDrawableEvent_Int32_Execute(const struct FLGUIDrawableEvent_Int32& InEvent, int32 InParameter);
	static struct FLGUIDelegateHandleWrapper LGUIDrawableEvent_Int32_Register(const struct FLGUIDrawableEvent_Int32& InEvent, TDelegate<void(int32 Value)> InDelegate);
	static void LGUIDrawableEvent_Int32_Unregister(const struct FLGUIDrawableEvent_Int32& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIDrawableEvent_Int64_Execute(const struct FLGUIDrawableEvent_Int64& InEvent, int64 InParameter);
	static struct FLGUIDelegateHandleWrapper LGUIDrawableEvent_Int64_Register(const struct FLGUIDrawableEvent_Int64& InEvent, TDelegate<void(int64 Value)> InDelegate);
	static void LGUIDrawableEvent_Int64_Unregister(const struct FLGUIDrawableEvent_Int64& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIDrawableEvent_LinearColor_Execute(const struct FLGUIDrawableEvent_LinearColor& InEvent, const struct FLinearColor& InParameter);
	static struct FLGUIDelegateHandleWrapper LGUIDrawableEvent_LinearColor_Register(const struct FLGUIDrawableEvent_LinearColor& InEvent, TDelegate<void(const struct FLinearColor& Value)> InDelegate);
	static void LGUIDrawableEvent_LinearColor_Unregister(const struct FLGUIDrawableEvent_LinearColor& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIDrawableEvent_Object_Execute(const struct FLGUIDrawableEvent_Object& InEvent, class UObject* InParameter);
	static struct FLGUIDelegateHandleWrapper LGUIDrawableEvent_Object_Register(const struct FLGUIDrawableEvent_Object& InEvent, TDelegate<void(class UObject* Value)> InDelegate);
	static void LGUIDrawableEvent_Object_Unregister(const struct FLGUIDrawableEvent_Object& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIDrawableEvent_PointerEvent_Execute(const struct FLGUIDrawableEvent_PointerEvent& InEvent, class ULGUIPointerEventData* InParameter);
	static struct FLGUIDelegateHandleWrapper LGUIDrawableEvent_PointerEvent_Register(const struct FLGUIDrawableEvent_PointerEvent& InEvent, TDelegate<void(class ULGUIPointerEventData* Value)> InDelegate);
	static void LGUIDrawableEvent_PointerEvent_Unregister(const struct FLGUIDrawableEvent_PointerEvent& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIDrawableEvent_Quaternion_Execute(const struct FLGUIDrawableEvent_Quaternion& InEvent, const struct FQuat& InParameter);
	static struct FLGUIDelegateHandleWrapper LGUIDrawableEvent_Quaternion_Register(const struct FLGUIDrawableEvent_Quaternion& InEvent, TDelegate<void(const struct FQuat& Value)> InDelegate);
	static void LGUIDrawableEvent_Quaternion_Unregister(const struct FLGUIDrawableEvent_Quaternion& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIDrawableEvent_Rotator_Execute(const struct FLGUIDrawableEvent_Rotator& InEvent, const struct FRotator& InParameter);
	static struct FLGUIDelegateHandleWrapper LGUIDrawableEvent_Rotator_Register(const struct FLGUIDrawableEvent_Rotator& InEvent, TDelegate<void(const struct FRotator& Value)> InDelegate);
	static void LGUIDrawableEvent_Rotator_Unregister(const struct FLGUIDrawableEvent_Rotator& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIDrawableEvent_String_Execute(const struct FLGUIDrawableEvent_String& InEvent, const class FString& InParameter);
	static struct FLGUIDelegateHandleWrapper LGUIDrawableEvent_String_Register(const struct FLGUIDrawableEvent_String& InEvent, TDelegate<void(const class FString& Value)> InDelegate);
	static void LGUIDrawableEvent_String_Unregister(const struct FLGUIDrawableEvent_String& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIDrawableEvent_UInt8_Execute(const struct FLGUIDrawableEvent_UInt8& InEvent, uint8 InParameter);
	static struct FLGUIDelegateHandleWrapper LGUIDrawableEvent_UInt8_Register(const struct FLGUIDrawableEvent_UInt8& InEvent, TDelegate<void(uint8 Value)> InDelegate);
	static void LGUIDrawableEvent_UInt8_Unregister(const struct FLGUIDrawableEvent_UInt8& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIDrawableEvent_Vector2_Execute(const struct FLGUIDrawableEvent_Vector2& InEvent, const struct FVector2D& InParameter);
	static struct FLGUIDelegateHandleWrapper LGUIDrawableEvent_Vector2_Register(const struct FLGUIDrawableEvent_Vector2& InEvent, TDelegate<void(const struct FVector2D& Value)> InDelegate);
	static void LGUIDrawableEvent_Vector2_Unregister(const struct FLGUIDrawableEvent_Vector2& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIDrawableEvent_Vector3_Execute(const struct FLGUIDrawableEvent_Vector3& InEvent, const struct FVector& InParameter);
	static struct FLGUIDelegateHandleWrapper LGUIDrawableEvent_Vector3_Register(const struct FLGUIDrawableEvent_Vector3& InEvent, TDelegate<void(const struct FVector& Value)> InDelegate);
	static void LGUIDrawableEvent_Vector3_Unregister(const struct FLGUIDrawableEvent_Vector3& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIDrawableEvent_Vector4_Execute(const struct FLGUIDrawableEvent_Vector4& InEvent, const struct FVector4& InParameter);
	static struct FLGUIDelegateHandleWrapper LGUIDrawableEvent_Vector4_Register(const struct FLGUIDrawableEvent_Vector4& InEvent, TDelegate<void(const struct FVector4& Value)> InDelegate);
	static void LGUIDrawableEvent_Vector4_Unregister(const struct FLGUIDrawableEvent_Vector4& InEvent, const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	static void LGUIDrawableEventExecuteActor(const struct FLGUIDrawableEvent& InEvent, class AActor* InParameter);
	static void LGUIDrawableEventExecuteBool(const struct FLGUIDrawableEvent& InEvent, const bool& InParameter);
	static void LGUIDrawableEventExecuteClass(const struct FLGUIDrawableEvent& InEvent, class UClass* InParameter);
	static void LGUIDrawableEventExecuteColor(const struct FLGUIDrawableEvent& InEvent, const struct FColor& InParameter);
	static void LGUIDrawableEventExecuteEmpty(const struct FLGUIDrawableEvent& InEvent);
	static void LGUIDrawableEventExecuteFloat(const struct FLGUIDrawableEvent& InEvent, const float& InParameter);
	static void LGUIDrawableEventExecuteInt32(const struct FLGUIDrawableEvent& InEvent, const int32& InParameter);
	static void LGUIDrawableEventExecuteLinearColor(const struct FLGUIDrawableEvent& InEvent, const struct FLinearColor& InParameter);
	static void LGUIDrawableEventExecuteObject(const struct FLGUIDrawableEvent& InEvent, class UObject* InParameter);
	static void LGUIDrawableEventExecutePointerEvent(const struct FLGUIDrawableEvent& InEvent, class ULGUIPointerEventData* InParameter);
	static void LGUIDrawableEventExecuteQuaternion(const struct FLGUIDrawableEvent& InEvent, const struct FQuat& InParameter);
	static void LGUIDrawableEventExecuteRotator(const struct FLGUIDrawableEvent& InEvent, const struct FRotator& InParameter);
	static void LGUIDrawableEventExecuteString(const struct FLGUIDrawableEvent& InEvent, const class FString& InParameter);
	static void LGUIDrawableEventExecuteUInt8(const struct FLGUIDrawableEvent& InEvent, const uint8& InParameter);
	static void LGUIDrawableEventExecuteVector2(const struct FLGUIDrawableEvent& InEvent, const struct FVector2D& InParameter);
	static void LGUIDrawableEventExecuteVector3(const struct FLGUIDrawableEvent& InEvent, const struct FVector& InParameter);
	static void LGUIDrawableEventExecuteVector4(const struct FLGUIDrawableEvent& InEvent, const struct FVector4& InParameter);
	static void LGUIExecuteControllerInputAction(const struct FKey& InputKey, bool PressOrRelease);
	static void LGUIExecuteControllerInputAxis(const struct FKey& InputKey, float Value);
	static void LGUIExecuteInputAction(const struct FKey& InputKey, bool PressOrRelease);
	static void LGUIExecuteInputAxis(const struct FKey& InputKey, float Value);
	static void LoadImageToTexture2D(const class FString& ImagePath, class UTexture2D* Texture);
	static class AActor* LoadPrefabWithAsset(class UObject* WorldContextObject, class UPrefabAsset* PrefabAsset, class USceneComponent* InParent);
	static class ULTweener* PivotTo(class UUIItem* Target, const struct FVector2D& EndValue, float Duration, float Delay, ELTweenEase Ease);
	static void PrintUIItemLog(const class FString& Content, class UUIItem* UIItem, int32 LogDepth);
	static void ResetGlobalBlurUIItem(class UWorld* World);
	static void SetGlobalBlurUIItem(class UUIItem* UIItem, class UWorld* World);
	static void SetIsFullScreenUIRendering(class UObject* WorldContextObject, bool Value);
	static void SetLGUIUISceneRendering(class AActor* Actor, bool IsUISceneRendering);
	static void SetUIActive(class AActor* Target, bool Acitve);
	static void SetUIAlpha(class AActor* Target, float InAlpha);
	static void SetUIHierarchyIndex(class AActor* Target, int32 Param_Index);
	static class ULGUIPointerEventData* SimulationLineTrace(const struct FVector2D& Pos, class UObject* WorldContext, TArray<class UUIItem*>* TraceOnlyItems);
	static class ULGUIPointerEventData* SimulationLineTraceOnCenterScreen(class UObject* WorldContext, TArray<class UUIItem*>* TraceOnlyItems);
	static class ULTweener* StretchBottomTo(class UUIItem* Target, float EndValue, float Duration, float Delay, ELTweenEase Ease);
	static class ULTweener* StretchLeftTo(class UUIItem* Target, float EndValue, float Duration, float Delay, ELTweenEase Ease);
	static class ULTweener* StretchRightTo(class UUIItem* Target, float EndValue, float Duration, float Delay, ELTweenEase Ease);
	static class ULTweener* StretchTopTo(class UUIItem* Target, float EndValue, float Duration, float Delay, ELTweenEase Ease);
	static class ULTweener* UILocalPositionTo(class UUIItem* Target, const struct FVector& EndValue, float Duration, float Delay, ELTweenEase Ease);
	static class ULTweener* WidthTo(class UUIItem* Target, float EndValue, float Duration, float Delay, ELTweenEase Ease);

	void SetWorldUISceneRendering(bool Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIBPLibrary">();
	}
	static class ULGUIBPLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIBPLibrary>();
	}
};
static_assert(alignof(ULGUIBPLibrary) == 0x000008, "Wrong alignment on ULGUIBPLibrary");
static_assert(sizeof(ULGUIBPLibrary) == 0x000030, "Wrong size on ULGUIBPLibrary");

// Class LGUI.LGUICanvas
// 0x0260 (0x0320 - 0x00C0)
class alignas(0x10) ULGUICanvas final : public UActorComponent
{
public:
	uint8                                         Pad_113B[0x20];                                    // 0x00C0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  RootCanvasActor;                                   // 0x00E0(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_113C[0x98];                                    // 0x00E8(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	ELGUIRenderMode                               RenderMode;                                        // 0x0180(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_113D[0x7];                                     // 0x0181(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x0188(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          PixelPerfect;                                      // 0x0190(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_113E[0x3];                                     // 0x0191(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CanvasDepth;                                       // 0x0194(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_113F[0x4];                                     // 0x0198(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SortOrder;                                         // 0x019C(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AdditionalSortOrder;                               // 0x01A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideSortOrder;                                // 0x01A4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELGUICanvasClipType                           ClipType;                                          // 0x01A5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1140[0x2];                                     // 0x01A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ClipFeather;                                       // 0x01A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                ClipRectOffset;                                    // 0x01B0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UTexture*                               ClipTexture;                                       // 0x01C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ClipTextureAlpha;                                  // 0x01C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          InheritRectClip;                                   // 0x01CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFlipClipArea;                                     // 0x01CD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClipWithRectOp;                                   // 0x01CE(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1141[0x1];                                     // 0x01CF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DynamicPixelsPerUnit;                              // 0x01D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int8                                          AdditionalShaderChannels;                          // 0x01D4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1142[0x3];                                     // 0x01D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     DefaultMaterials[0x3];                             // 0x01D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          OwnerNoSee;                                        // 0x01F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          OnlyOwnerSee;                                      // 0x01F1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int8                                          OverrideParameters;                                // 0x01F2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1143[0x4D];                                    // 0x01F3(0x004D)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class UUIBaseRenderable*>                RenderableSet;                                     // 0x0240(0x0050)(Edit, ExportObject, Transient, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UUIBaseRenderable*>              ToRenderList;                                      // 0x0290(0x0010)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1144[0x60];                                    // 0x02A0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLGUIMaterialArrayContainer>    PooledUIMaterialList;                              // 0x0300(0x0010)(Edit, ZeroConstructor, Transient, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         IsUiScenePrimitive : 1;                            // 0x0310(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bPostTickUpdate;                                   // 0x0311(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1145[0xE];                                     // 0x0312(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	ELGUICanvasClipType GetActualClipType();
	float GetActualDynamicPixelsPerUnit();
	bool GetActualOnlyOwnerSee();
	bool GetActualOwnerNoSee();
	bool GetActualPixelPerfect();
	ELGUIRenderMode GetActualRenderMode();
	class UTextureRenderTarget2D* GetActualRenderTarget();
	struct FVector2D GetClipRectMax();
	struct FVector2D GetClipRectMin();
	bool GetRequireNormal();
	bool GetRequireTangent();
	bool GetRequireUV1();
	bool GetRequireUV2();
	bool GetRequireUV3();
	class ULGUICanvas* GetRootCanvas();
	struct FIntPoint GetViewportSize();
	bool IsUIVisible(class UUIItem* HitUI);
	void SetClipTexture(class UTexture* NewTexture);
	void SetClipTextureAlpha(float NewAlpha);
	void SetClipType(ELGUICanvasClipType NewClipType);
	void SetDynamicPixelsPerUnit(float NewValue);
	void SetInheriRectClip(bool NewBool);
	void SetOnlyOwnerSee(bool Value);
	void SetOwnerNoSee(bool Value);
	void SetPixelPerfect(bool Value);
	void SetProjectionParameters(ECameraProjectionMode InProjectionType, float InFovAngle, float InNearClipPlane, float InFarClipPlane);
	void SetRectClipFeather(const struct FVector2D& NewFeather);
	void SetRectClipOffset(const struct FMargin& NewOffset);
	void SetRenderMode(ELGUIRenderMode Value);
	void SetRenderTarget(class UTextureRenderTarget2D* Value);
	void SetSortOrder(int32 NewValue, bool PropagateToChildrenCanvas);
	void SetSortOrderToHighestOfHierarchy(bool PropagateToChildrenCanvas);

	struct FVector2D GetClipFeather() const;
	class UTexture* GetClipTexture() const;
	float GetClipTextureAlpha() const;
	ELGUICanvasClipType GetClipType() const;
	float GetDynamicPixelsPerUnit() const;
	bool GetInheritRectClip() const;
	bool GetOnlyOwnerSee() const;
	bool GetOwnerNoSee() const;
	bool GetPixelPerfect() const;
	ELGUIRenderMode GetRenderMode() const;
	class UTextureRenderTarget2D* GetRenderTarget() const;
	bool IsPostTickUpdate() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUICanvas">();
	}
	static class ULGUICanvas* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUICanvas>();
	}
};
static_assert(alignof(ULGUICanvas) == 0x000010, "Wrong alignment on ULGUICanvas");
static_assert(sizeof(ULGUICanvas) == 0x000320, "Wrong size on ULGUICanvas");
static_assert(offsetof(ULGUICanvas, RootCanvasActor) == 0x0000E0, "Member 'ULGUICanvas::RootCanvasActor' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, RenderMode) == 0x000180, "Member 'ULGUICanvas::RenderMode' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, RenderTarget) == 0x000188, "Member 'ULGUICanvas::RenderTarget' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, PixelPerfect) == 0x000190, "Member 'ULGUICanvas::PixelPerfect' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, CanvasDepth) == 0x000194, "Member 'ULGUICanvas::CanvasDepth' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, SortOrder) == 0x00019C, "Member 'ULGUICanvas::SortOrder' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, AdditionalSortOrder) == 0x0001A0, "Member 'ULGUICanvas::AdditionalSortOrder' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, bOverrideSortOrder) == 0x0001A4, "Member 'ULGUICanvas::bOverrideSortOrder' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, ClipType) == 0x0001A5, "Member 'ULGUICanvas::ClipType' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, ClipFeather) == 0x0001A8, "Member 'ULGUICanvas::ClipFeather' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, ClipRectOffset) == 0x0001B0, "Member 'ULGUICanvas::ClipRectOffset' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, ClipTexture) == 0x0001C0, "Member 'ULGUICanvas::ClipTexture' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, ClipTextureAlpha) == 0x0001C8, "Member 'ULGUICanvas::ClipTextureAlpha' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, InheritRectClip) == 0x0001CC, "Member 'ULGUICanvas::InheritRectClip' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, bFlipClipArea) == 0x0001CD, "Member 'ULGUICanvas::bFlipClipArea' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, bClipWithRectOp) == 0x0001CE, "Member 'ULGUICanvas::bClipWithRectOp' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, DynamicPixelsPerUnit) == 0x0001D0, "Member 'ULGUICanvas::DynamicPixelsPerUnit' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, AdditionalShaderChannels) == 0x0001D4, "Member 'ULGUICanvas::AdditionalShaderChannels' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, DefaultMaterials) == 0x0001D8, "Member 'ULGUICanvas::DefaultMaterials' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, OwnerNoSee) == 0x0001F0, "Member 'ULGUICanvas::OwnerNoSee' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, OnlyOwnerSee) == 0x0001F1, "Member 'ULGUICanvas::OnlyOwnerSee' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, OverrideParameters) == 0x0001F2, "Member 'ULGUICanvas::OverrideParameters' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, RenderableSet) == 0x000240, "Member 'ULGUICanvas::RenderableSet' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, ToRenderList) == 0x000290, "Member 'ULGUICanvas::ToRenderList' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, PooledUIMaterialList) == 0x000300, "Member 'ULGUICanvas::PooledUIMaterialList' has a wrong offset!");
static_assert(offsetof(ULGUICanvas, bPostTickUpdate) == 0x000311, "Member 'ULGUICanvas::bPostTickUpdate' has a wrong offset!");

// Class LGUI.LGUICanvasScaler
// 0x0068 (0x0128 - 0x00C0)
class ULGUICanvasScaler final : public UActorComponent
{
public:
	uint8                                         Pad_1149[0x20];                                    // 0x00C0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	ECameraProjectionMode                         ProjectionType;                                    // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_114A[0x3];                                     // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FOVAngle;                                          // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NearClipPlane;                                     // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FarClipPlane;                                      // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELGUIScaleMode                                UIScaleMode;                                       // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_114B[0x3];                                     // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ReferenceResolution;                               // 0x00F4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MatchFromWidthToHeight;                            // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELGUIScreenMatchMode                          ScreenMatchMode;                                   // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_114C[0x7];                                     // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULGUICanvas*                            Canvas;                                            // 0x0108(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_114D[0x18];                                    // 0x0110(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetMatchFromWidthToHeight();
	struct FVector2D GetReferenceResolution();
	ELGUIScreenMatchMode GetScreenMatchMode();
	ELGUIScaleMode GetUIScaleMode();
	void SetFarClipPlane(float Value);
	void SetFovAngle(float Value);
	void SetMatchFromWidthToHeight(float Value);
	void SetNearClipPlane(float Value);
	void SetProjectionType(ECameraProjectionMode Value);
	void SetReferenceResolution(const struct FVector2D& Value);
	void SetScreenMatchMode(ELGUIScreenMatchMode Value);
	void SetUIScaleMode(ELGUIScaleMode Value);

	struct FVector2D ConvertPositionFromLGUICanvasToViewport(const struct FVector2D& Position) const;
	struct FVector2D ConvertPositionFromViewportToLGUICanvas(const struct FVector2D& Position) const;
	float GetFarClipPlane() const;
	float GetFovAngle() const;
	float GetNearClipPlane() const;
	ECameraProjectionMode GetProjectionType() const;
	bool Project3DToScreen(const struct FVector& Position3D, struct FVector2D* OutPosition2D) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUICanvasScaler">();
	}
	static class ULGUICanvasScaler* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUICanvasScaler>();
	}
};
static_assert(alignof(ULGUICanvasScaler) == 0x000008, "Wrong alignment on ULGUICanvasScaler");
static_assert(sizeof(ULGUICanvasScaler) == 0x000128, "Wrong size on ULGUICanvasScaler");
static_assert(offsetof(ULGUICanvasScaler, ProjectionType) == 0x0000E0, "Member 'ULGUICanvasScaler::ProjectionType' has a wrong offset!");
static_assert(offsetof(ULGUICanvasScaler, FOVAngle) == 0x0000E4, "Member 'ULGUICanvasScaler::FOVAngle' has a wrong offset!");
static_assert(offsetof(ULGUICanvasScaler, NearClipPlane) == 0x0000E8, "Member 'ULGUICanvasScaler::NearClipPlane' has a wrong offset!");
static_assert(offsetof(ULGUICanvasScaler, FarClipPlane) == 0x0000EC, "Member 'ULGUICanvasScaler::FarClipPlane' has a wrong offset!");
static_assert(offsetof(ULGUICanvasScaler, UIScaleMode) == 0x0000F0, "Member 'ULGUICanvasScaler::UIScaleMode' has a wrong offset!");
static_assert(offsetof(ULGUICanvasScaler, ReferenceResolution) == 0x0000F4, "Member 'ULGUICanvasScaler::ReferenceResolution' has a wrong offset!");
static_assert(offsetof(ULGUICanvasScaler, MatchFromWidthToHeight) == 0x0000FC, "Member 'ULGUICanvasScaler::MatchFromWidthToHeight' has a wrong offset!");
static_assert(offsetof(ULGUICanvasScaler, ScreenMatchMode) == 0x000100, "Member 'ULGUICanvasScaler::ScreenMatchMode' has a wrong offset!");
static_assert(offsetof(ULGUICanvasScaler, Canvas) == 0x000108, "Member 'ULGUICanvasScaler::Canvas' has a wrong offset!");

// Class LGUI.LGUIComponentsRegistry
// 0x00C0 (0x0180 - 0x00C0)
class ULGUIComponentsRegistry final : public UActorComponent
{
public:
	class FString                                 TsClassName;                                       // 0x00C0(0x0010)(Edit, ZeroConstructor, Transient, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FRegisterRuntimeData> RuntimeRegistryData;                               // 0x00D0(0x0050)(Edit, EditConst, AdvancedDisplay, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         Components;                                        // 0x0120(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<int32, class FString>                    MissingComponents;                                 // 0x0130(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIComponentsRegistry">();
	}
	static class ULGUIComponentsRegistry* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIComponentsRegistry>();
	}
};
static_assert(alignof(ULGUIComponentsRegistry) == 0x000008, "Wrong alignment on ULGUIComponentsRegistry");
static_assert(sizeof(ULGUIComponentsRegistry) == 0x000180, "Wrong size on ULGUIComponentsRegistry");
static_assert(offsetof(ULGUIComponentsRegistry, TsClassName) == 0x0000C0, "Member 'ULGUIComponentsRegistry::TsClassName' has a wrong offset!");
static_assert(offsetof(ULGUIComponentsRegistry, RuntimeRegistryData) == 0x0000D0, "Member 'ULGUIComponentsRegistry::RuntimeRegistryData' has a wrong offset!");
static_assert(offsetof(ULGUIComponentsRegistry, Components) == 0x000120, "Member 'ULGUIComponentsRegistry::Components' has a wrong offset!");
static_assert(offsetof(ULGUIComponentsRegistry, MissingComponents) == 0x000130, "Member 'ULGUIComponentsRegistry::MissingComponents' has a wrong offset!");

// Class LGUI.LGUIEditorLevelDataStorageActor
// 0x0000 (0x02A8 - 0x02A8)
class ALGUIEditorLevelDataStorageActor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIEditorLevelDataStorageActor">();
	}
	static class ALGUIEditorLevelDataStorageActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALGUIEditorLevelDataStorageActor>();
	}
};
static_assert(alignof(ALGUIEditorLevelDataStorageActor) == 0x000008, "Wrong alignment on ALGUIEditorLevelDataStorageActor");
static_assert(sizeof(ALGUIEditorLevelDataStorageActor) == 0x0002A8, "Wrong size on ALGUIEditorLevelDataStorageActor");

// Class LGUI.LGUIEditorManagerObject
// 0x0008 (0x0038 - 0x0030)
class ULGUIEditorManagerObject final : public UObject
{
public:
	uint8                                         Pad_114F[0x8];                                     // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIEditorManagerObject">();
	}
	static class ULGUIEditorManagerObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIEditorManagerObject>();
	}
};
static_assert(alignof(ULGUIEditorManagerObject) == 0x000008, "Wrong alignment on ULGUIEditorManagerObject");
static_assert(sizeof(ULGUIEditorManagerObject) == 0x000038, "Wrong size on ULGUIEditorManagerObject");

// Class LGUI.UITextClickComponent
// 0x0018 (0x0118 - 0x0100)
class UUITextClickComponent final : public ULGUIBehaviour
{
public:
	uint8                                         Pad_1150[0x10];                                    // 0x0100(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UUIText>                 Target;                                            // 0x0110(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITextClickComponent">();
	}
	static class UUITextClickComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITextClickComponent>();
	}
};
static_assert(alignof(UUITextClickComponent) == 0x000008, "Wrong alignment on UUITextClickComponent");
static_assert(sizeof(UUITextClickComponent) == 0x000118, "Wrong size on UUITextClickComponent");
static_assert(offsetof(UUITextClickComponent, Target) == 0x000110, "Member 'UUITextClickComponent::Target' has a wrong offset!");

// Class LGUI.LGUIEventSystem
// 0x0150 (0x0210 - 0x00C0)
class ULGUIEventSystem final : public UActorComponent
{
public:
	uint8                                         Pad_1151[0x1];                                     // 0x00C0(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRayEventEnable;                                   // 0x00C1(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          HighlightWhenMouseMoveOut;                         // 0x00C2(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1152[0x5];                                     // 0x00C3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class ULGUIPointerEventData*>     PointerEventDataMap;                               // 0x00C8(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_1153[0x30];                                    // 0x0118(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(ENavigationComponentState State, class USceneComponent* CursorComponent, ELGUIPointerInputType InputType, bool bForceNavigation)> NavigationChangeDelegate;                          // 0x0148(0x0028)(Edit, ZeroConstructor, InstancedReference, Protected, NativeAccessSpecifierProtected)
	TDelegate<void(ELGUINavigationDirection Direction)> FindDefaultNavigationDelegate;                     // 0x0170(0x0028)(Edit, ZeroConstructor, InstancedReference, Protected, NativeAccessSpecifierProtected)
	TDelegate<void(ELGUINavigationDirection Direction, class UUISelectableComponent* SelectableComponent)> TryFindNavigationDelegate;                         // 0x0198(0x0028)(Edit, ZeroConstructor, InstancedReference, Protected, NativeAccessSpecifierProtected)
	ELGUIPointerInputType                         DefaultInputType;                                  // 0x01C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELGUIEventFireType                            EventFireTypeForNavigation;                        // 0x01C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1154[0x2];                                     // 0x01C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NavigateInputInterval;                             // 0x01C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavigateInputIntervalForFirstTime;                 // 0x01C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1155[0x4];                                     // 0x01CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SelectedComponent;                                 // 0x01D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        NavigationComponent;                               // 0x01D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        PreSelectedComponent;                              // 0x01E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1156[0x28];                                    // 0x01E8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ULGUIEventSystem* GetLGUIEventSystemInstance(class UObject* WorldContextObject);

	void ClearEvent();
	class ULGUIBaseInputModule* GetCurrentInputModule();
	class USceneComponent* GetCurrentSelectedComponent();
	void InputNavigationBegin();
	void InputNavigationDown();
	void InputNavigationEnd();
	void InputNavigationLeft();
	void InputNavigationNext();
	void InputNavigationPrev();
	void InputNavigationRight();
	void InputNavigationUp();
	void InputScroll(const float& InAxisValue);
	void InputTrigger(bool InTriggerPress, EMouseButtonType InMouseButtonType);
	bool IsRaycastEnable();
	class USceneComponent* Navigate(ELGUINavigationDirection Direction, class UUISelectableComponent* Selectable);
	struct FLGUIDelegateHandleWrapper RegisterGlobalListener(const TDelegate<void(class ULGUIBaseEventData* EventData)>& InDelegate);
	struct FLGUIDelegateHandleWrapper RegisterHitEvent(const TDelegate<void(bool IsHit, struct FHitResult& HitResult, class USceneComponent* HitComponent)>& InDelegate);
	void RegisterPointerEnterExitEvent(const TDelegate<void(bool bEnter)>& PointerEnterExitDelegate);
	void SetRaycastEnable(bool Enable, bool ClearEvent);
	void SetSelectComponent(class USceneComponent* InSelectComp, class ULGUIBaseEventData* EventData, ELGUIEventFireType EventFireType);
	void SetSelectComponentWithDefault(class USceneComponent* InSelectComp);
	void UnregisterGlobalListener(const struct FLGUIDelegateHandleWrapper& InHandle);
	void UnregisterHitEvent(const struct FLGUIDelegateHandleWrapper& InHandle);
	void UnRegisterPointerEnterExitEvent();

	bool IsNavigationActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIEventSystem">();
	}
	static class ULGUIEventSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIEventSystem>();
	}
};
static_assert(alignof(ULGUIEventSystem) == 0x000008, "Wrong alignment on ULGUIEventSystem");
static_assert(sizeof(ULGUIEventSystem) == 0x000210, "Wrong size on ULGUIEventSystem");
static_assert(offsetof(ULGUIEventSystem, bRayEventEnable) == 0x0000C1, "Member 'ULGUIEventSystem::bRayEventEnable' has a wrong offset!");
static_assert(offsetof(ULGUIEventSystem, HighlightWhenMouseMoveOut) == 0x0000C2, "Member 'ULGUIEventSystem::HighlightWhenMouseMoveOut' has a wrong offset!");
static_assert(offsetof(ULGUIEventSystem, PointerEventDataMap) == 0x0000C8, "Member 'ULGUIEventSystem::PointerEventDataMap' has a wrong offset!");
static_assert(offsetof(ULGUIEventSystem, NavigationChangeDelegate) == 0x000148, "Member 'ULGUIEventSystem::NavigationChangeDelegate' has a wrong offset!");
static_assert(offsetof(ULGUIEventSystem, FindDefaultNavigationDelegate) == 0x000170, "Member 'ULGUIEventSystem::FindDefaultNavigationDelegate' has a wrong offset!");
static_assert(offsetof(ULGUIEventSystem, TryFindNavigationDelegate) == 0x000198, "Member 'ULGUIEventSystem::TryFindNavigationDelegate' has a wrong offset!");
static_assert(offsetof(ULGUIEventSystem, DefaultInputType) == 0x0001C0, "Member 'ULGUIEventSystem::DefaultInputType' has a wrong offset!");
static_assert(offsetof(ULGUIEventSystem, EventFireTypeForNavigation) == 0x0001C1, "Member 'ULGUIEventSystem::EventFireTypeForNavigation' has a wrong offset!");
static_assert(offsetof(ULGUIEventSystem, NavigateInputInterval) == 0x0001C4, "Member 'ULGUIEventSystem::NavigateInputInterval' has a wrong offset!");
static_assert(offsetof(ULGUIEventSystem, NavigateInputIntervalForFirstTime) == 0x0001C8, "Member 'ULGUIEventSystem::NavigateInputIntervalForFirstTime' has a wrong offset!");
static_assert(offsetof(ULGUIEventSystem, SelectedComponent) == 0x0001D0, "Member 'ULGUIEventSystem::SelectedComponent' has a wrong offset!");
static_assert(offsetof(ULGUIEventSystem, NavigationComponent) == 0x0001D8, "Member 'ULGUIEventSystem::NavigationComponent' has a wrong offset!");
static_assert(offsetof(ULGUIEventSystem, PreSelectedComponent) == 0x0001E0, "Member 'ULGUIEventSystem::PreSelectedComponent' has a wrong offset!");

// Class LGUI.LGUIEventSystemActor
// 0x0008 (0x02B0 - 0x02A8)
class ALGUIEventSystemActor : public AActor
{
public:
	class ULGUIEventSystem*                       EventSystem;                                       // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void PreDestroy();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIEventSystemActor">();
	}
	static class ALGUIEventSystemActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALGUIEventSystemActor>();
	}
};
static_assert(alignof(ALGUIEventSystemActor) == 0x000008, "Wrong alignment on ALGUIEventSystemActor");
static_assert(sizeof(ALGUIEventSystemActor) == 0x0002B0, "Wrong size on ALGUIEventSystemActor");
static_assert(offsetof(ALGUIEventSystemActor, EventSystem) == 0x0002A8, "Member 'ALGUIEventSystemActor::EventSystem' has a wrong offset!");

// Class LGUI.UIExtendToggleTransitionBase
// 0x0040 (0x0140 - 0x0100)
class UUIExtendToggleTransitionBase : public ULGUIBehaviour
{
public:
	struct FUIWidget                              UnCkeckUnHoverWidget;                              // 0x0100(0x0040)(NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIExtendToggleTransitionBase">();
	}
	static class UUIExtendToggleTransitionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIExtendToggleTransitionBase>();
	}
};
static_assert(alignof(UUIExtendToggleTransitionBase) == 0x000008, "Wrong alignment on UUIExtendToggleTransitionBase");
static_assert(sizeof(UUIExtendToggleTransitionBase) == 0x000140, "Wrong size on UUIExtendToggleTransitionBase");
static_assert(offsetof(UUIExtendToggleTransitionBase, UnCkeckUnHoverWidget) == 0x000100, "Member 'UUIExtendToggleTransitionBase::UnCkeckUnHoverWidget' has a wrong offset!");

// Class LGUI.UIExtendToggleTextureTransition
// 0x01A8 (0x02E8 - 0x0140)
class UUIExtendToggleTextureTransition final : public UUIExtendToggleTransitionBase
{
public:
	ETextureTransitionType                        TransitionType;                                    // 0x0140(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1159[0x3];                                     // 0x0141(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FExtendToggleColorTransition           TransitionColors;                                  // 0x0144(0x0028)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_115A[0x4];                                     // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FExtendToggleTextureTransitionState    TransitionState;                                   // 0x0170(0x0128)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_115B[0x50];                                    // 0x0298(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAllTransitionStateTexture(class UTexture* Texture);
	void SetTargetStateTexture(EToggleTransitionState State, class UTexture* Texture, bool ForceNoTriggerOnChange);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIExtendToggleTextureTransition">();
	}
	static class UUIExtendToggleTextureTransition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIExtendToggleTextureTransition>();
	}
};
static_assert(alignof(UUIExtendToggleTextureTransition) == 0x000008, "Wrong alignment on UUIExtendToggleTextureTransition");
static_assert(sizeof(UUIExtendToggleTextureTransition) == 0x0002E8, "Wrong size on UUIExtendToggleTextureTransition");
static_assert(offsetof(UUIExtendToggleTextureTransition, TransitionType) == 0x000140, "Member 'UUIExtendToggleTextureTransition::TransitionType' has a wrong offset!");
static_assert(offsetof(UUIExtendToggleTextureTransition, TransitionColors) == 0x000144, "Member 'UUIExtendToggleTextureTransition::TransitionColors' has a wrong offset!");
static_assert(offsetof(UUIExtendToggleTextureTransition, TransitionState) == 0x000170, "Member 'UUIExtendToggleTextureTransition::TransitionState' has a wrong offset!");

// Class LGUI.LGUIFontData_BaseObject
// 0x0050 (0x0080 - 0x0030)
class ULGUIFontData_BaseObject : public UObject
{
public:
	uint8                                         Pad_115E[0x50];                                    // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIFontData_BaseObject">();
	}
	static class ULGUIFontData_BaseObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIFontData_BaseObject>();
	}
};
static_assert(alignof(ULGUIFontData_BaseObject) == 0x000008, "Wrong alignment on ULGUIFontData_BaseObject");
static_assert(sizeof(ULGUIFontData_BaseObject) == 0x000080, "Wrong size on ULGUIFontData_BaseObject");

// Class LGUI.LGUIFontData
// 0x0458 (0x04D8 - 0x0080)
class ULGUIFontData final : public ULGUIFontData_BaseObject
{
public:
	uint8                                         Pad_115F[0x4];                                     // 0x0080(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	ECulture                                      CurrentMainCulture;                                // 0x0084(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELGUIDynamicFontDataType                      FontType;                                          // 0x0085(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1160[0x2];                                     // 0x0086(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FontFilePath;                                      // 0x0088(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          UseRelativeFilePath;                               // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          UseExternalFileOrEmbedInToUAsset;                  // 0x0099(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1161[0x6];                                     // 0x009A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UFontFace*                              UnrealFont;                                        // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         FontFace;                                          // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FixedVerticalOffset;                               // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ItalicAngle;                                       // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         boldRatio;                                         // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   PackingTag;                                        // 0x00B8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1162[0x4];                                     // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Texture;                                           // 0x00C8(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELGUIAtlasTextureSizeType                     InitialSize;                                       // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1163[0x7];                                     // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLGUISubFontData>               SubFonts;                                          // 0x00D8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1164[0x8];                                     // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class UUIText>>         RenderTextArray;                                   // 0x00F0(0x0010)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<uint8>                                 FontBinaryArray;                                   // 0x0100(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<uint8>                                 TempFontBinaryArray;                               // 0x0110(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1165[0x3B8];                                   // 0x0120(0x03B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ULGUIFontData* GetDefaultFont();
	static TArray<class ULGUIFontData*> GetFonts();
	static void RebuildAllFontText();
	static void SetAllFontCurrentCulture(ECulture NewCulture);

	int32 GetCharMapSize();
	class FString GetFontPath();
	class UTexture2D* GetFontTexture();
	int32 GetFreeRectNum();
	int32 GetTobeClearNum();
	int32 GetUsedRectNum();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIFontData">();
	}
	static class ULGUIFontData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIFontData>();
	}
};
static_assert(alignof(ULGUIFontData) == 0x000008, "Wrong alignment on ULGUIFontData");
static_assert(sizeof(ULGUIFontData) == 0x0004D8, "Wrong size on ULGUIFontData");
static_assert(offsetof(ULGUIFontData, CurrentMainCulture) == 0x000084, "Member 'ULGUIFontData::CurrentMainCulture' has a wrong offset!");
static_assert(offsetof(ULGUIFontData, FontType) == 0x000085, "Member 'ULGUIFontData::FontType' has a wrong offset!");
static_assert(offsetof(ULGUIFontData, FontFilePath) == 0x000088, "Member 'ULGUIFontData::FontFilePath' has a wrong offset!");
static_assert(offsetof(ULGUIFontData, UseRelativeFilePath) == 0x000098, "Member 'ULGUIFontData::UseRelativeFilePath' has a wrong offset!");
static_assert(offsetof(ULGUIFontData, UseExternalFileOrEmbedInToUAsset) == 0x000099, "Member 'ULGUIFontData::UseExternalFileOrEmbedInToUAsset' has a wrong offset!");
static_assert(offsetof(ULGUIFontData, UnrealFont) == 0x0000A0, "Member 'ULGUIFontData::UnrealFont' has a wrong offset!");
static_assert(offsetof(ULGUIFontData, FontFace) == 0x0000A8, "Member 'ULGUIFontData::FontFace' has a wrong offset!");
static_assert(offsetof(ULGUIFontData, FixedVerticalOffset) == 0x0000AC, "Member 'ULGUIFontData::FixedVerticalOffset' has a wrong offset!");
static_assert(offsetof(ULGUIFontData, ItalicAngle) == 0x0000B0, "Member 'ULGUIFontData::ItalicAngle' has a wrong offset!");
static_assert(offsetof(ULGUIFontData, boldRatio) == 0x0000B4, "Member 'ULGUIFontData::boldRatio' has a wrong offset!");
static_assert(offsetof(ULGUIFontData, PackingTag) == 0x0000B8, "Member 'ULGUIFontData::PackingTag' has a wrong offset!");
static_assert(offsetof(ULGUIFontData, Texture) == 0x0000C8, "Member 'ULGUIFontData::Texture' has a wrong offset!");
static_assert(offsetof(ULGUIFontData, InitialSize) == 0x0000D0, "Member 'ULGUIFontData::InitialSize' has a wrong offset!");
static_assert(offsetof(ULGUIFontData, SubFonts) == 0x0000D8, "Member 'ULGUIFontData::SubFonts' has a wrong offset!");
static_assert(offsetof(ULGUIFontData, RenderTextArray) == 0x0000F0, "Member 'ULGUIFontData::RenderTextArray' has a wrong offset!");
static_assert(offsetof(ULGUIFontData, FontBinaryArray) == 0x000100, "Member 'ULGUIFontData::FontBinaryArray' has a wrong offset!");
static_assert(offsetof(ULGUIFontData, TempFontBinaryArray) == 0x000110, "Member 'ULGUIFontData::TempFontBinaryArray' has a wrong offset!");

// Class LGUI.UISelectableTransitionComponent
// 0x0010 (0x0110 - 0x0100)
class UUISelectableTransitionComponent : public ULGUIBehaviour
{
public:
	TArray<class ULTweener*>                      TweenerCollection;                                 // 0x0100(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	void CollectTweener(class ULTweener* InItem);
	void CollectTweeners(const TSet<class ULTweener*>& InItems);
	void OnDisabledBP(bool InImmediateSet);
	void OnHighlightedBP(bool InImmediateSet);
	void OnNormalBP(bool InImmediateSet);
	void OnPressedBP(bool InImmediateSet);
	void OnStartCustomTransitionBP(class FName InTransitionName, bool InImmediateSet);
	void StopTransition();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISelectableTransitionComponent">();
	}
	static class UUISelectableTransitionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISelectableTransitionComponent>();
	}
};
static_assert(alignof(UUISelectableTransitionComponent) == 0x000008, "Wrong alignment on UUISelectableTransitionComponent");
static_assert(sizeof(UUISelectableTransitionComponent) == 0x000110, "Wrong size on UUISelectableTransitionComponent");
static_assert(offsetof(UUISelectableTransitionComponent, TweenerCollection) == 0x000100, "Member 'UUISelectableTransitionComponent::TweenerCollection' has a wrong offset!");

// Class LGUI.UITransitionBase
// 0x0158 (0x0268 - 0x0110)
class UUITransitionBase : public UUISelectableTransitionComponent
{
public:
	struct FWidgetTransitionInfo                  WidgetTransitionInfo;                              // 0x0110(0x0104)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1167[0x54];                                    // 0x0214(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITransitionBase">();
	}
	static class UUITransitionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITransitionBase>();
	}
};
static_assert(alignof(UUITransitionBase) == 0x000008, "Wrong alignment on UUITransitionBase");
static_assert(sizeof(UUITransitionBase) == 0x000268, "Wrong size on UUITransitionBase");
static_assert(offsetof(UUITransitionBase, WidgetTransitionInfo) == 0x000110, "Member 'UUITransitionBase::WidgetTransitionInfo' has a wrong offset!");

// Class LGUI.UITextTransition
// 0x0030 (0x0298 - 0x0268)
class UUITextTransition final : public UUITransitionBase
{
public:
	struct FTextTransitionInfo                    TransitionInfo;                                    // 0x0268(0x0030)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITextTransition">();
	}
	static class UUITextTransition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITextTransition>();
	}
};
static_assert(alignof(UUITextTransition) == 0x000008, "Wrong alignment on UUITextTransition");
static_assert(sizeof(UUITextTransition) == 0x000298, "Wrong size on UUITextTransition");
static_assert(offsetof(UUITextTransition, TransitionInfo) == 0x000268, "Member 'UUITextTransition::TransitionInfo' has a wrong offset!");

// Class LGUI.LGUIGridAnimationInterface
// 0x0000 (0x0030 - 0x0030)
class ILGUIGridAnimationInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIGridAnimationInterface">();
	}
	static class ILGUIGridAnimationInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILGUIGridAnimationInterface>();
	}
};
static_assert(alignof(ILGUIGridAnimationInterface) == 0x000008, "Wrong alignment on ILGUIGridAnimationInterface");
static_assert(sizeof(ILGUIGridAnimationInterface) == 0x000030, "Wrong size on ILGUIGridAnimationInterface");

// Class LGUI.LGUIImageSequencePlayer
// 0x0020 (0x00E0 - 0x00C0)
class ULGUIImageSequencePlayer : public UActorComponent
{
public:
	float                                         Fps;                                               // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Loop;                                              // 0x00C4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          PlayOnStart;                                       // 0x00C5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1168[0x1A];                                    // 0x00C6(0x001A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Pause();
	void Play();
	void SeekFrame(int32 FrameNumber);
	void SeekTime(float Time);
	void SetFps(float Value);
	void SetLoop(bool Value);
	void Stop();

	float GetDuration() const;
	float GetFps() const;
	bool GetIsPlaying() const;
	bool GetLoop() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIImageSequencePlayer">();
	}
	static class ULGUIImageSequencePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIImageSequencePlayer>();
	}
};
static_assert(alignof(ULGUIImageSequencePlayer) == 0x000008, "Wrong alignment on ULGUIImageSequencePlayer");
static_assert(sizeof(ULGUIImageSequencePlayer) == 0x0000E0, "Wrong size on ULGUIImageSequencePlayer");
static_assert(offsetof(ULGUIImageSequencePlayer, Fps) == 0x0000C0, "Member 'ULGUIImageSequencePlayer::Fps' has a wrong offset!");
static_assert(offsetof(ULGUIImageSequencePlayer, Loop) == 0x0000C4, "Member 'ULGUIImageSequencePlayer::Loop' has a wrong offset!");
static_assert(offsetof(ULGUIImageSequencePlayer, PlayOnStart) == 0x0000C5, "Member 'ULGUIImageSequencePlayer::PlayOnStart' has a wrong offset!");

// Class LGUI.UIItem
// 0x0320 (0x0540 - 0x0220)
class UUIItem : public USceneComponent
{
public:
	uint8                                         Pad_1169[0xD8];                                    // 0x0218(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUIWidget                              Widget;                                            // 0x02F0(0x0040)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_116A[0x10];                                    // 0x0330(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUIItem*>                        UIChildren;                                        // 0x0340(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          InheritAlpha;                                      // 0x0350(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_116B[0x3];                                     // 0x0351(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 Color;                                             // 0x0354(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Alpha;                                             // 0x0358(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Width;                                             // 0x035C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Height;                                            // 0x0360(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UseChangeColor;                                    // 0x0364(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_116C[0x3];                                     // 0x0365(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 ChangeColor;                                       // 0x0368(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_116D[0x4];                                     // 0x036C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FSequenceInfo>     LevelSequences;                                    // 0x0370(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FSoftObjectPath, struct FLGUILevelSequenceBindings> LevelSequenceBindings;                             // 0x03C0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        HardRefAssets;                                     // 0x0410(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_116E[0xC];                                     // 0x0420(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  RenderCanvasActor;                                 // 0x042C(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_116F[0x6D];                                    // 0x0434(0x006D)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsRenderAfterBlur;                                // 0x04A1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRenderBeforeBloom;                              // 0x04A2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1170[0x1];                                     // 0x04A3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsUIActive;                                       // 0x04A4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1171[0x7];                                     // 0x04A5(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HierarchyIndex;                                    // 0x04AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FlattenHierarchyIndex;                             // 0x04B0(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AdditionalIndexDelta;                              // 0x04B4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1172[0x8];                                     // 0x04B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DisplayName;                                       // 0x04C0(0x0010)(Edit, ZeroConstructor, EditConst, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRaycastTarget;                                    // 0x04D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBubbleUpToParent;                                 // 0x04D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETraceTypeQuery                               TraceChannel;                                      // 0x04D2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1173[0x65];                                    // 0x04D3(0x0065)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AUIBaseActor>            DebugCollisionLine;                                // 0x0538(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void GetAllAttachUIChildren(TArray<class UUIItem*>* OutArray);
	const struct FVector GetLGUISpaceAbsolutePosition();
	const struct FVector GetLGUISpaceAbsolutePositionByPivot(const struct FVector2D& Pivot);
	const struct FVector GetLGUISpaceCenterAbsolutePosition();
	bool GetOverlapWith(class UUIItem* UIItem);
	class UUIItem* GetParentAsUIItem();
	struct FVector2D GetPositionInScreen(bool bIsScaledByDPI);
	struct FVector2D GetPositionInViewPort(bool bIsScaledByDPI);
	class ULGUICanvas* GetRenderCanvas();
	bool IsRenderTargetUI();
	bool IsScreenSpaceOverlayUI();
	bool IsWorldSpaceUI();
	void PlayUIItemAlphaTween(float StartValue, float EndValue, float Duration);
	void PlayUIItemScaleTween(float StartValue, float EndValue, float Duration);
	void ReverseChildrenIndex();
	void SetAlpha(float NewAlpha);
	void SetAnchorAlign(EUIAnchorHorizontalAlign HAlign, EUIAnchorVerticalAlign VAlign);
	void SetAnchorHAlign(EUIAnchorHorizontalAlign Align);
	void SetAnchorOffset(const struct FVector2D& NewOffset);
	void SetAnchorOffsetX(float NewOffset);
	void SetAnchorOffsetY(float NewOffset);
	void SetAnchorVAlign(EUIAnchorVerticalAlign Align);
	void SetAsFirstHierarchy();
	void SetAsLastHierarchy();
	void SetBubbleUpToParent(bool NewBool);
	void SetChangeColor(bool bUseChangeColor, const struct FColor& NewColor);
	void SetColor(const struct FColor& NewColor);
	void SetDepth(int32 Depth, bool PropagateToChildren);
	void SetDisplayName(const class FString& InName);
	void SetHeight(float NewHeight);
	void SetHierarchyIndex(int32 InInt);
	void SetHorizontalStretch(const struct FVector2D& NewStretch);
	void SetIsUIActive(bool Active);
	void SetLGUISpaceAbsolutePosition(const struct FVector& Pos);
	void SetPivot(const struct FVector2D& NewPivot);
	void SetPivot_Raw(const struct FVector2D& NewPivot, bool bAdjustLocation);
	void SetRaycastTarget(bool NewBool);
	void SetStretchBottom(float NewBottom);
	void SetStretchLeft(float NewLeft);
	void SetStretchRight(float NewRight);
	void SetStretchTop(float NewTop);
	void SetTraceChannel(ETraceTypeQuery InTraceChannel);
	void SetUIActive(bool bActive);
	void SetUIItemAlpha(float Value);
	void SetUIItemScale(const struct FVector& Value);
	void SetUIParent(class UUIItem* InParent, bool KeepWorldTransform);
	void SetUIRelativeLocation(const struct FVector& NewLocation);
	void SetUIRelativeRotation(const struct FRotator& NewRotation);
	void SetUIRelativeScale3D(const struct FVector& NewScale3D);
	void SetUIRenderAfterBlur(bool bAfterBlur);
	void SetUIRenderBeforeBloom(bool bBeforeBloom);
	void SetUIWorldLocation(const struct FVector& NewLocation);
	void SetUIWorldRotation(const struct FRotator& NewRotation);
	void SetVerticalStretch(const struct FVector2D& NewStretch);
	void SetWidget(const struct FUIWidget& InWidget);
	void SetWidth(float NewWidth);

	float GetAlpha() const;
	EUIAnchorHorizontalAlign GetAnchorHAlign() const;
	struct FVector2D GetAnchorOffset() const;
	float GetAnchorOffsetX() const;
	float GetAnchorOffsetY() const;
	EUIAnchorVerticalAlign GetAnchorVAlign() const;
	class UUIItem* GetAttachUIChild(int32 Param_Index) const;
	const TArray<class UUIItem*> GetAttachUIChildren() const;
	float GetCalculatedParentAlpha() const;
	class ULGUICanvasScaler* GetCanvasScaler() const;
	struct FColor GetColor() const;
	int32 GetDepth() const;
	class FString GetDisplayName() const;
	int32 GetFlattenHierarchyIndex() const;
	float GetHeight() const;
	int32 GetHierarchyIndex() const;
	bool GetInheritAlpha() const;
	float GetLocalSpaceBottom() const;
	struct FVector2D GetLocalSpaceCenter() const;
	float GetLocalSpaceLeft() const;
	struct FVector2D GetLocalSpaceLeftBottomPoint() const;
	float GetLocalSpaceRight() const;
	struct FVector2D GetLocalSpaceRightTopPoint() const;
	float GetLocalSpaceTop() const;
	struct FVector2D GetPivot() const;
	class ULGUICanvas* GetRootCanvas() const;
	float GetStretchBottom() const;
	float GetStretchLeft() const;
	float GetStretchRight() const;
	float GetStretchTop() const;
	ETraceTypeQuery GetTraceChannel() const;
	EUIItemType GetUIItemType() const;
	const struct FUIWidget GetWidget() const;
	float GetWidth() const;
	bool IsBubbleUpToParent() const;
	bool IsRaycastTarget() const;
	bool IsUIActiveInHierarchy() const;
	bool IsUIActiveSelf() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItem">();
	}
	static class UUIItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItem>();
	}
};
static_assert(alignof(UUIItem) == 0x000010, "Wrong alignment on UUIItem");
static_assert(sizeof(UUIItem) == 0x000540, "Wrong size on UUIItem");
static_assert(offsetof(UUIItem, Widget) == 0x0002F0, "Member 'UUIItem::Widget' has a wrong offset!");
static_assert(offsetof(UUIItem, UIChildren) == 0x000340, "Member 'UUIItem::UIChildren' has a wrong offset!");
static_assert(offsetof(UUIItem, InheritAlpha) == 0x000350, "Member 'UUIItem::InheritAlpha' has a wrong offset!");
static_assert(offsetof(UUIItem, Color) == 0x000354, "Member 'UUIItem::Color' has a wrong offset!");
static_assert(offsetof(UUIItem, Alpha) == 0x000358, "Member 'UUIItem::Alpha' has a wrong offset!");
static_assert(offsetof(UUIItem, Width) == 0x00035C, "Member 'UUIItem::Width' has a wrong offset!");
static_assert(offsetof(UUIItem, Height) == 0x000360, "Member 'UUIItem::Height' has a wrong offset!");
static_assert(offsetof(UUIItem, UseChangeColor) == 0x000364, "Member 'UUIItem::UseChangeColor' has a wrong offset!");
static_assert(offsetof(UUIItem, ChangeColor) == 0x000368, "Member 'UUIItem::ChangeColor' has a wrong offset!");
static_assert(offsetof(UUIItem, LevelSequences) == 0x000370, "Member 'UUIItem::LevelSequences' has a wrong offset!");
static_assert(offsetof(UUIItem, LevelSequenceBindings) == 0x0003C0, "Member 'UUIItem::LevelSequenceBindings' has a wrong offset!");
static_assert(offsetof(UUIItem, HardRefAssets) == 0x000410, "Member 'UUIItem::HardRefAssets' has a wrong offset!");
static_assert(offsetof(UUIItem, RenderCanvasActor) == 0x00042C, "Member 'UUIItem::RenderCanvasActor' has a wrong offset!");
static_assert(offsetof(UUIItem, bIsRenderAfterBlur) == 0x0004A1, "Member 'UUIItem::bIsRenderAfterBlur' has a wrong offset!");
static_assert(offsetof(UUIItem, bIsRenderBeforeBloom) == 0x0004A2, "Member 'UUIItem::bIsRenderBeforeBloom' has a wrong offset!");
static_assert(offsetof(UUIItem, bIsUIActive) == 0x0004A4, "Member 'UUIItem::bIsUIActive' has a wrong offset!");
static_assert(offsetof(UUIItem, HierarchyIndex) == 0x0004AC, "Member 'UUIItem::HierarchyIndex' has a wrong offset!");
static_assert(offsetof(UUIItem, FlattenHierarchyIndex) == 0x0004B0, "Member 'UUIItem::FlattenHierarchyIndex' has a wrong offset!");
static_assert(offsetof(UUIItem, AdditionalIndexDelta) == 0x0004B4, "Member 'UUIItem::AdditionalIndexDelta' has a wrong offset!");
static_assert(offsetof(UUIItem, DisplayName) == 0x0004C0, "Member 'UUIItem::DisplayName' has a wrong offset!");
static_assert(offsetof(UUIItem, bRaycastTarget) == 0x0004D0, "Member 'UUIItem::bRaycastTarget' has a wrong offset!");
static_assert(offsetof(UUIItem, bBubbleUpToParent) == 0x0004D1, "Member 'UUIItem::bBubbleUpToParent' has a wrong offset!");
static_assert(offsetof(UUIItem, TraceChannel) == 0x0004D2, "Member 'UUIItem::TraceChannel' has a wrong offset!");
static_assert(offsetof(UUIItem, DebugCollisionLine) == 0x000538, "Member 'UUIItem::DebugCollisionLine' has a wrong offset!");

// Class LGUI.UIBaseRenderable
// 0x0020 (0x0560 - 0x0540)
class UUIBaseRenderable : public UUIItem
{
public:
	uint8                                         Pad_117C[0x14];                                    // 0x0540(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BatchDepth;                                        // 0x0554(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRenderAfterBlurPartial;                         // 0x0558(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAlphaZeroClip;                                  // 0x0559(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_117D[0x6];                                     // 0x055A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetUIRenderAfterBlurPartial(bool bAfterBlurPartial);

	EUIRenderableType GetUIRenderableType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBaseRenderable">();
	}
	static class UUIBaseRenderable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBaseRenderable>();
	}
};
static_assert(alignof(UUIBaseRenderable) == 0x000010, "Wrong alignment on UUIBaseRenderable");
static_assert(sizeof(UUIBaseRenderable) == 0x000560, "Wrong size on UUIBaseRenderable");
static_assert(offsetof(UUIBaseRenderable, BatchDepth) == 0x000554, "Member 'UUIBaseRenderable::BatchDepth' has a wrong offset!");
static_assert(offsetof(UUIBaseRenderable, bIsRenderAfterBlurPartial) == 0x000558, "Member 'UUIBaseRenderable::bIsRenderAfterBlurPartial' has a wrong offset!");
static_assert(offsetof(UUIBaseRenderable, bIsAlphaZeroClip) == 0x000559, "Member 'UUIBaseRenderable::bIsAlphaZeroClip' has a wrong offset!");

// Class LGUI.UIDirectMeshRenderable
// 0x0010 (0x0570 - 0x0560)
class UUIDirectMeshRenderable : public UUIBaseRenderable
{
public:
	uint8                                         Pad_117E[0x10];                                    // 0x0560(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDirectMeshRenderable">();
	}
	static class UUIDirectMeshRenderable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDirectMeshRenderable>();
	}
};
static_assert(alignof(UUIDirectMeshRenderable) == 0x000010, "Wrong alignment on UUIDirectMeshRenderable");
static_assert(sizeof(UUIDirectMeshRenderable) == 0x000570, "Wrong size on UUIDirectMeshRenderable");

// Class LGUI.UIStaticMesh
// 0x0010 (0x0580 - 0x0570)
class UUIStaticMesh final : public UUIDirectMeshRenderable
{
public:
	class UStaticMesh*                            Mesh;                                              // 0x0570(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUIStaticMeshVertexColorType                  VertexColorType;                                   // 0x0578(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_117F[0x7];                                     // 0x0579(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMesh(class UStaticMesh* Value);
	void SetVertexColorType(EUIStaticMeshVertexColorType Value);

	class UStaticMesh* GetMesh() const;
	EUIStaticMeshVertexColorType GetVertexColorType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStaticMesh">();
	}
	static class UUIStaticMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIStaticMesh>();
	}
};
static_assert(alignof(UUIStaticMesh) == 0x000010, "Wrong alignment on UUIStaticMesh");
static_assert(sizeof(UUIStaticMesh) == 0x000580, "Wrong size on UUIStaticMesh");
static_assert(offsetof(UUIStaticMesh, Mesh) == 0x000570, "Member 'UUIStaticMesh::Mesh' has a wrong offset!");
static_assert(offsetof(UUIStaticMesh, VertexColorType) == 0x000578, "Member 'UUIStaticMesh::VertexColorType' has a wrong offset!");

// Class LGUI.LGUIManagerActor
// 0x0220 (0x04C8 - 0x02A8)
class ALGUIManagerActor final : public AActor
{
public:
	uint8                                         Pad_1180[0x8];                                     // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class UUIItem>>         AllUIItem;                                         // 0x02B0(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class ULGUICanvas*>                    AllCanvas;                                         // 0x02C0(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class ULGUICanvas*>                    PostTickCanvas;                                    // 0x02D0(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class ULGUIBaseRaycaster*>             RaycasterArray;                                    // 0x02E0(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class ULGUIBaseInputModule*                   CurrentInputModule;                                // 0x02F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUISelectableComponent*>         AllSelectableArray;                                // 0x02F8(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class USequencerManager*                      SequencerManager;                                  // 0x0308(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUIDynmaicTextureAtlasMgr*              DynmaicTextureAtlasMgr;                            // 0x0310(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class UUIItem>>         AllRaycastTarget;                                  // 0x0318(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class ULGUIBehaviour>>  LGUIBehavioursForUpdate;                           // 0x0328(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UUINiagara*>                     AllUINiagara;                                      // 0x0338(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ULGUICanvas>             ScreenRootPtr;                                     // 0x0348(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1181[0x40];                                    // 0x0350(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLGUIBehaviourArrayContainer>   LGUIBehaviours_PrefabSystemProcessing;             // 0x0390(0x0010)(Edit, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1182[0x4];                                     // 0x03A0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UUIItem>                 DebugRootLayer;                                    // 0x03A4(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1183[0x5C];                                    // 0x03AC(0x005C)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class UUIItem*>                          DirtyHierarchyRootSet;                             // 0x0408(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UUILayoutBase*>                  AutoLayoutRebuildList_ParentFirst;                 // 0x0458(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UUILayoutBase*>                  AutoLayoutRebuildList_ChildrenFirst;               // 0x0468(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSet<class UUILayoutBase*>                    AutoLayoutPostRebuildList;                         // 0x0478(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static int32 GetGlobalUiBlurIndex(class UObject* WorldContextObject);
	static void SetDebugRootLayer(class UObject* WorldContextObj, class UUIItem* LayerItem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIManagerActor">();
	}
	static class ALGUIManagerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALGUIManagerActor>();
	}
};
static_assert(alignof(ALGUIManagerActor) == 0x000008, "Wrong alignment on ALGUIManagerActor");
static_assert(sizeof(ALGUIManagerActor) == 0x0004C8, "Wrong size on ALGUIManagerActor");
static_assert(offsetof(ALGUIManagerActor, AllUIItem) == 0x0002B0, "Member 'ALGUIManagerActor::AllUIItem' has a wrong offset!");
static_assert(offsetof(ALGUIManagerActor, AllCanvas) == 0x0002C0, "Member 'ALGUIManagerActor::AllCanvas' has a wrong offset!");
static_assert(offsetof(ALGUIManagerActor, PostTickCanvas) == 0x0002D0, "Member 'ALGUIManagerActor::PostTickCanvas' has a wrong offset!");
static_assert(offsetof(ALGUIManagerActor, RaycasterArray) == 0x0002E0, "Member 'ALGUIManagerActor::RaycasterArray' has a wrong offset!");
static_assert(offsetof(ALGUIManagerActor, CurrentInputModule) == 0x0002F0, "Member 'ALGUIManagerActor::CurrentInputModule' has a wrong offset!");
static_assert(offsetof(ALGUIManagerActor, AllSelectableArray) == 0x0002F8, "Member 'ALGUIManagerActor::AllSelectableArray' has a wrong offset!");
static_assert(offsetof(ALGUIManagerActor, SequencerManager) == 0x000308, "Member 'ALGUIManagerActor::SequencerManager' has a wrong offset!");
static_assert(offsetof(ALGUIManagerActor, DynmaicTextureAtlasMgr) == 0x000310, "Member 'ALGUIManagerActor::DynmaicTextureAtlasMgr' has a wrong offset!");
static_assert(offsetof(ALGUIManagerActor, AllRaycastTarget) == 0x000318, "Member 'ALGUIManagerActor::AllRaycastTarget' has a wrong offset!");
static_assert(offsetof(ALGUIManagerActor, LGUIBehavioursForUpdate) == 0x000328, "Member 'ALGUIManagerActor::LGUIBehavioursForUpdate' has a wrong offset!");
static_assert(offsetof(ALGUIManagerActor, AllUINiagara) == 0x000338, "Member 'ALGUIManagerActor::AllUINiagara' has a wrong offset!");
static_assert(offsetof(ALGUIManagerActor, ScreenRootPtr) == 0x000348, "Member 'ALGUIManagerActor::ScreenRootPtr' has a wrong offset!");
static_assert(offsetof(ALGUIManagerActor, LGUIBehaviours_PrefabSystemProcessing) == 0x000390, "Member 'ALGUIManagerActor::LGUIBehaviours_PrefabSystemProcessing' has a wrong offset!");
static_assert(offsetof(ALGUIManagerActor, DebugRootLayer) == 0x0003A4, "Member 'ALGUIManagerActor::DebugRootLayer' has a wrong offset!");
static_assert(offsetof(ALGUIManagerActor, DirtyHierarchyRootSet) == 0x000408, "Member 'ALGUIManagerActor::DirtyHierarchyRootSet' has a wrong offset!");
static_assert(offsetof(ALGUIManagerActor, AutoLayoutRebuildList_ParentFirst) == 0x000458, "Member 'ALGUIManagerActor::AutoLayoutRebuildList_ParentFirst' has a wrong offset!");
static_assert(offsetof(ALGUIManagerActor, AutoLayoutRebuildList_ChildrenFirst) == 0x000468, "Member 'ALGUIManagerActor::AutoLayoutRebuildList_ChildrenFirst' has a wrong offset!");
static_assert(offsetof(ALGUIManagerActor, AutoLayoutPostRebuildList) == 0x000478, "Member 'ALGUIManagerActor::AutoLayoutPostRebuildList' has a wrong offset!");

// Class LGUI.LGUIMeshComponent
// 0x0050 (0x0560 - 0x0510)
class ULGUIMeshComponent : public UMeshComponent
{
public:
	uint8                                         Pad_1185[0x50];                                    // 0x0510(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIMeshComponent">();
	}
	static class ULGUIMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIMeshComponent>();
	}
};
static_assert(alignof(ULGUIMeshComponent) == 0x000010, "Wrong alignment on ULGUIMeshComponent");
static_assert(sizeof(ULGUIMeshComponent) == 0x000560, "Wrong size on ULGUIMeshComponent");

// Class LGUI.LGUINiagaraComponent
// 0x0000 (0x06B0 - 0x06B0)
class ULGUINiagaraComponent final : public UNiagaraComponent
{
public:
	bool                                          IsUIDrawCallVisible;                               // 0x06A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSupportWorldSpace;                               // 0x06A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1186[0x6];                                     // 0x06AA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUINiagaraComponent">();
	}
	static class ULGUINiagaraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUINiagaraComponent>();
	}
};
static_assert(alignof(ULGUINiagaraComponent) == 0x000010, "Wrong alignment on ULGUINiagaraComponent");
static_assert(sizeof(ULGUINiagaraComponent) == 0x0006B0, "Wrong size on ULGUINiagaraComponent");
static_assert(offsetof(ULGUINiagaraComponent, IsUIDrawCallVisible) == 0x0006A8, "Member 'ULGUINiagaraComponent::IsUIDrawCallVisible' has a wrong offset!");
static_assert(offsetof(ULGUINiagaraComponent, IsSupportWorldSpace) == 0x0006A9, "Member 'ULGUINiagaraComponent::IsSupportWorldSpace' has a wrong offset!");

// Class LGUI.UISelectableComponent
// 0x02D0 (0x03D0 - 0x0100)
class UUISelectableComponent : public ULGUIBehaviour
{
public:
	uint8                                         Pad_1187[0x20];                                    // 0x0100(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AUIBaseActor>            TransitionActor;                                   // 0x0120(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          AllowEventBubbleUp;                                // 0x0128(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUISelectableTransitionType                   Transition;                                        // 0x0129(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1188[0x6];                                     // 0x012A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ULTweener*                              TransitionTweener;                                 // 0x0130(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 NormalColor;                                       // 0x0138(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 HighlightedColor;                                  // 0x013C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 PressedColor;                                      // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 DisabledColor;                                     // 0x0144(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 SelectedColor;                                     // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeDuration;                                      // 0x014C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULGUISpriteData_BaseObject*             NormalSprite;                                      // 0x0150(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULGUISpriteData_BaseObject*             HighlightedSprite;                                 // 0x0158(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULGUISpriteData_BaseObject*             PressedSprite;                                     // 0x0160(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULGUISpriteData_BaseObject*             DisabledSprite;                                    // 0x0168(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULGUISpriteData_BaseObject*             SelectedSprite;                                    // 0x0170(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AUIBaseActor>            NormalItem;                                        // 0x0178(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AUIBaseActor>            HighlightedItem;                                   // 0x0180(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AUIBaseActor>            PressedItem;                                       // 0x0188(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AUIBaseActor>            DisabledItem;                                      // 0x0190(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AUIBaseActor>            SelectedItem;                                      // 0x0198(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUISelectableSelectionState                   CurrentSelectionState;                             // 0x01A0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1189[0x3];                                     // 0x01A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bApplyColorToChildren;                             // 0x01A4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoScrollOnSelected;                             // 0x01A5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_118A[0x2];                                     // 0x01A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  NavigationGroupParentComponentActor;               // 0x01A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UUISelectableComponent>  NavigationGroupParentComponent;                    // 0x01B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  NavigationGroupComponentActor;                     // 0x01B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UUINavigationGroupComponent> NavigationGroupComponent;                          // 0x01C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  ScrollViewActor;                                   // 0x01C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UUIScrollViewWithScrollbarComponent> ScrollViewComponent;                               // 0x01D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UUISelectableTransitionComponent> TransitionComp;                                    // 0x01D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUISelectableNavigationMode                   NavigationLeft;                                    // 0x01E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_118B[0x7];                                     // 0x01E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUIComponentReference                NavigationLeftSpecific;                            // 0x01E8(0x0028)(Edit, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	EUISelectableNavigationMode                   NavigationRight;                                   // 0x0210(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_118C[0x7];                                     // 0x0211(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUIComponentReference                NavigationRightSpecific;                           // 0x0218(0x0028)(Edit, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	EUISelectableNavigationMode                   NavigationUp;                                      // 0x0240(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_118D[0x7];                                     // 0x0241(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUIComponentReference                NavigationUpSpecific;                              // 0x0248(0x0028)(Edit, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	EUISelectableNavigationMode                   NavigationDown;                                    // 0x0270(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_118E[0x7];                                     // 0x0271(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUIComponentReference                NavigationDownSpecific;                            // 0x0278(0x0028)(Edit, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	EUISelectableNavigationMode                   NavigationNext;                                    // 0x02A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_118F[0x7];                                     // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUIComponentReference                NavigationNextSpecific;                            // 0x02A8(0x0028)(Edit, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	EUISelectableNavigationMode                   NavigationPrev;                                    // 0x02D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1190[0x7];                                     // 0x02D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUIComponentReference                NavigationPrevSpecific;                            // 0x02D8(0x0028)(Edit, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<EStateTransferType, struct FAnimationPlayInfo> AnimationConfig;                                   // 0x0300(0x0050)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_1191[0x8];                                     // 0x0350(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULevelSequence*>                 AllAnims;                                          // 0x0358(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TDelegate<void(bool CurrentSelfInteractive)>  OnSelfInteractiveChanged;                          // 0x0368(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	bool                                          IsSelfInteractive;                                 // 0x0390(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanClickWhenDisable;                              // 0x0391(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1192[0x16];                                    // 0x0392(0x0016)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             FocusListenerDelegate;                             // 0x03A8(0x0028)(Edit, ZeroConstructor, InstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static void ResetSelectableDelegate();
	static void SetSelectableDelegate(const TDelegate<void(class UUISelectableComponent* SelectableComponent, bool bCreate)>& Delegate);
	static void SetShieldMobileHighlight(const bool Value);
	static void SetShieldPCPress(const bool Value);

	void ApplySelectionState(bool bImmediateSet);
	bool GetCanClickWhenDisable();
	EUISelectableSelectionState GetSelectionState();
	bool GetSelfInteractive();
	void NotifyFocusListener();
	void PlayUIAnimationByPlayInfo(const struct FAnimationPlayInfo& PlayInfo);
	void SetCanClickWhenDisable(bool CanClickEnbale);
	void SetHighlightedColor(const struct FColor& NewColor);
	void SetHighlightedSprite(class ULGUISpriteData_BaseObject* NewSprite);
	void SetIsCustomAnim(bool bIsCustomAnim);
	void SetIsCustomTransition(bool bIsCustomTransition);
	void SetNavigationDown(EUISelectableNavigationMode Value);
	void SetNavigationDownExplicit(class UUISelectableComponent* Value);
	void SetNavigationGroup(class UUINavigationGroupComponent* Component);
	void SetNavigationGroupParent(class UUISelectableComponent* Component);
	void SetNavigationLeft(EUISelectableNavigationMode Value);
	void SetNavigationLeftExplicit(class UUISelectableComponent* Value);
	void SetNavigationNext(EUISelectableNavigationMode Value);
	void SetNavigationNextExplicit(class UUISelectableComponent* Value);
	void SetNavigationPrev(EUISelectableNavigationMode Value);
	void SetNavigationPrevExplicit(class UUISelectableComponent* Value);
	void SetNavigationRight(EUISelectableNavigationMode Value);
	void SetNavigationRightExplicit(class UUISelectableComponent* Value);
	void SetNavigationUp(EUISelectableNavigationMode Value);
	void SetNavigationUpExplicit(class UUISelectableComponent* Value);
	void SetNormalColor(const struct FColor& NewColor);
	void SetNormalSprite(class ULGUISpriteData_BaseObject* NewSprite);
	void SetPressedColor(const struct FColor& NewColor);
	void SetPressedSprite(class ULGUISpriteData_BaseObject* NewSprite);
	void SetScrollView(class UUIScrollViewWithScrollbarComponent* Component);
	void SetSelectionState(EUISelectableSelectionState NewState);
	void SetSelfInteractive(bool InteractiveEnable);
	void SetTransitionTarget(class AUIBaseActor* Value);

	class ULGUISpriteData_BaseObject* GetDisabledSprite() const;
	struct FColor GetHighlightedColor() const;
	class ULGUISpriteData_BaseObject* GetHighlightedSprite() const;
	EUISelectableNavigationMode GetNavigationDown() const;
	class UUISelectableComponent* GetNavigationDownExplicit() const;
	EUISelectableNavigationMode GetNavigationLeft() const;
	class UUISelectableComponent* GetNavigationLeftExplicit() const;
	EUISelectableNavigationMode GetNavigationNext() const;
	class UUISelectableComponent* GetNavigationNextExplicit() const;
	EUISelectableNavigationMode GetNavigationPrev() const;
	class UUISelectableComponent* GetNavigationPrevExplicit() const;
	EUISelectableNavigationMode GetNavigationRight() const;
	class UUISelectableComponent* GetNavigationRightExplicit() const;
	EUISelectableNavigationMode GetNavigationUp() const;
	class UUISelectableComponent* GetNavigationUpExplicit() const;
	struct FColor GetNormalColor() const;
	class ULGUISpriteData_BaseObject* GetNormalSprite() const;
	struct FColor GetPressedColor() const;
	class ULGUISpriteData_BaseObject* GetPressedSprite() const;
	class ULGUISpriteData_BaseObject* GetSelectedSprite() const;
	class AUIBaseActor* GetTransitionTarget() const;
	bool IsInteractable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISelectableComponent">();
	}
	static class UUISelectableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISelectableComponent>();
	}
};
static_assert(alignof(UUISelectableComponent) == 0x000008, "Wrong alignment on UUISelectableComponent");
static_assert(sizeof(UUISelectableComponent) == 0x0003D0, "Wrong size on UUISelectableComponent");
static_assert(offsetof(UUISelectableComponent, TransitionActor) == 0x000120, "Member 'UUISelectableComponent::TransitionActor' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, AllowEventBubbleUp) == 0x000128, "Member 'UUISelectableComponent::AllowEventBubbleUp' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, Transition) == 0x000129, "Member 'UUISelectableComponent::Transition' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, TransitionTweener) == 0x000130, "Member 'UUISelectableComponent::TransitionTweener' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, NormalColor) == 0x000138, "Member 'UUISelectableComponent::NormalColor' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, HighlightedColor) == 0x00013C, "Member 'UUISelectableComponent::HighlightedColor' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, PressedColor) == 0x000140, "Member 'UUISelectableComponent::PressedColor' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, DisabledColor) == 0x000144, "Member 'UUISelectableComponent::DisabledColor' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, SelectedColor) == 0x000148, "Member 'UUISelectableComponent::SelectedColor' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, FadeDuration) == 0x00014C, "Member 'UUISelectableComponent::FadeDuration' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, NormalSprite) == 0x000150, "Member 'UUISelectableComponent::NormalSprite' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, HighlightedSprite) == 0x000158, "Member 'UUISelectableComponent::HighlightedSprite' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, PressedSprite) == 0x000160, "Member 'UUISelectableComponent::PressedSprite' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, DisabledSprite) == 0x000168, "Member 'UUISelectableComponent::DisabledSprite' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, SelectedSprite) == 0x000170, "Member 'UUISelectableComponent::SelectedSprite' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, NormalItem) == 0x000178, "Member 'UUISelectableComponent::NormalItem' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, HighlightedItem) == 0x000180, "Member 'UUISelectableComponent::HighlightedItem' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, PressedItem) == 0x000188, "Member 'UUISelectableComponent::PressedItem' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, DisabledItem) == 0x000190, "Member 'UUISelectableComponent::DisabledItem' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, SelectedItem) == 0x000198, "Member 'UUISelectableComponent::SelectedItem' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, CurrentSelectionState) == 0x0001A0, "Member 'UUISelectableComponent::CurrentSelectionState' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, bApplyColorToChildren) == 0x0001A4, "Member 'UUISelectableComponent::bApplyColorToChildren' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, bAutoScrollOnSelected) == 0x0001A5, "Member 'UUISelectableComponent::bAutoScrollOnSelected' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, NavigationGroupParentComponentActor) == 0x0001A8, "Member 'UUISelectableComponent::NavigationGroupParentComponentActor' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, NavigationGroupParentComponent) == 0x0001B0, "Member 'UUISelectableComponent::NavigationGroupParentComponent' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, NavigationGroupComponentActor) == 0x0001B8, "Member 'UUISelectableComponent::NavigationGroupComponentActor' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, NavigationGroupComponent) == 0x0001C0, "Member 'UUISelectableComponent::NavigationGroupComponent' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, ScrollViewActor) == 0x0001C8, "Member 'UUISelectableComponent::ScrollViewActor' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, ScrollViewComponent) == 0x0001D0, "Member 'UUISelectableComponent::ScrollViewComponent' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, TransitionComp) == 0x0001D8, "Member 'UUISelectableComponent::TransitionComp' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, NavigationLeft) == 0x0001E0, "Member 'UUISelectableComponent::NavigationLeft' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, NavigationLeftSpecific) == 0x0001E8, "Member 'UUISelectableComponent::NavigationLeftSpecific' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, NavigationRight) == 0x000210, "Member 'UUISelectableComponent::NavigationRight' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, NavigationRightSpecific) == 0x000218, "Member 'UUISelectableComponent::NavigationRightSpecific' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, NavigationUp) == 0x000240, "Member 'UUISelectableComponent::NavigationUp' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, NavigationUpSpecific) == 0x000248, "Member 'UUISelectableComponent::NavigationUpSpecific' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, NavigationDown) == 0x000270, "Member 'UUISelectableComponent::NavigationDown' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, NavigationDownSpecific) == 0x000278, "Member 'UUISelectableComponent::NavigationDownSpecific' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, NavigationNext) == 0x0002A0, "Member 'UUISelectableComponent::NavigationNext' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, NavigationNextSpecific) == 0x0002A8, "Member 'UUISelectableComponent::NavigationNextSpecific' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, NavigationPrev) == 0x0002D0, "Member 'UUISelectableComponent::NavigationPrev' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, NavigationPrevSpecific) == 0x0002D8, "Member 'UUISelectableComponent::NavigationPrevSpecific' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, AnimationConfig) == 0x000300, "Member 'UUISelectableComponent::AnimationConfig' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, AllAnims) == 0x000358, "Member 'UUISelectableComponent::AllAnims' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, OnSelfInteractiveChanged) == 0x000368, "Member 'UUISelectableComponent::OnSelfInteractiveChanged' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, IsSelfInteractive) == 0x000390, "Member 'UUISelectableComponent::IsSelfInteractive' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, bCanClickWhenDisable) == 0x000391, "Member 'UUISelectableComponent::bCanClickWhenDisable' has a wrong offset!");
static_assert(offsetof(UUISelectableComponent, FocusListenerDelegate) == 0x0003A8, "Member 'UUISelectableComponent::FocusListenerDelegate' has a wrong offset!");

// Class LGUI.UIExtendToggle
// 0x0408 (0x07D8 - 0x03D0)
class UUIExtendToggle final : public UUISelectableComponent
{
public:
	uint8                                         Pad_1193[0x10];                                    // 0x03D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnStateChange;                                     // 0x03E0(0x0010)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1194[0x10];                                    // 0x03F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             CanExecuteChange;                                  // 0x0400(0x0028)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHover;                                           // 0x0428(0x0010)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUnHover;                                         // 0x0438(0x0010)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUndeterminedClicked;                             // 0x0448(0x0010)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TDelegate<void(const class FString& EventName)> OnPostAudioEvent;                                  // 0x0458(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TMap<EToggleAudioTransitionState, struct FSoftObjectPath> AudioConfig;                                       // 0x0480(0x0050)(Edit, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelectedHover;                              // 0x04D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1195[0x7];                                     // 0x04D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        LongPressAudioEvent;                               // 0x04D8(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(EToggleAudioTransitionState State, const class FString& EventName)> OnPostAudioStateEvent;                             // 0x04F8(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(EToggleState State)>           OnPointEnterCallBack;                              // 0x0520(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(EToggleState State)>           OnPointExitCallBack;                               // 0x0548(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(EToggleState State)>           OnPointDownCallBack;                               // 0x0570(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(EToggleState State)>           OnPointUpCallBack;                                 // 0x0598(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(EToggleState State)>           OnPointCancelCallBack;                             // 0x05C0(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	EToggleState                                  ToggleState;                                       // 0x05E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1196[0x3];                                     // 0x05E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  ToggleGroupActor;                                  // 0x05EC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bToggleOnSelect;                                   // 0x05F4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLockStateOnSelect;                                // 0x05F5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCheckToggleSelected;                              // 0x05F6(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1197[0x1];                                     // 0x05F7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EToggleAnimationType, struct FToggleAnimationPlayInfo> ToggleAnimations;                                  // 0x05F8(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TMap<EUISelectableInteractionState, struct FToggleStateAnimation> InteractiveAnimations;                             // 0x0648(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TMap<EToggleStateSwitch, struct FToggleAnimationPlayInfo> StateSwitchAnimations;                             // 0x0698(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1198[0xF0];                                    // 0x06E8(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAllTransitionsEnable(bool bIsEnable);
	void SetToggleGroup(class AActor* TogGroupActor);
	EToggleChangeStateResult SetToggleState(EToggleState State, bool bFireEvent);
	void SetToggleStateForce(EToggleState State, bool bFireEvent, bool bIngnoreAnim);

	class UUIExtendToggleGroup* GetToggleGroup() const;
	EToggleState GetToggleState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIExtendToggle">();
	}
	static class UUIExtendToggle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIExtendToggle>();
	}
};
static_assert(alignof(UUIExtendToggle) == 0x000008, "Wrong alignment on UUIExtendToggle");
static_assert(sizeof(UUIExtendToggle) == 0x0007D8, "Wrong size on UUIExtendToggle");
static_assert(offsetof(UUIExtendToggle, OnStateChange) == 0x0003E0, "Member 'UUIExtendToggle::OnStateChange' has a wrong offset!");
static_assert(offsetof(UUIExtendToggle, CanExecuteChange) == 0x000400, "Member 'UUIExtendToggle::CanExecuteChange' has a wrong offset!");
static_assert(offsetof(UUIExtendToggle, OnHover) == 0x000428, "Member 'UUIExtendToggle::OnHover' has a wrong offset!");
static_assert(offsetof(UUIExtendToggle, OnUnHover) == 0x000438, "Member 'UUIExtendToggle::OnUnHover' has a wrong offset!");
static_assert(offsetof(UUIExtendToggle, OnUndeterminedClicked) == 0x000448, "Member 'UUIExtendToggle::OnUndeterminedClicked' has a wrong offset!");
static_assert(offsetof(UUIExtendToggle, OnPostAudioEvent) == 0x000458, "Member 'UUIExtendToggle::OnPostAudioEvent' has a wrong offset!");
static_assert(offsetof(UUIExtendToggle, AudioConfig) == 0x000480, "Member 'UUIExtendToggle::AudioConfig' has a wrong offset!");
static_assert(offsetof(UUIExtendToggle, bIgnoreSelectedHover) == 0x0004D0, "Member 'UUIExtendToggle::bIgnoreSelectedHover' has a wrong offset!");
static_assert(offsetof(UUIExtendToggle, LongPressAudioEvent) == 0x0004D8, "Member 'UUIExtendToggle::LongPressAudioEvent' has a wrong offset!");
static_assert(offsetof(UUIExtendToggle, OnPostAudioStateEvent) == 0x0004F8, "Member 'UUIExtendToggle::OnPostAudioStateEvent' has a wrong offset!");
static_assert(offsetof(UUIExtendToggle, OnPointEnterCallBack) == 0x000520, "Member 'UUIExtendToggle::OnPointEnterCallBack' has a wrong offset!");
static_assert(offsetof(UUIExtendToggle, OnPointExitCallBack) == 0x000548, "Member 'UUIExtendToggle::OnPointExitCallBack' has a wrong offset!");
static_assert(offsetof(UUIExtendToggle, OnPointDownCallBack) == 0x000570, "Member 'UUIExtendToggle::OnPointDownCallBack' has a wrong offset!");
static_assert(offsetof(UUIExtendToggle, OnPointUpCallBack) == 0x000598, "Member 'UUIExtendToggle::OnPointUpCallBack' has a wrong offset!");
static_assert(offsetof(UUIExtendToggle, OnPointCancelCallBack) == 0x0005C0, "Member 'UUIExtendToggle::OnPointCancelCallBack' has a wrong offset!");
static_assert(offsetof(UUIExtendToggle, ToggleState) == 0x0005E8, "Member 'UUIExtendToggle::ToggleState' has a wrong offset!");
static_assert(offsetof(UUIExtendToggle, ToggleGroupActor) == 0x0005EC, "Member 'UUIExtendToggle::ToggleGroupActor' has a wrong offset!");
static_assert(offsetof(UUIExtendToggle, bToggleOnSelect) == 0x0005F4, "Member 'UUIExtendToggle::bToggleOnSelect' has a wrong offset!");
static_assert(offsetof(UUIExtendToggle, bLockStateOnSelect) == 0x0005F5, "Member 'UUIExtendToggle::bLockStateOnSelect' has a wrong offset!");
static_assert(offsetof(UUIExtendToggle, bCheckToggleSelected) == 0x0005F6, "Member 'UUIExtendToggle::bCheckToggleSelected' has a wrong offset!");
static_assert(offsetof(UUIExtendToggle, ToggleAnimations) == 0x0005F8, "Member 'UUIExtendToggle::ToggleAnimations' has a wrong offset!");
static_assert(offsetof(UUIExtendToggle, InteractiveAnimations) == 0x000648, "Member 'UUIExtendToggle::InteractiveAnimations' has a wrong offset!");
static_assert(offsetof(UUIExtendToggle, StateSwitchAnimations) == 0x000698, "Member 'UUIExtendToggle::StateSwitchAnimations' has a wrong offset!");

// Class LGUI.LGUIPlayTween
// 0x0088 (0x00B8 - 0x0030)
class ULGUIPlayTween : public UObject
{
public:
	ELTweenLoop                                   LoopType;                                          // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1199[0x3];                                     // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LoopCount;                                         // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELTweenEase                                   EaseType;                                          // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_119A[0x7];                                     // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            EaseCurve;                                         // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Duration;                                          // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartDelay;                                        // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLGUIDrawableEvent                     OnStart;                                           // 0x0050(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FLGUIDrawableEvent                     OnUpdateProgress;                                  // 0x0068(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FLGUIDrawableEvent                     OnComplete;                                        // 0x0080(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	class ULTweener*                              Tweener;                                           // 0x0098(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_119B[0x18];                                    // 0x00A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FLGUIDelegateHandleWrapper RegisterOnComplete(const TDelegate<void()>& InDelegate);
	void Start();
	void Stop();
	void UnregisterOnComplete(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);

	class ULTweener* GetTweener() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPlayTween">();
	}
	static class ULGUIPlayTween* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPlayTween>();
	}
};
static_assert(alignof(ULGUIPlayTween) == 0x000008, "Wrong alignment on ULGUIPlayTween");
static_assert(sizeof(ULGUIPlayTween) == 0x0000B8, "Wrong size on ULGUIPlayTween");
static_assert(offsetof(ULGUIPlayTween, LoopType) == 0x000030, "Member 'ULGUIPlayTween::LoopType' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween, LoopCount) == 0x000034, "Member 'ULGUIPlayTween::LoopCount' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween, EaseType) == 0x000038, "Member 'ULGUIPlayTween::EaseType' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween, EaseCurve) == 0x000040, "Member 'ULGUIPlayTween::EaseCurve' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween, Duration) == 0x000048, "Member 'ULGUIPlayTween::Duration' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween, StartDelay) == 0x00004C, "Member 'ULGUIPlayTween::StartDelay' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween, OnStart) == 0x000050, "Member 'ULGUIPlayTween::OnStart' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween, OnUpdateProgress) == 0x000068, "Member 'ULGUIPlayTween::OnUpdateProgress' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween, OnComplete) == 0x000080, "Member 'ULGUIPlayTween::OnComplete' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween, Tweener) == 0x000098, "Member 'ULGUIPlayTween::Tweener' has a wrong offset!");

// Class LGUI.LGUIPlayTween_Float
// 0x0020 (0x00D8 - 0x00B8)
class ULGUIPlayTween_Float final : public ULGUIPlayTween
{
public:
	float                                         From;                                              // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         To;                                                // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLGUIDrawableEvent                     OnUpdateValue;                                     // 0x00C0(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPlayTween_Float">();
	}
	static class ULGUIPlayTween_Float* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPlayTween_Float>();
	}
};
static_assert(alignof(ULGUIPlayTween_Float) == 0x000008, "Wrong alignment on ULGUIPlayTween_Float");
static_assert(sizeof(ULGUIPlayTween_Float) == 0x0000D8, "Wrong size on ULGUIPlayTween_Float");
static_assert(offsetof(ULGUIPlayTween_Float, From) == 0x0000B8, "Member 'ULGUIPlayTween_Float::From' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween_Float, To) == 0x0000BC, "Member 'ULGUIPlayTween_Float::To' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween_Float, OnUpdateValue) == 0x0000C0, "Member 'ULGUIPlayTween_Float::OnUpdateValue' has a wrong offset!");

// Class LGUI.UILayoutWithAnimation
// 0x0020 (0x0190 - 0x0170)
class UUILayoutWithAnimation : public UUILayoutBase
{
public:
	EUILayoutChangePositionAnimationType          AnimationType;                                     // 0x0170(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_119C[0x3];                                     // 0x0171(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimationDuration;                                 // 0x0174(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ULTweener*>                      TweenerArray;                                      // 0x0178(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_119D[0x8];                                     // 0x0188(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelAnimation(bool CallComplete);
	void SetAnimationDuration(float Value);
	void SetAnimationType(EUILayoutChangePositionAnimationType Value);

	float GetAnimationDuration() const;
	EUILayoutChangePositionAnimationType GetAnimationType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILayoutWithAnimation">();
	}
	static class UUILayoutWithAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILayoutWithAnimation>();
	}
};
static_assert(alignof(UUILayoutWithAnimation) == 0x000008, "Wrong alignment on UUILayoutWithAnimation");
static_assert(sizeof(UUILayoutWithAnimation) == 0x000190, "Wrong size on UUILayoutWithAnimation");
static_assert(offsetof(UUILayoutWithAnimation, AnimationType) == 0x000170, "Member 'UUILayoutWithAnimation::AnimationType' has a wrong offset!");
static_assert(offsetof(UUILayoutWithAnimation, AnimationDuration) == 0x000174, "Member 'UUILayoutWithAnimation::AnimationDuration' has a wrong offset!");
static_assert(offsetof(UUILayoutWithAnimation, TweenerArray) == 0x000178, "Member 'UUILayoutWithAnimation::TweenerArray' has a wrong offset!");

// Class LGUI.LGUIPlayTween_Color
// 0x0020 (0x00D8 - 0x00B8)
class ULGUIPlayTween_Color final : public ULGUIPlayTween
{
public:
	struct FColor                                 From;                                              // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 To;                                                // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLGUIDrawableEvent                     OnUpdateValue;                                     // 0x00C0(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPlayTween_Color">();
	}
	static class ULGUIPlayTween_Color* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPlayTween_Color>();
	}
};
static_assert(alignof(ULGUIPlayTween_Color) == 0x000008, "Wrong alignment on ULGUIPlayTween_Color");
static_assert(sizeof(ULGUIPlayTween_Color) == 0x0000D8, "Wrong size on ULGUIPlayTween_Color");
static_assert(offsetof(ULGUIPlayTween_Color, From) == 0x0000B8, "Member 'ULGUIPlayTween_Color::From' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween_Color, To) == 0x0000BC, "Member 'ULGUIPlayTween_Color::To' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween_Color, OnUpdateValue) == 0x0000C0, "Member 'ULGUIPlayTween_Color::OnUpdateValue' has a wrong offset!");

// Class LGUI.LGUIPlayTween_Int
// 0x0020 (0x00D8 - 0x00B8)
class ULGUIPlayTween_Int final : public ULGUIPlayTween
{
public:
	int32                                         From;                                              // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         To;                                                // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLGUIDrawableEvent                     OnUpdateValue;                                     // 0x00C0(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPlayTween_Int">();
	}
	static class ULGUIPlayTween_Int* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPlayTween_Int>();
	}
};
static_assert(alignof(ULGUIPlayTween_Int) == 0x000008, "Wrong alignment on ULGUIPlayTween_Int");
static_assert(sizeof(ULGUIPlayTween_Int) == 0x0000D8, "Wrong size on ULGUIPlayTween_Int");
static_assert(offsetof(ULGUIPlayTween_Int, From) == 0x0000B8, "Member 'ULGUIPlayTween_Int::From' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween_Int, To) == 0x0000BC, "Member 'ULGUIPlayTween_Int::To' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween_Int, OnUpdateValue) == 0x0000C0, "Member 'ULGUIPlayTween_Int::OnUpdateValue' has a wrong offset!");

// Class LGUI.UIMultiTemplateLayout
// 0x0020 (0x01B0 - 0x0190)
class UUIMultiTemplateLayout final : public UUILayoutWithAnimation
{
public:
	ELGUILayoutDirectionType                      DirectionType;                                     // 0x0190(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_119E[0x3];                                     // 0x0191(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMargin                                Padding;                                           // 0x0194(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              Spacing;                                           // 0x01A4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          SizeFitToChildren;                                 // 0x01AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_119F[0x3];                                     // 0x01AD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetDirectionType(ELGUILayoutDirectionType NewDirectionType);
	void SetPadding(const struct FMargin& Value);
	void SetSizeFitToChildren(bool Value);
	void SetSpacing(const struct FVector2D& Value);

	ELGUILayoutDirectionType GetDirectionType() const;
	struct FMargin GetPadding() const;
	bool GetSizeFitToChildren() const;
	struct FVector2D GetSpacing() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIMultiTemplateLayout">();
	}
	static class UUIMultiTemplateLayout* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIMultiTemplateLayout>();
	}
};
static_assert(alignof(UUIMultiTemplateLayout) == 0x000008, "Wrong alignment on UUIMultiTemplateLayout");
static_assert(sizeof(UUIMultiTemplateLayout) == 0x0001B0, "Wrong size on UUIMultiTemplateLayout");
static_assert(offsetof(UUIMultiTemplateLayout, DirectionType) == 0x000190, "Member 'UUIMultiTemplateLayout::DirectionType' has a wrong offset!");
static_assert(offsetof(UUIMultiTemplateLayout, Padding) == 0x000194, "Member 'UUIMultiTemplateLayout::Padding' has a wrong offset!");
static_assert(offsetof(UUIMultiTemplateLayout, Spacing) == 0x0001A4, "Member 'UUIMultiTemplateLayout::Spacing' has a wrong offset!");
static_assert(offsetof(UUIMultiTemplateLayout, SizeFitToChildren) == 0x0001AC, "Member 'UUIMultiTemplateLayout::SizeFitToChildren' has a wrong offset!");

// Class LGUI.LGUIPlayTween_LinearColor
// 0x0038 (0x00F0 - 0x00B8)
class ULGUIPlayTween_LinearColor final : public ULGUIPlayTween
{
public:
	struct FLinearColor                           From;                                              // 0x00B8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           To;                                                // 0x00C8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLGUIDrawableEvent                     OnUpdateValue;                                     // 0x00D8(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPlayTween_LinearColor">();
	}
	static class ULGUIPlayTween_LinearColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPlayTween_LinearColor>();
	}
};
static_assert(alignof(ULGUIPlayTween_LinearColor) == 0x000008, "Wrong alignment on ULGUIPlayTween_LinearColor");
static_assert(sizeof(ULGUIPlayTween_LinearColor) == 0x0000F0, "Wrong size on ULGUIPlayTween_LinearColor");
static_assert(offsetof(ULGUIPlayTween_LinearColor, From) == 0x0000B8, "Member 'ULGUIPlayTween_LinearColor::From' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween_LinearColor, To) == 0x0000C8, "Member 'ULGUIPlayTween_LinearColor::To' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween_LinearColor, OnUpdateValue) == 0x0000D8, "Member 'ULGUIPlayTween_LinearColor::OnUpdateValue' has a wrong offset!");

// Class LGUI.LGUIPlayTween_Quaternion
// 0x0048 (0x0100 - 0x00B8)
class ULGUIPlayTween_Quaternion final : public ULGUIPlayTween
{
public:
	uint8                                         Pad_11A0[0x8];                                     // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  From;                                              // 0x00C0(0x0010)(Edit, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FQuat                                  To;                                                // 0x00D0(0x0010)(Edit, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLGUIDrawableEvent                     OnUpdateValue;                                     // 0x00E0(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_11A1[0x8];                                     // 0x00F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPlayTween_Quaternion">();
	}
	static class ULGUIPlayTween_Quaternion* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPlayTween_Quaternion>();
	}
};
static_assert(alignof(ULGUIPlayTween_Quaternion) == 0x000010, "Wrong alignment on ULGUIPlayTween_Quaternion");
static_assert(sizeof(ULGUIPlayTween_Quaternion) == 0x000100, "Wrong size on ULGUIPlayTween_Quaternion");
static_assert(offsetof(ULGUIPlayTween_Quaternion, From) == 0x0000C0, "Member 'ULGUIPlayTween_Quaternion::From' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween_Quaternion, To) == 0x0000D0, "Member 'ULGUIPlayTween_Quaternion::To' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween_Quaternion, OnUpdateValue) == 0x0000E0, "Member 'ULGUIPlayTween_Quaternion::OnUpdateValue' has a wrong offset!");

// Class LGUI.UIInteractionGroup
// 0x0010 (0x00D0 - 0x00C0)
class UUIInteractionGroup final : public UActorComponent
{
public:
	bool                                          bInteractable;                                     // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreParentGroup;                                // 0x00C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11A2[0x6];                                     // 0x00C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIItem*                                CacheUIItem;                                       // 0x00C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetIgnoreParentGroup(bool Value);
	void SetInteractable(bool Value);

	bool GetIgnoreParentGroup() const;
	bool GetInteractable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIInteractionGroup">();
	}
	static class UUIInteractionGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIInteractionGroup>();
	}
};
static_assert(alignof(UUIInteractionGroup) == 0x000008, "Wrong alignment on UUIInteractionGroup");
static_assert(sizeof(UUIInteractionGroup) == 0x0000D0, "Wrong size on UUIInteractionGroup");
static_assert(offsetof(UUIInteractionGroup, bInteractable) == 0x0000C0, "Member 'UUIInteractionGroup::bInteractable' has a wrong offset!");
static_assert(offsetof(UUIInteractionGroup, bIgnoreParentGroup) == 0x0000C1, "Member 'UUIInteractionGroup::bIgnoreParentGroup' has a wrong offset!");
static_assert(offsetof(UUIInteractionGroup, CacheUIItem) == 0x0000C8, "Member 'UUIInteractionGroup::CacheUIItem' has a wrong offset!");

// Class LGUI.LGUIPlayTween_Rotator
// 0x0030 (0x00E8 - 0x00B8)
class ULGUIPlayTween_Rotator final : public ULGUIPlayTween
{
public:
	struct FRotator                               From;                                              // 0x00B8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               To;                                                // 0x00C4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLGUIDrawableEvent                     OnUpdateValue;                                     // 0x00D0(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPlayTween_Rotator">();
	}
	static class ULGUIPlayTween_Rotator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPlayTween_Rotator>();
	}
};
static_assert(alignof(ULGUIPlayTween_Rotator) == 0x000008, "Wrong alignment on ULGUIPlayTween_Rotator");
static_assert(sizeof(ULGUIPlayTween_Rotator) == 0x0000E8, "Wrong size on ULGUIPlayTween_Rotator");
static_assert(offsetof(ULGUIPlayTween_Rotator, From) == 0x0000B8, "Member 'ULGUIPlayTween_Rotator::From' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween_Rotator, To) == 0x0000C4, "Member 'ULGUIPlayTween_Rotator::To' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween_Rotator, OnUpdateValue) == 0x0000D0, "Member 'ULGUIPlayTween_Rotator::OnUpdateValue' has a wrong offset!");

// Class LGUI.LGUIPlayTween_Vector2
// 0x0028 (0x00E0 - 0x00B8)
class ULGUIPlayTween_Vector2 final : public ULGUIPlayTween
{
public:
	struct FVector2D                              From;                                              // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              To;                                                // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLGUIDrawableEvent                     OnUpdateValue;                                     // 0x00C8(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPlayTween_Vector2">();
	}
	static class ULGUIPlayTween_Vector2* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPlayTween_Vector2>();
	}
};
static_assert(alignof(ULGUIPlayTween_Vector2) == 0x000008, "Wrong alignment on ULGUIPlayTween_Vector2");
static_assert(sizeof(ULGUIPlayTween_Vector2) == 0x0000E0, "Wrong size on ULGUIPlayTween_Vector2");
static_assert(offsetof(ULGUIPlayTween_Vector2, From) == 0x0000B8, "Member 'ULGUIPlayTween_Vector2::From' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween_Vector2, To) == 0x0000C0, "Member 'ULGUIPlayTween_Vector2::To' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween_Vector2, OnUpdateValue) == 0x0000C8, "Member 'ULGUIPlayTween_Vector2::OnUpdateValue' has a wrong offset!");

// Class LGUI.UIFrameAnimController
// 0x0030 (0x0130 - 0x0100)
class UUIFrameAnimController final : public ULGUIBehaviour
{
public:
	float                                         FrameInterval;                                     // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseCustomFrameCount;                              // 0x0104(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11A3[0x3];                                     // 0x0105(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BeginFrame;                                        // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CustomFrameCount;                                  // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11A4[0x20];                                    // 0x0110(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Pause();
	void Play(bool bLooping);
	void Resume();
	void Stop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFrameAnimController">();
	}
	static class UUIFrameAnimController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFrameAnimController>();
	}
};
static_assert(alignof(UUIFrameAnimController) == 0x000008, "Wrong alignment on UUIFrameAnimController");
static_assert(sizeof(UUIFrameAnimController) == 0x000130, "Wrong size on UUIFrameAnimController");
static_assert(offsetof(UUIFrameAnimController, FrameInterval) == 0x000100, "Member 'UUIFrameAnimController::FrameInterval' has a wrong offset!");
static_assert(offsetof(UUIFrameAnimController, bUseCustomFrameCount) == 0x000104, "Member 'UUIFrameAnimController::bUseCustomFrameCount' has a wrong offset!");
static_assert(offsetof(UUIFrameAnimController, BeginFrame) == 0x000108, "Member 'UUIFrameAnimController::BeginFrame' has a wrong offset!");
static_assert(offsetof(UUIFrameAnimController, CustomFrameCount) == 0x00010C, "Member 'UUIFrameAnimController::CustomFrameCount' has a wrong offset!");

// Class LGUI.LGUIPlayTween_Vector3
// 0x0030 (0x00E8 - 0x00B8)
class ULGUIPlayTween_Vector3 final : public ULGUIPlayTween
{
public:
	struct FVector                                From;                                              // 0x00B8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                To;                                                // 0x00C4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLGUIDrawableEvent                     OnUpdateValue;                                     // 0x00D0(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPlayTween_Vector3">();
	}
	static class ULGUIPlayTween_Vector3* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPlayTween_Vector3>();
	}
};
static_assert(alignof(ULGUIPlayTween_Vector3) == 0x000008, "Wrong alignment on ULGUIPlayTween_Vector3");
static_assert(sizeof(ULGUIPlayTween_Vector3) == 0x0000E8, "Wrong size on ULGUIPlayTween_Vector3");
static_assert(offsetof(ULGUIPlayTween_Vector3, From) == 0x0000B8, "Member 'ULGUIPlayTween_Vector3::From' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween_Vector3, To) == 0x0000C4, "Member 'ULGUIPlayTween_Vector3::To' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween_Vector3, OnUpdateValue) == 0x0000D0, "Member 'ULGUIPlayTween_Vector3::OnUpdateValue' has a wrong offset!");

// Class LGUI.LGUIPlayTween_Vector4
// 0x0048 (0x0100 - 0x00B8)
class ULGUIPlayTween_Vector4 final : public ULGUIPlayTween
{
public:
	uint8                                         Pad_11A5[0x8];                                     // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4                               From;                                              // 0x00C0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector4                               To;                                                // 0x00D0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLGUIDrawableEvent                     OnUpdateValue;                                     // 0x00E0(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_11A6[0x8];                                     // 0x00F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPlayTween_Vector4">();
	}
	static class ULGUIPlayTween_Vector4* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPlayTween_Vector4>();
	}
};
static_assert(alignof(ULGUIPlayTween_Vector4) == 0x000010, "Wrong alignment on ULGUIPlayTween_Vector4");
static_assert(sizeof(ULGUIPlayTween_Vector4) == 0x000100, "Wrong size on ULGUIPlayTween_Vector4");
static_assert(offsetof(ULGUIPlayTween_Vector4, From) == 0x0000C0, "Member 'ULGUIPlayTween_Vector4::From' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween_Vector4, To) == 0x0000D0, "Member 'ULGUIPlayTween_Vector4::To' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTween_Vector4, OnUpdateValue) == 0x0000E0, "Member 'ULGUIPlayTween_Vector4::OnUpdateValue' has a wrong offset!");

// Class LGUI.UILayoutInterface
// 0x0000 (0x0030 - 0x0030)
class IUILayoutInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILayoutInterface">();
	}
	static class IUILayoutInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IUILayoutInterface>();
	}
};
static_assert(alignof(IUILayoutInterface) == 0x000008, "Wrong alignment on IUILayoutInterface");
static_assert(sizeof(IUILayoutInterface) == 0x000030, "Wrong size on IUILayoutInterface");

// Class LGUI.LGUIPlayTweenComponent
// 0x0010 (0x00D0 - 0x00C0)
class ULGUIPlayTweenComponent final : public UActorComponent
{
public:
	bool                                          PlayOnStart;                                       // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11A7[0x7];                                     // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULGUIPlayTween*                         PlayTween;                                         // 0x00C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Play();
	void Stop();

	class ULGUIPlayTween* GetPlayTween() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPlayTweenComponent">();
	}
	static class ULGUIPlayTweenComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPlayTweenComponent>();
	}
};
static_assert(alignof(ULGUIPlayTweenComponent) == 0x000008, "Wrong alignment on ULGUIPlayTweenComponent");
static_assert(sizeof(ULGUIPlayTweenComponent) == 0x0000D0, "Wrong size on ULGUIPlayTweenComponent");
static_assert(offsetof(ULGUIPlayTweenComponent, PlayOnStart) == 0x0000C0, "Member 'ULGUIPlayTweenComponent::PlayOnStart' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTweenComponent, PlayTween) == 0x0000C8, "Member 'ULGUIPlayTweenComponent::PlayTween' has a wrong offset!");

// Class LGUI.LGUIPlayTweenSequenceComponent
// 0x0038 (0x00F8 - 0x00C0)
class ULGUIPlayTweenSequenceComponent final : public UActorComponent
{
public:
	bool                                          PlayOnStart;                                       // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11A8[0x7];                                     // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULGUIPlayTween*>                 PlayTweenArray;                                    // 0x00C8(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FLGUIDrawableEvent                     OnComplete;                                        // 0x00D8(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_11A9[0x8];                                     // 0x00F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Play();
	void Stop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPlayTweenSequenceComponent">();
	}
	static class ULGUIPlayTweenSequenceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPlayTweenSequenceComponent>();
	}
};
static_assert(alignof(ULGUIPlayTweenSequenceComponent) == 0x000008, "Wrong alignment on ULGUIPlayTweenSequenceComponent");
static_assert(sizeof(ULGUIPlayTweenSequenceComponent) == 0x0000F8, "Wrong size on ULGUIPlayTweenSequenceComponent");
static_assert(offsetof(ULGUIPlayTweenSequenceComponent, PlayOnStart) == 0x0000C0, "Member 'ULGUIPlayTweenSequenceComponent::PlayOnStart' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTweenSequenceComponent, PlayTweenArray) == 0x0000C8, "Member 'ULGUIPlayTweenSequenceComponent::PlayTweenArray' has a wrong offset!");
static_assert(offsetof(ULGUIPlayTweenSequenceComponent, OnComplete) == 0x0000D8, "Member 'ULGUIPlayTweenSequenceComponent::OnComplete' has a wrong offset!");

// Class LGUI.UIBatchGeometryRenderable
// 0x0200 (0x0760 - 0x0560)
#pragma pack(push, 0x1)
class alignas(0x10) UUIBatchGeometryRenderable : public UUIBaseRenderable
{
public:
	uint8                                         Pad_11AA[0xE0];                                    // 0x0560(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, float>                      CustomScalarParameterTMap;                         // 0x0640(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FName, class UTexture*>            CustomTextureParameterTMap;                        // 0x0690(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FName, struct FLinearColor>        CustomVectorParameterTMap;                         // 0x06E0(0x0050)(NativeAccessSpecifierPublic)
	class UMaterialInterface*                     CustomUIMaterial;                                  // 0x0730(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSelfRender;                                     // 0x0738(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsGray;                                           // 0x0739(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsColorRevert;                                    // 0x073A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRaycastComplex;                                   // 0x073B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11AB[0x4];                                     // 0x073C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIDrawcallMesh*                        UiMesh;                                            // 0x0740(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               UiMaterial;                                        // 0x0748(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11AC[0x8];                                     // 0x0750(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearCustomMaterialParameterInMap();
	bool GetRaycastComplex();
	void SetCustomMaterialScalarParameter(class FName ParamterName, float Value);
	void SetCustomMaterialTextureParameter(class FName ParameterName, class UTexture* Value);
	void SetCustomMaterialVectorParameter(class FName ParamterName, const struct FLinearColor& Value);
	void SetCustomUIMaterial(class UMaterialInterface* InMat);
	void SetIsColorRevert(bool Value);
	void SetIsGray(bool Value);
	void SetIsSelfRender(bool Value);
	void SetRaycastComplex(bool NewValue);

	class UMaterialInterface* GetCustomUIMaterial() const;
	bool GetIsSelfRender() const;
	class UMaterialInstanceDynamic* GetMaterialInstanceDynamic() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBatchGeometryRenderable">();
	}
	static class UUIBatchGeometryRenderable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBatchGeometryRenderable>();
	}
};
#pragma pack(pop)
static_assert(alignof(UUIBatchGeometryRenderable) == 0x000010, "Wrong alignment on UUIBatchGeometryRenderable");
static_assert(sizeof(UUIBatchGeometryRenderable) == 0x000760, "Wrong size on UUIBatchGeometryRenderable");
static_assert(offsetof(UUIBatchGeometryRenderable, CustomScalarParameterTMap) == 0x000640, "Member 'UUIBatchGeometryRenderable::CustomScalarParameterTMap' has a wrong offset!");
static_assert(offsetof(UUIBatchGeometryRenderable, CustomTextureParameterTMap) == 0x000690, "Member 'UUIBatchGeometryRenderable::CustomTextureParameterTMap' has a wrong offset!");
static_assert(offsetof(UUIBatchGeometryRenderable, CustomVectorParameterTMap) == 0x0006E0, "Member 'UUIBatchGeometryRenderable::CustomVectorParameterTMap' has a wrong offset!");
static_assert(offsetof(UUIBatchGeometryRenderable, CustomUIMaterial) == 0x000730, "Member 'UUIBatchGeometryRenderable::CustomUIMaterial' has a wrong offset!");
static_assert(offsetof(UUIBatchGeometryRenderable, bIsSelfRender) == 0x000738, "Member 'UUIBatchGeometryRenderable::bIsSelfRender' has a wrong offset!");
static_assert(offsetof(UUIBatchGeometryRenderable, bIsGray) == 0x000739, "Member 'UUIBatchGeometryRenderable::bIsGray' has a wrong offset!");
static_assert(offsetof(UUIBatchGeometryRenderable, bIsColorRevert) == 0x00073A, "Member 'UUIBatchGeometryRenderable::bIsColorRevert' has a wrong offset!");
static_assert(offsetof(UUIBatchGeometryRenderable, bRaycastComplex) == 0x00073B, "Member 'UUIBatchGeometryRenderable::bRaycastComplex' has a wrong offset!");
static_assert(offsetof(UUIBatchGeometryRenderable, UiMesh) == 0x000740, "Member 'UUIBatchGeometryRenderable::UiMesh' has a wrong offset!");
static_assert(offsetof(UUIBatchGeometryRenderable, UiMaterial) == 0x000748, "Member 'UUIBatchGeometryRenderable::UiMaterial' has a wrong offset!");

// Class LGUI.UISpriteBase
// 0x0010 (0x0770 - 0x0760)
#pragma pack(push, 0x1)
class alignas(0x10) UUISpriteBase : public UUIBatchGeometryRenderable
{
public:
	class ULGUISpriteData_BaseObject*             Sprite;                                            // 0x0758(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11AE[0x8];                                     // 0x0760(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSizeFromSpriteData();
	void SetSprite(class ULGUISpriteData_BaseObject* NewSprite, bool SetSize);

	class ULGUISpriteData_BaseObject* GetSprite() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISpriteBase">();
	}
	static class UUISpriteBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISpriteBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(UUISpriteBase) == 0x000010, "Wrong alignment on UUISpriteBase");
static_assert(sizeof(UUISpriteBase) == 0x000770, "Wrong size on UUISpriteBase");
static_assert(offsetof(UUISpriteBase, Sprite) == 0x000758, "Member 'UUISpriteBase::Sprite' has a wrong offset!");

// Class LGUI.UI2DLineRendererBase
// 0x0010 (0x0780 - 0x0770)
class UUI2DLineRendererBase : public UUISpriteBase
{
public:
	float                                         LineWidth;                                         // 0x0768(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUI2DLineRenderer_EndType                     EndType;                                           // 0x076C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11B0[0x3];                                     // 0x076D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LineWidthOffset;                                   // 0x0770(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFixedThickness;                                   // 0x0774(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11B1[0xB];                                     // 0x0775(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ULTweener* LineWidthTo(float EndValue, float Duration, float Delay, ELTweenEase EaseType);
	void SetEndType(EUI2DLineRenderer_EndType NewValue);
	void SetLineWidth(float NewValue);
	void SetLineWidthOffset(float NewValue);

	EUI2DLineRenderer_EndType GetEndType() const;
	float GetLineWidth() const;
	float GetLineWidthOffset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI2DLineRendererBase">();
	}
	static class UUI2DLineRendererBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI2DLineRendererBase>();
	}
};
static_assert(alignof(UUI2DLineRendererBase) == 0x000010, "Wrong alignment on UUI2DLineRendererBase");
static_assert(sizeof(UUI2DLineRendererBase) == 0x000780, "Wrong size on UUI2DLineRendererBase");
static_assert(offsetof(UUI2DLineRendererBase, LineWidth) == 0x000768, "Member 'UUI2DLineRendererBase::LineWidth' has a wrong offset!");
static_assert(offsetof(UUI2DLineRendererBase, EndType) == 0x00076C, "Member 'UUI2DLineRendererBase::EndType' has a wrong offset!");
static_assert(offsetof(UUI2DLineRendererBase, LineWidthOffset) == 0x000770, "Member 'UUI2DLineRendererBase::LineWidthOffset' has a wrong offset!");
static_assert(offsetof(UUI2DLineRendererBase, bFixedThickness) == 0x000774, "Member 'UUI2DLineRendererBase::bFixedThickness' has a wrong offset!");

// Class LGUI.UIPolygonLine
// 0x0030 (0x07B0 - 0x0780)
class UUIPolygonLine final : public UUI2DLineRendererBase
{
public:
	bool                                          FullCycle;                                         // 0x0780(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11B3[0x3];                                     // 0x0781(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartAngle;                                        // 0x0784(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndAngle;                                          // 0x0788(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Sides;                                             // 0x078C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 VertexOffsetArray;                                 // 0x0790(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FVector2D>                      CurrentPointArray;                                 // 0x07A0(0x0010)(Edit, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	class ULTweener* EndAngleTo(float EndValue, float Duration, float Delay, ELTweenEase EaseType);
	void SetEndAngle(float Value);
	void SetSides(int32 Value);
	void SetStartAngle(float Value);
	void SetVertexOffsetArray(const TArray<float>& Value);
	class ULTweener* StartAngleTo(float EndValue, float Duration, float Delay, ELTweenEase EaseType);

	float GetEndAngle() const;
	int32 GetSides() const;
	float GetStartAngle() const;
	const TArray<float> GetVertexOffsetArray() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPolygonLine">();
	}
	static class UUIPolygonLine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPolygonLine>();
	}
};
static_assert(alignof(UUIPolygonLine) == 0x000010, "Wrong alignment on UUIPolygonLine");
static_assert(sizeof(UUIPolygonLine) == 0x0007B0, "Wrong size on UUIPolygonLine");
static_assert(offsetof(UUIPolygonLine, FullCycle) == 0x000780, "Member 'UUIPolygonLine::FullCycle' has a wrong offset!");
static_assert(offsetof(UUIPolygonLine, StartAngle) == 0x000784, "Member 'UUIPolygonLine::StartAngle' has a wrong offset!");
static_assert(offsetof(UUIPolygonLine, EndAngle) == 0x000788, "Member 'UUIPolygonLine::EndAngle' has a wrong offset!");
static_assert(offsetof(UUIPolygonLine, Sides) == 0x00078C, "Member 'UUIPolygonLine::Sides' has a wrong offset!");
static_assert(offsetof(UUIPolygonLine, VertexOffsetArray) == 0x000790, "Member 'UUIPolygonLine::VertexOffsetArray' has a wrong offset!");
static_assert(offsetof(UUIPolygonLine, CurrentPointArray) == 0x0007A0, "Member 'UUIPolygonLine::CurrentPointArray' has a wrong offset!");

// Class LGUI.LGUIPointerClickInterface
// 0x0000 (0x0030 - 0x0030)
class ILGUIPointerClickInterface final : public IInterface
{
public:
	bool OnPointerClick(class ULGUIPointerEventData* EventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPointerClickInterface">();
	}
	static class ILGUIPointerClickInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILGUIPointerClickInterface>();
	}
};
static_assert(alignof(ILGUIPointerClickInterface) == 0x000008, "Wrong alignment on ILGUIPointerClickInterface");
static_assert(sizeof(ILGUIPointerClickInterface) == 0x000030, "Wrong size on ILGUIPointerClickInterface");

// Class LGUI.LGUIPointerDownUpInterface
// 0x0000 (0x0030 - 0x0030)
class ILGUIPointerDownUpInterface final : public IInterface
{
public:
	bool OnPointerDown(class ULGUIPointerEventData* EventData);
	bool OnPointerUp(class ULGUIPointerEventData* EventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPointerDownUpInterface">();
	}
	static class ILGUIPointerDownUpInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILGUIPointerDownUpInterface>();
	}
};
static_assert(alignof(ILGUIPointerDownUpInterface) == 0x000008, "Wrong alignment on ILGUIPointerDownUpInterface");
static_assert(sizeof(ILGUIPointerDownUpInterface) == 0x000030, "Wrong size on ILGUIPointerDownUpInterface");

// Class LGUI.UINavigationGroupComponent
// 0x0108 (0x0208 - 0x0100)
class UUINavigationGroupComponent final : public ULGUIBehaviour
{
public:
	uint8                                         Pad_11B9[0xA0];                                    // 0x0100(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	EUINavigationWrapMode                         HorizontalWrapMode;                                // 0x01A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUINavigationPriorityMode                     HorizontalPriorityMode;                            // 0x01A1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUINavigationWrapMode                         VerticalWrapMode;                                  // 0x01A2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUINavigationPriorityMode                     VerticalPriorityMode;                              // 0x01A3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  PrevNavigationGroupActor;                          // 0x01A4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UUINavigationGroupComponent> PrevNavigationGroup;                               // 0x01AC(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  NextNavigationGroupActor;                          // 0x01B4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UUINavigationGroupComponent> NextNavigationGroup;                               // 0x01BC(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PrevNavigationGroupName;                           // 0x01C4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NextNavigationGroupName;                           // 0x01D0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NavigationGroupName;                               // 0x01DC(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class AActor>>          DefaultNavigateActors;                             // 0x01E8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          BookMark;                                          // 0x01F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ScrollBall;                                        // 0x01F9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MouseCanJump;                                      // 0x01FA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoSearch;                                        // 0x01FB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SelectableMemory;                                  // 0x01FC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11BA[0x3];                                     // 0x01FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ViewId;                                            // 0x0200(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11BB[0x4];                                     // 0x0204(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ResetNavigateGroupDelegate();
	static void SetNavigateGroupDelegate(const TDelegate<void(class UUINavigationGroupComponent* NavigationGroupComponent, EUINavigationGroupMode Mode)>& Delegate);
	static void SetNavigateTolerance(const float Tolerance);

	void GetRootNavigationGrade(TArray<class UUISelectableComponent*>* Result);
	void Navigate();
	void NavigateToNextGroup();
	void NavigateToPrevGroup();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINavigationGroupComponent">();
	}
	static class UUINavigationGroupComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINavigationGroupComponent>();
	}
};
static_assert(alignof(UUINavigationGroupComponent) == 0x000008, "Wrong alignment on UUINavigationGroupComponent");
static_assert(sizeof(UUINavigationGroupComponent) == 0x000208, "Wrong size on UUINavigationGroupComponent");
static_assert(offsetof(UUINavigationGroupComponent, HorizontalWrapMode) == 0x0001A0, "Member 'UUINavigationGroupComponent::HorizontalWrapMode' has a wrong offset!");
static_assert(offsetof(UUINavigationGroupComponent, HorizontalPriorityMode) == 0x0001A1, "Member 'UUINavigationGroupComponent::HorizontalPriorityMode' has a wrong offset!");
static_assert(offsetof(UUINavigationGroupComponent, VerticalWrapMode) == 0x0001A2, "Member 'UUINavigationGroupComponent::VerticalWrapMode' has a wrong offset!");
static_assert(offsetof(UUINavigationGroupComponent, VerticalPriorityMode) == 0x0001A3, "Member 'UUINavigationGroupComponent::VerticalPriorityMode' has a wrong offset!");
static_assert(offsetof(UUINavigationGroupComponent, PrevNavigationGroupActor) == 0x0001A4, "Member 'UUINavigationGroupComponent::PrevNavigationGroupActor' has a wrong offset!");
static_assert(offsetof(UUINavigationGroupComponent, PrevNavigationGroup) == 0x0001AC, "Member 'UUINavigationGroupComponent::PrevNavigationGroup' has a wrong offset!");
static_assert(offsetof(UUINavigationGroupComponent, NextNavigationGroupActor) == 0x0001B4, "Member 'UUINavigationGroupComponent::NextNavigationGroupActor' has a wrong offset!");
static_assert(offsetof(UUINavigationGroupComponent, NextNavigationGroup) == 0x0001BC, "Member 'UUINavigationGroupComponent::NextNavigationGroup' has a wrong offset!");
static_assert(offsetof(UUINavigationGroupComponent, PrevNavigationGroupName) == 0x0001C4, "Member 'UUINavigationGroupComponent::PrevNavigationGroupName' has a wrong offset!");
static_assert(offsetof(UUINavigationGroupComponent, NextNavigationGroupName) == 0x0001D0, "Member 'UUINavigationGroupComponent::NextNavigationGroupName' has a wrong offset!");
static_assert(offsetof(UUINavigationGroupComponent, NavigationGroupName) == 0x0001DC, "Member 'UUINavigationGroupComponent::NavigationGroupName' has a wrong offset!");
static_assert(offsetof(UUINavigationGroupComponent, DefaultNavigateActors) == 0x0001E8, "Member 'UUINavigationGroupComponent::DefaultNavigateActors' has a wrong offset!");
static_assert(offsetof(UUINavigationGroupComponent, BookMark) == 0x0001F8, "Member 'UUINavigationGroupComponent::BookMark' has a wrong offset!");
static_assert(offsetof(UUINavigationGroupComponent, ScrollBall) == 0x0001F9, "Member 'UUINavigationGroupComponent::ScrollBall' has a wrong offset!");
static_assert(offsetof(UUINavigationGroupComponent, MouseCanJump) == 0x0001FA, "Member 'UUINavigationGroupComponent::MouseCanJump' has a wrong offset!");
static_assert(offsetof(UUINavigationGroupComponent, AutoSearch) == 0x0001FB, "Member 'UUINavigationGroupComponent::AutoSearch' has a wrong offset!");
static_assert(offsetof(UUINavigationGroupComponent, SelectableMemory) == 0x0001FC, "Member 'UUINavigationGroupComponent::SelectableMemory' has a wrong offset!");
static_assert(offsetof(UUINavigationGroupComponent, ViewId) == 0x000200, "Member 'UUINavigationGroupComponent::ViewId' has a wrong offset!");

// Class LGUI.LGUIPointerDragDropInterface
// 0x0000 (0x0030 - 0x0030)
class ILGUIPointerDragDropInterface final : public IInterface
{
public:
	bool OnPointerDragDrop(class ULGUIPointerEventData* EventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPointerDragDropInterface">();
	}
	static class ILGUIPointerDragDropInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILGUIPointerDragDropInterface>();
	}
};
static_assert(alignof(ILGUIPointerDragDropInterface) == 0x000008, "Wrong alignment on ILGUIPointerDragDropInterface");
static_assert(sizeof(ILGUIPointerDragDropInterface) == 0x000030, "Wrong size on ILGUIPointerDragDropInterface");

// Class LGUI.LGUIPointerDragEnterExitInterface
// 0x0000 (0x0030 - 0x0030)
class ILGUIPointerDragEnterExitInterface final : public IInterface
{
public:
	bool OnPointerDragEnter(class ULGUIPointerEventData* EventData);
	bool OnPointerDragExit(class ULGUIPointerEventData* EventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPointerDragEnterExitInterface">();
	}
	static class ILGUIPointerDragEnterExitInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILGUIPointerDragEnterExitInterface>();
	}
};
static_assert(alignof(ILGUIPointerDragEnterExitInterface) == 0x000008, "Wrong alignment on ILGUIPointerDragEnterExitInterface");
static_assert(sizeof(ILGUIPointerDragEnterExitInterface) == 0x000030, "Wrong size on ILGUIPointerDragEnterExitInterface");

// Class LGUI.UIItemEditorHelperComp
// 0x0010 (0x0500 - 0x04F0)
class UUIItemEditorHelperComp final : public UPrimitiveComponent
{
public:
	class UUIItem*                                Parent;                                            // 0x04E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBodySetup*                             BodySetup;                                         // 0x04F0(0x0008)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11BF[0x8];                                     // 0x04F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIItemEditorHelperComp">();
	}
	static class UUIItemEditorHelperComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIItemEditorHelperComp>();
	}
};
static_assert(alignof(UUIItemEditorHelperComp) == 0x000010, "Wrong alignment on UUIItemEditorHelperComp");
static_assert(sizeof(UUIItemEditorHelperComp) == 0x000500, "Wrong size on UUIItemEditorHelperComp");
static_assert(offsetof(UUIItemEditorHelperComp, Parent) == 0x0004E8, "Member 'UUIItemEditorHelperComp::Parent' has a wrong offset!");
static_assert(offsetof(UUIItemEditorHelperComp, BodySetup) == 0x0004F0, "Member 'UUIItemEditorHelperComp::BodySetup' has a wrong offset!");

// Class LGUI.LGUIPointerDragInterface
// 0x0000 (0x0030 - 0x0030)
class ILGUIPointerDragInterface final : public IInterface
{
public:
	bool OnPointerBeginDrag(class ULGUIPointerEventData* EventData);
	bool OnPointerDrag(class ULGUIPointerEventData* EventData);
	bool OnPointerEndDrag(class ULGUIPointerEventData* EventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPointerDragInterface">();
	}
	static class ILGUIPointerDragInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILGUIPointerDragInterface>();
	}
};
static_assert(alignof(ILGUIPointerDragInterface) == 0x000008, "Wrong alignment on ILGUIPointerDragInterface");
static_assert(sizeof(ILGUIPointerDragInterface) == 0x000030, "Wrong size on ILGUIPointerDragInterface");

// Class LGUI.LGUIPointerEnterExitInterface
// 0x0000 (0x0030 - 0x0030)
class ILGUIPointerEnterExitInterface final : public IInterface
{
public:
	bool OnPointerEnter(class ULGUIPointerEventData* EventData);
	bool OnPointerExit(class ULGUIPointerEventData* EventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPointerEnterExitInterface">();
	}
	static class ILGUIPointerEnterExitInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILGUIPointerEnterExitInterface>();
	}
};
static_assert(alignof(ILGUIPointerEnterExitInterface) == 0x000008, "Wrong alignment on ILGUIPointerEnterExitInterface");
static_assert(sizeof(ILGUIPointerEnterExitInterface) == 0x000030, "Wrong size on ILGUIPointerEnterExitInterface");

// Class LGUI.LGUIPointerEventData
// 0x01C0 (0x0200 - 0x0040)
class ULGUIPointerEventData final : public ULGUIBaseEventData
{
public:
	ELGUIPointerInputType                         InputType;                                         // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C5[0x3];                                     // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PointerID;                                         // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PointerPosition;                                   // 0x0048(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C6[0x4];                                     // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        CurrentComponent;                                  // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        EnterComponent;                                    // 0x0060(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                EnterComponentStack;                               // 0x0068(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                HoverComponentArray;                               // 0x0078(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C7[0x50];                                    // 0x0088(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WorldPoint;                                        // 0x00D8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldNormal;                                       // 0x00E4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FaceIndex;                                         // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ElementIndex;                                      // 0x00F4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C8[0x3];                                     // 0x00F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Item;                                              // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MoveDelta;                                         // 0x00FC(0x000C)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CumulativeMoveDelta;                               // 0x0108(0x000C)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScrollAxisValue;                                   // 0x0114(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RayOrigin;                                         // 0x0118(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RayDirection;                                      // 0x0124(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULGUIBaseRaycaster*                     Raycaster;                                         // 0x0130(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMouseButtonType                              MouseButtonType;                                   // 0x0138(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C9[0x7];                                     // 0x0139(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        PressComponent;                                    // 0x0140(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PressWorldPoint;                                   // 0x0148(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PressWorldNormal;                                  // 0x0154(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PressDistance;                                     // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PressRayOrigin;                                    // 0x0164(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PressRayDirection;                                 // 0x0170(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11CA[0x4];                                     // 0x017C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             PressWorldToLocalTransform;                        // 0x0180(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class ULGUIBaseRaycaster*                     PressRaycaster;                                    // 0x01B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClickTime;                                         // 0x01B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PressTime;                                         // 0x01BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PrevMousePos;                                      // 0x01C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDragging;                                        // 0x01C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11CB[0x7];                                     // 0x01C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DragComponent;                                     // 0x01D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DragRayOrigin;                                     // 0x01D8(0x000C)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DragRayDirection;                                  // 0x01E4(0x000C)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11CC[0x8];                                     // 0x01F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          NowIsTriggerPressed;                               // 0x01F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11CD[0x2];                                     // 0x01F9(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          DragDropTriggered;                                 // 0x01FB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11CE[0x4];                                     // 0x01FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetCumulativeMoveDelta() const;
	struct FVector GetDragRayDirection() const;
	struct FVector GetDragRayOrigin() const;
	struct FVector GetLocalPointInPlane() const;
	struct FVector GetWorldPointInPlane() const;
	struct FVector GetWorldPointSpherical() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPointerEventData">();
	}
	static class ULGUIPointerEventData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPointerEventData>();
	}
};
static_assert(alignof(ULGUIPointerEventData) == 0x000010, "Wrong alignment on ULGUIPointerEventData");
static_assert(sizeof(ULGUIPointerEventData) == 0x000200, "Wrong size on ULGUIPointerEventData");
static_assert(offsetof(ULGUIPointerEventData, InputType) == 0x000040, "Member 'ULGUIPointerEventData::InputType' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, PointerID) == 0x000044, "Member 'ULGUIPointerEventData::PointerID' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, PointerPosition) == 0x000048, "Member 'ULGUIPointerEventData::PointerPosition' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, CurrentComponent) == 0x000058, "Member 'ULGUIPointerEventData::CurrentComponent' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, EnterComponent) == 0x000060, "Member 'ULGUIPointerEventData::EnterComponent' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, EnterComponentStack) == 0x000068, "Member 'ULGUIPointerEventData::EnterComponentStack' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, HoverComponentArray) == 0x000078, "Member 'ULGUIPointerEventData::HoverComponentArray' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, WorldPoint) == 0x0000D8, "Member 'ULGUIPointerEventData::WorldPoint' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, WorldNormal) == 0x0000E4, "Member 'ULGUIPointerEventData::WorldNormal' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, FaceIndex) == 0x0000F0, "Member 'ULGUIPointerEventData::FaceIndex' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, ElementIndex) == 0x0000F4, "Member 'ULGUIPointerEventData::ElementIndex' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, Item) == 0x0000F8, "Member 'ULGUIPointerEventData::Item' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, MoveDelta) == 0x0000FC, "Member 'ULGUIPointerEventData::MoveDelta' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, CumulativeMoveDelta) == 0x000108, "Member 'ULGUIPointerEventData::CumulativeMoveDelta' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, ScrollAxisValue) == 0x000114, "Member 'ULGUIPointerEventData::ScrollAxisValue' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, RayOrigin) == 0x000118, "Member 'ULGUIPointerEventData::RayOrigin' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, RayDirection) == 0x000124, "Member 'ULGUIPointerEventData::RayDirection' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, Raycaster) == 0x000130, "Member 'ULGUIPointerEventData::Raycaster' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, MouseButtonType) == 0x000138, "Member 'ULGUIPointerEventData::MouseButtonType' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, PressComponent) == 0x000140, "Member 'ULGUIPointerEventData::PressComponent' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, PressWorldPoint) == 0x000148, "Member 'ULGUIPointerEventData::PressWorldPoint' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, PressWorldNormal) == 0x000154, "Member 'ULGUIPointerEventData::PressWorldNormal' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, PressDistance) == 0x000160, "Member 'ULGUIPointerEventData::PressDistance' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, PressRayOrigin) == 0x000164, "Member 'ULGUIPointerEventData::PressRayOrigin' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, PressRayDirection) == 0x000170, "Member 'ULGUIPointerEventData::PressRayDirection' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, PressWorldToLocalTransform) == 0x000180, "Member 'ULGUIPointerEventData::PressWorldToLocalTransform' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, PressRaycaster) == 0x0001B0, "Member 'ULGUIPointerEventData::PressRaycaster' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, ClickTime) == 0x0001B8, "Member 'ULGUIPointerEventData::ClickTime' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, PressTime) == 0x0001BC, "Member 'ULGUIPointerEventData::PressTime' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, PrevMousePos) == 0x0001C0, "Member 'ULGUIPointerEventData::PrevMousePos' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, IsDragging) == 0x0001C8, "Member 'ULGUIPointerEventData::IsDragging' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, DragComponent) == 0x0001D0, "Member 'ULGUIPointerEventData::DragComponent' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, DragRayOrigin) == 0x0001D8, "Member 'ULGUIPointerEventData::DragRayOrigin' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, DragRayDirection) == 0x0001E4, "Member 'ULGUIPointerEventData::DragRayDirection' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, NowIsTriggerPressed) == 0x0001F8, "Member 'ULGUIPointerEventData::NowIsTriggerPressed' has a wrong offset!");
static_assert(offsetof(ULGUIPointerEventData, DragDropTriggered) == 0x0001FB, "Member 'ULGUIPointerEventData::DragDropTriggered' has a wrong offset!");

// Class LGUI.LGUIPointerInterruptInterface
// 0x0000 (0x0030 - 0x0030)
class ILGUIPointerInterruptInterface final : public IInterface
{
public:
	bool NeedInterrupt(class ULGUIBaseEventData* EventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPointerInterruptInterface">();
	}
	static class ILGUIPointerInterruptInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILGUIPointerInterruptInterface>();
	}
};
static_assert(alignof(ILGUIPointerInterruptInterface) == 0x000008, "Wrong alignment on ILGUIPointerInterruptInterface");
static_assert(sizeof(ILGUIPointerInterruptInterface) == 0x000030, "Wrong size on ILGUIPointerInterruptInterface");

// Class LGUI.UIScrollViewHelper
// 0x0008 (0x0108 - 0x0100)
class UUIScrollViewHelper final : public ULGUIBehaviour
{
public:
	TWeakObjectPtr<class UUIScrollViewComponent>  TargetComp;                                        // 0x0100(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIScrollViewHelper">();
	}
	static class UUIScrollViewHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIScrollViewHelper>();
	}
};
static_assert(alignof(UUIScrollViewHelper) == 0x000008, "Wrong alignment on UUIScrollViewHelper");
static_assert(sizeof(UUIScrollViewHelper) == 0x000108, "Wrong size on UUIScrollViewHelper");
static_assert(offsetof(UUIScrollViewHelper, TargetComp) == 0x000100, "Member 'UUIScrollViewHelper::TargetComp' has a wrong offset!");

// Class LGUI.LGUIPointerScrollInterface
// 0x0000 (0x0030 - 0x0030)
class ILGUIPointerScrollInterface final : public IInterface
{
public:
	bool OnPointerScroll(class ULGUIPointerEventData* EventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPointerScrollInterface">();
	}
	static class ILGUIPointerScrollInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILGUIPointerScrollInterface>();
	}
};
static_assert(alignof(ILGUIPointerScrollInterface) == 0x000008, "Wrong alignment on ILGUIPointerScrollInterface");
static_assert(sizeof(ILGUIPointerScrollInterface) == 0x000030, "Wrong size on ILGUIPointerScrollInterface");

// Class LGUI.LGUIPointerSelectDeselectInterface
// 0x0000 (0x0030 - 0x0030)
class ILGUIPointerSelectDeselectInterface final : public IInterface
{
public:
	bool OnPointerDeselect(class ULGUIBaseEventData* EventData);
	bool OnPointerSelect(class ULGUIBaseEventData* EventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPointerSelectDeselectInterface">();
	}
	static class ILGUIPointerSelectDeselectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILGUIPointerSelectDeselectInterface>();
	}
};
static_assert(alignof(ILGUIPointerSelectDeselectInterface) == 0x000008, "Wrong alignment on ILGUIPointerSelectDeselectInterface");
static_assert(sizeof(ILGUIPointerSelectDeselectInterface) == 0x000030, "Wrong size on ILGUIPointerSelectDeselectInterface");

// Class LGUI.LGUIPrefab
// 0x0078 (0x00A8 - 0x0030)
class ULGUIPrefab final : public UObject
{
public:
	TArray<class UObject*>                        ReferenceAssetList;                                // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         ReferenceStringList;                               // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           ReferenceNameList;                                 // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           ReferenceTextList;                                 // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UClass*>                         ReferenceClassList;                                // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                AllSoftObjectReferences;                           // 0x0080(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint16                                        PrefabVersion;                                     // 0x0090(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        EngineMajorVersion;                                // 0x0092(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        EngineMinorVersion;                                // 0x0094(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11D3[0x2];                                     // 0x0096(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 BinaryDataForBuild;                                // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPrefab">();
	}
	static class ULGUIPrefab* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIPrefab>();
	}
};
static_assert(alignof(ULGUIPrefab) == 0x000008, "Wrong alignment on ULGUIPrefab");
static_assert(sizeof(ULGUIPrefab) == 0x0000A8, "Wrong size on ULGUIPrefab");
static_assert(offsetof(ULGUIPrefab, ReferenceAssetList) == 0x000030, "Member 'ULGUIPrefab::ReferenceAssetList' has a wrong offset!");
static_assert(offsetof(ULGUIPrefab, ReferenceStringList) == 0x000040, "Member 'ULGUIPrefab::ReferenceStringList' has a wrong offset!");
static_assert(offsetof(ULGUIPrefab, ReferenceNameList) == 0x000050, "Member 'ULGUIPrefab::ReferenceNameList' has a wrong offset!");
static_assert(offsetof(ULGUIPrefab, ReferenceTextList) == 0x000060, "Member 'ULGUIPrefab::ReferenceTextList' has a wrong offset!");
static_assert(offsetof(ULGUIPrefab, ReferenceClassList) == 0x000070, "Member 'ULGUIPrefab::ReferenceClassList' has a wrong offset!");
static_assert(offsetof(ULGUIPrefab, AllSoftObjectReferences) == 0x000080, "Member 'ULGUIPrefab::AllSoftObjectReferences' has a wrong offset!");
static_assert(offsetof(ULGUIPrefab, PrefabVersion) == 0x000090, "Member 'ULGUIPrefab::PrefabVersion' has a wrong offset!");
static_assert(offsetof(ULGUIPrefab, EngineMajorVersion) == 0x000092, "Member 'ULGUIPrefab::EngineMajorVersion' has a wrong offset!");
static_assert(offsetof(ULGUIPrefab, EngineMinorVersion) == 0x000094, "Member 'ULGUIPrefab::EngineMinorVersion' has a wrong offset!");
static_assert(offsetof(ULGUIPrefab, BinaryDataForBuild) == 0x000098, "Member 'ULGUIPrefab::BinaryDataForBuild' has a wrong offset!");

// Class LGUI.LGUIPrefabActor
// 0x0008 (0x02B0 - 0x02A8)
class ALGUIPrefabActor final : public AActor
{
public:
	class ULGUIPrefabHelperComponent*             PrefabComponent;                                   // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPrefabActor">();
	}
	static class ALGUIPrefabActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALGUIPrefabActor>();
	}
};
static_assert(alignof(ALGUIPrefabActor) == 0x000008, "Wrong alignment on ALGUIPrefabActor");
static_assert(sizeof(ALGUIPrefabActor) == 0x0002B0, "Wrong size on ALGUIPrefabActor");
static_assert(offsetof(ALGUIPrefabActor, PrefabComponent) == 0x0002A8, "Member 'ALGUIPrefabActor::PrefabComponent' has a wrong offset!");

// Class LGUI.LGUIPrefabCheckerInterface
// 0x0000 (0x0030 - 0x0030)
class ILGUIPrefabCheckerInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIPrefabCheckerInterface">();
	}
	static class ILGUIPrefabCheckerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILGUIPrefabCheckerInterface>();
	}
};
static_assert(alignof(ILGUIPrefabCheckerInterface) == 0x000008, "Wrong alignment on ILGUIPrefabCheckerInterface");
static_assert(sizeof(ILGUIPrefabCheckerInterface) == 0x000030, "Wrong size on ILGUIPrefabCheckerInterface");

// Class LGUI.LGUIScreenSpaceInteraction
// 0x0010 (0x0280 - 0x0270)
class ULGUIScreenSpaceInteraction final : public ULGUI_UIRaycaster
{
public:
	float                                         ClickThreshold;                                    // 0x0268(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          HoldToDrag;                                        // 0x026C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11D4[0x3];                                     // 0x026D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HoldToDragTime;                                    // 0x0270(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11D5[0xC];                                     // 0x0274(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetClickThreshold(float Value);
	void SetHoldToDrag(bool Value);
	void SetHoldToDragTime(float Value);

	float GetClickThreshold() const;
	bool GetHoldToDrag() const;
	float GetHoldToDragTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIScreenSpaceInteraction">();
	}
	static class ULGUIScreenSpaceInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIScreenSpaceInteraction>();
	}
};
static_assert(alignof(ULGUIScreenSpaceInteraction) == 0x000010, "Wrong alignment on ULGUIScreenSpaceInteraction");
static_assert(sizeof(ULGUIScreenSpaceInteraction) == 0x000280, "Wrong size on ULGUIScreenSpaceInteraction");
static_assert(offsetof(ULGUIScreenSpaceInteraction, ClickThreshold) == 0x000268, "Member 'ULGUIScreenSpaceInteraction::ClickThreshold' has a wrong offset!");
static_assert(offsetof(ULGUIScreenSpaceInteraction, HoldToDrag) == 0x00026C, "Member 'ULGUIScreenSpaceInteraction::HoldToDrag' has a wrong offset!");
static_assert(offsetof(ULGUIScreenSpaceInteraction, HoldToDragTime) == 0x000270, "Member 'ULGUIScreenSpaceInteraction::HoldToDragTime' has a wrong offset!");

// Class LGUI.UIBaseActor
// 0x00E8 (0x0390 - 0x02A8)
class AUIBaseActor : public AActor
{
public:
	uint8                                         Pad_11D6[0x8];                                     // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FSoftObjectPath, class ALevelSequenceActor*> CurBindingSeqActors;                               // 0x02B0(0x0050)(Transient, NativeAccessSpecifierPublic)
	TDelegate<void(const class FString& SequenceName, const class FString& EventName)> OnSequencePlayEvent;                               // 0x0300(0x0028)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	struct FGuid                                  LGUIGuid;                                          // 0x0328(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<struct FSoftObjectPath, class USequencePlayContext*> AllSequencePlayContexts;                           // 0x0338(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11D7[0x8];                                     // 0x0388(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateAllChildrenInteraction();
	void CleanIdleAnimSeqActorCache();
	void ClearAllSequence();
	ESequenceLoadState GetLoadStateOfSequenceByKey(const class FString& Key);
	struct FSequenceInfo GetSeqInfoByKey(const class FString& Key);
	class USequencePlayContext* GetSequencePlayContextOfKey(const class FString& Key);
	class ALevelSequenceActor* GetSequencePlayerByKey(const class FString& Param_Name);
	void LoadSequenceAssetAsyncByKey(const class FString& Key, const TDelegate<void(class ULevelSequence* Sequence)>& OnLoaded);
	void PauseSequenceByKey(const class FString& Param_Name);
	void PlayLevelSequenceByKey(const class FString& Param_Name);
	void ReplaySequenceByKey(const class FString& Param_Name);
	void ResumeSequenceByKey(const class FString& Param_Name);
	void SequenceJumpToEnd(const struct FSoftObjectPath& SoftPath);
	void SequenceJumpToSecondByKey(const class FString& Param_Name, const struct FFrameTime& Time);
	void SequencePlayReverseByKey(const class FString& Param_Name);
	void StopSequenceByKey(const class FString& Param_Name);

	void ExecuteSequencePlayEvent(const class FString& SequenceName, const class FString& EventName) const;
	class UUIItem* GetUIItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBaseActor">();
	}
	static class AUIBaseActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIBaseActor>();
	}
};
static_assert(alignof(AUIBaseActor) == 0x000008, "Wrong alignment on AUIBaseActor");
static_assert(sizeof(AUIBaseActor) == 0x000390, "Wrong size on AUIBaseActor");
static_assert(offsetof(AUIBaseActor, CurBindingSeqActors) == 0x0002B0, "Member 'AUIBaseActor::CurBindingSeqActors' has a wrong offset!");
static_assert(offsetof(AUIBaseActor, OnSequencePlayEvent) == 0x000300, "Member 'AUIBaseActor::OnSequencePlayEvent' has a wrong offset!");
static_assert(offsetof(AUIBaseActor, LGUIGuid) == 0x000328, "Member 'AUIBaseActor::LGUIGuid' has a wrong offset!");
static_assert(offsetof(AUIBaseActor, AllSequencePlayContexts) == 0x000338, "Member 'AUIBaseActor::AllSequencePlayContexts' has a wrong offset!");

// Class LGUI.UIRingActor
// 0x0008 (0x0398 - 0x0390)
class AUIRingActor final : public AUIBaseActor
{
public:
	class UUIRing*                                UIElement;                                         // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIRingActor">();
	}
	static class AUIRingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIRingActor>();
	}
};
static_assert(alignof(AUIRingActor) == 0x000008, "Wrong alignment on AUIRingActor");
static_assert(sizeof(AUIRingActor) == 0x000398, "Wrong size on AUIRingActor");
static_assert(offsetof(AUIRingActor, UIElement) == 0x000390, "Member 'AUIRingActor::UIElement' has a wrong offset!");

// Class LGUI.LGUIScreenSpaceInteractionForNoneUI
// 0x0010 (0x0270 - 0x0260)
class ULGUIScreenSpaceInteractionForNoneUI final : public ULGUI_WorldRaycaster
{
public:
	float                                         ClickThreshold;                                    // 0x0260(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          HoldToDrag;                                        // 0x0264(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11D9[0x3];                                     // 0x0265(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HoldToDragTime;                                    // 0x0268(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11DA[0x4];                                     // 0x026C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetClickThreshold(float Value);
	void SetHoldToDrag(bool Value);
	void SetHoldToDragTime(float Value);

	float GetClickThreshold() const;
	bool GetHoldToDrag() const;
	float GetHoldToDragTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIScreenSpaceInteractionForNoneUI">();
	}
	static class ULGUIScreenSpaceInteractionForNoneUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIScreenSpaceInteractionForNoneUI>();
	}
};
static_assert(alignof(ULGUIScreenSpaceInteractionForNoneUI) == 0x000010, "Wrong alignment on ULGUIScreenSpaceInteractionForNoneUI");
static_assert(sizeof(ULGUIScreenSpaceInteractionForNoneUI) == 0x000270, "Wrong size on ULGUIScreenSpaceInteractionForNoneUI");
static_assert(offsetof(ULGUIScreenSpaceInteractionForNoneUI, ClickThreshold) == 0x000260, "Member 'ULGUIScreenSpaceInteractionForNoneUI::ClickThreshold' has a wrong offset!");
static_assert(offsetof(ULGUIScreenSpaceInteractionForNoneUI, HoldToDrag) == 0x000264, "Member 'ULGUIScreenSpaceInteractionForNoneUI::HoldToDrag' has a wrong offset!");
static_assert(offsetof(ULGUIScreenSpaceInteractionForNoneUI, HoldToDragTime) == 0x000268, "Member 'ULGUIScreenSpaceInteractionForNoneUI::HoldToDragTime' has a wrong offset!");

// Class LGUI.LGUISequenceBindingMgr
// 0x0050 (0x0080 - 0x0030)
class ULGUISequenceBindingMgr final : public UObject
{
public:
	TMap<class UMovieSceneSequence*, struct FActorBindings> BindingMaps;                                       // 0x0030(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUISequenceBindingMgr">();
	}
	static class ULGUISequenceBindingMgr* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUISequenceBindingMgr>();
	}
};
static_assert(alignof(ULGUISequenceBindingMgr) == 0x000008, "Wrong alignment on ULGUISequenceBindingMgr");
static_assert(sizeof(ULGUISequenceBindingMgr) == 0x000080, "Wrong size on ULGUISequenceBindingMgr");
static_assert(offsetof(ULGUISequenceBindingMgr, BindingMaps) == 0x000030, "Member 'ULGUISequenceBindingMgr::BindingMaps' has a wrong offset!");

// Class LGUI.UISizeControlByAspectRatio
// 0x0028 (0x0198 - 0x0170)
class UUISizeControlByAspectRatio final : public UUILayoutBase
{
public:
	EUISizeControlByAspectRatioMode               ControlMode;                                       // 0x0170(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11DB[0x3];                                     // 0x0171(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AspectRatio;                                       // 0x0174(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11DC[0xC];                                     // 0x0178(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UUISizeControlByAspectRatioHelper> HelperComp;                                        // 0x0184(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              Pivot;                                             // 0x018C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bChangeChildrenOffset;                             // 0x0194(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bChangeChildrenSize;                               // 0x0195(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11DD[0x2];                                     // 0x0196(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAspectRatio(float Value);
	void SetControlMode(EUISizeControlByAspectRatioMode Value);

	float GetAspectRatio() const;
	EUISizeControlByAspectRatioMode GetControlMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISizeControlByAspectRatio">();
	}
	static class UUISizeControlByAspectRatio* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISizeControlByAspectRatio>();
	}
};
static_assert(alignof(UUISizeControlByAspectRatio) == 0x000008, "Wrong alignment on UUISizeControlByAspectRatio");
static_assert(sizeof(UUISizeControlByAspectRatio) == 0x000198, "Wrong size on UUISizeControlByAspectRatio");
static_assert(offsetof(UUISizeControlByAspectRatio, ControlMode) == 0x000170, "Member 'UUISizeControlByAspectRatio::ControlMode' has a wrong offset!");
static_assert(offsetof(UUISizeControlByAspectRatio, AspectRatio) == 0x000174, "Member 'UUISizeControlByAspectRatio::AspectRatio' has a wrong offset!");
static_assert(offsetof(UUISizeControlByAspectRatio, HelperComp) == 0x000184, "Member 'UUISizeControlByAspectRatio::HelperComp' has a wrong offset!");
static_assert(offsetof(UUISizeControlByAspectRatio, Pivot) == 0x00018C, "Member 'UUISizeControlByAspectRatio::Pivot' has a wrong offset!");
static_assert(offsetof(UUISizeControlByAspectRatio, bChangeChildrenOffset) == 0x000194, "Member 'UUISizeControlByAspectRatio::bChangeChildrenOffset' has a wrong offset!");
static_assert(offsetof(UUISizeControlByAspectRatio, bChangeChildrenSize) == 0x000195, "Member 'UUISizeControlByAspectRatio::bChangeChildrenSize' has a wrong offset!");

// Class LGUI.LGUISettings
// 0x01C8 (0x01F8 - 0x0030)
class ULGUISettings final : public UObject
{
public:
	struct FLGUIAtlasSettings                     DefaultAtlasSetting;                               // 0x0030(0x0008)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	TMap<class FName, struct FLGUIAtlasSettings>  AtlasSettingForSpecificPackingTag;                 // 0x0038(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               DefaultTraceChannel;                               // 0x0088(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELGUIScreenSpaceUIAntiAliasing                AntiAliasing;                                      // 0x0089(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11DE[0x2];                                     // 0x008A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUIFixedInfo                         FixedInfo;                                         // 0x008C(0x0020)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         NiagaraSortOrderBias;                              // 0x00AC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NeedTidyUpRatio;                                   // 0x00B0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11DF[0x4];                                     // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DefaultWhiteTexturePath;                           // 0x00B8(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DefaultWhiteSpritePath;                            // 0x00C8(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DefaultEventPrefabPath;                            // 0x00D8(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DefaultScreenRootPath;                             // 0x00E8(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DefaultWorldRootPath;                              // 0x00F8(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DefaultChildPath;                                  // 0x0108(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DefaultFontPath;                                   // 0x0118(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PcPrefix;                                          // 0x0128(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MobilePrefix;                                      // 0x0138(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BasePrefabItemName;                                // 0x0148(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlatformReplacePath;                               // 0x0158(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlatformSequenceReplacePath;                       // 0x0168(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PcDirectory;                                       // 0x0178(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PcSequenceDirectory;                               // 0x0188(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PcSequenceTmpPath;                                 // 0x0198(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PcSequencePostfix;                                 // 0x01B8(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MobileDirectory;                                   // 0x01C8(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSequenceActorTriggerCollect;                    // 0x01D8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SequenceActorTriggerCollectInterval;               // 0x01DC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MaxDiscreteTextureSize;                            // 0x01E0(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DynamicAtlasFailAttemptSecs;                       // 0x01E8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        DynamicAtlasNum;                                   // 0x01EC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        MaxAttemptInsertTime;                              // 0x01F0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseNewSequenceBinding;                            // 0x01F4(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11E0[0x3];                                     // 0x01F5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUISettings">();
	}
	static class ULGUISettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUISettings>();
	}
};
static_assert(alignof(ULGUISettings) == 0x000008, "Wrong alignment on ULGUISettings");
static_assert(sizeof(ULGUISettings) == 0x0001F8, "Wrong size on ULGUISettings");
static_assert(offsetof(ULGUISettings, DefaultAtlasSetting) == 0x000030, "Member 'ULGUISettings::DefaultAtlasSetting' has a wrong offset!");
static_assert(offsetof(ULGUISettings, AtlasSettingForSpecificPackingTag) == 0x000038, "Member 'ULGUISettings::AtlasSettingForSpecificPackingTag' has a wrong offset!");
static_assert(offsetof(ULGUISettings, DefaultTraceChannel) == 0x000088, "Member 'ULGUISettings::DefaultTraceChannel' has a wrong offset!");
static_assert(offsetof(ULGUISettings, AntiAliasing) == 0x000089, "Member 'ULGUISettings::AntiAliasing' has a wrong offset!");
static_assert(offsetof(ULGUISettings, FixedInfo) == 0x00008C, "Member 'ULGUISettings::FixedInfo' has a wrong offset!");
static_assert(offsetof(ULGUISettings, NiagaraSortOrderBias) == 0x0000AC, "Member 'ULGUISettings::NiagaraSortOrderBias' has a wrong offset!");
static_assert(offsetof(ULGUISettings, NeedTidyUpRatio) == 0x0000B0, "Member 'ULGUISettings::NeedTidyUpRatio' has a wrong offset!");
static_assert(offsetof(ULGUISettings, DefaultWhiteTexturePath) == 0x0000B8, "Member 'ULGUISettings::DefaultWhiteTexturePath' has a wrong offset!");
static_assert(offsetof(ULGUISettings, DefaultWhiteSpritePath) == 0x0000C8, "Member 'ULGUISettings::DefaultWhiteSpritePath' has a wrong offset!");
static_assert(offsetof(ULGUISettings, DefaultEventPrefabPath) == 0x0000D8, "Member 'ULGUISettings::DefaultEventPrefabPath' has a wrong offset!");
static_assert(offsetof(ULGUISettings, DefaultScreenRootPath) == 0x0000E8, "Member 'ULGUISettings::DefaultScreenRootPath' has a wrong offset!");
static_assert(offsetof(ULGUISettings, DefaultWorldRootPath) == 0x0000F8, "Member 'ULGUISettings::DefaultWorldRootPath' has a wrong offset!");
static_assert(offsetof(ULGUISettings, DefaultChildPath) == 0x000108, "Member 'ULGUISettings::DefaultChildPath' has a wrong offset!");
static_assert(offsetof(ULGUISettings, DefaultFontPath) == 0x000118, "Member 'ULGUISettings::DefaultFontPath' has a wrong offset!");
static_assert(offsetof(ULGUISettings, PcPrefix) == 0x000128, "Member 'ULGUISettings::PcPrefix' has a wrong offset!");
static_assert(offsetof(ULGUISettings, MobilePrefix) == 0x000138, "Member 'ULGUISettings::MobilePrefix' has a wrong offset!");
static_assert(offsetof(ULGUISettings, BasePrefabItemName) == 0x000148, "Member 'ULGUISettings::BasePrefabItemName' has a wrong offset!");
static_assert(offsetof(ULGUISettings, PlatformReplacePath) == 0x000158, "Member 'ULGUISettings::PlatformReplacePath' has a wrong offset!");
static_assert(offsetof(ULGUISettings, PlatformSequenceReplacePath) == 0x000168, "Member 'ULGUISettings::PlatformSequenceReplacePath' has a wrong offset!");
static_assert(offsetof(ULGUISettings, PcDirectory) == 0x000178, "Member 'ULGUISettings::PcDirectory' has a wrong offset!");
static_assert(offsetof(ULGUISettings, PcSequenceDirectory) == 0x000188, "Member 'ULGUISettings::PcSequenceDirectory' has a wrong offset!");
static_assert(offsetof(ULGUISettings, PcSequenceTmpPath) == 0x000198, "Member 'ULGUISettings::PcSequenceTmpPath' has a wrong offset!");
static_assert(offsetof(ULGUISettings, PcSequencePostfix) == 0x0001B8, "Member 'ULGUISettings::PcSequencePostfix' has a wrong offset!");
static_assert(offsetof(ULGUISettings, MobileDirectory) == 0x0001C8, "Member 'ULGUISettings::MobileDirectory' has a wrong offset!");
static_assert(offsetof(ULGUISettings, MaxSequenceActorTriggerCollect) == 0x0001D8, "Member 'ULGUISettings::MaxSequenceActorTriggerCollect' has a wrong offset!");
static_assert(offsetof(ULGUISettings, SequenceActorTriggerCollectInterval) == 0x0001DC, "Member 'ULGUISettings::SequenceActorTriggerCollectInterval' has a wrong offset!");
static_assert(offsetof(ULGUISettings, MaxDiscreteTextureSize) == 0x0001E0, "Member 'ULGUISettings::MaxDiscreteTextureSize' has a wrong offset!");
static_assert(offsetof(ULGUISettings, DynamicAtlasFailAttemptSecs) == 0x0001E8, "Member 'ULGUISettings::DynamicAtlasFailAttemptSecs' has a wrong offset!");
static_assert(offsetof(ULGUISettings, DynamicAtlasNum) == 0x0001EC, "Member 'ULGUISettings::DynamicAtlasNum' has a wrong offset!");
static_assert(offsetof(ULGUISettings, MaxAttemptInsertTime) == 0x0001F0, "Member 'ULGUISettings::MaxAttemptInsertTime' has a wrong offset!");
static_assert(offsetof(ULGUISettings, bUseNewSequenceBinding) == 0x0001F4, "Member 'ULGUISettings::bUseNewSequenceBinding' has a wrong offset!");

// Class LGUI.LGUIEditorSettings
// 0x0000 (0x0030 - 0x0030)
class ULGUIEditorSettings final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIEditorSettings">();
	}
	static class ULGUIEditorSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIEditorSettings>();
	}
};
static_assert(alignof(ULGUIEditorSettings) == 0x000008, "Wrong alignment on ULGUIEditorSettings");
static_assert(sizeof(ULGUIEditorSettings) == 0x000030, "Wrong size on ULGUIEditorSettings");

// Class LGUI.UISpriteSheetTexturePlayer
// 0x0018 (0x00F8 - 0x00E0)
class UUISpriteSheetTexturePlayer final : public ULGUIImageSequencePlayer
{
public:
	TWeakObjectPtr<class UUITexture>              Texture;                                           // 0x00E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         WidthCount;                                        // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         HeightCount;                                       // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11E1[0x8];                                     // 0x00F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHeightCount(int32 Value);
	void SetWidthCount(int32 Value);

	int32 GetHeightCount() const;
	int32 GetWidthCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISpriteSheetTexturePlayer">();
	}
	static class UUISpriteSheetTexturePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISpriteSheetTexturePlayer>();
	}
};
static_assert(alignof(UUISpriteSheetTexturePlayer) == 0x000008, "Wrong alignment on UUISpriteSheetTexturePlayer");
static_assert(sizeof(UUISpriteSheetTexturePlayer) == 0x0000F8, "Wrong size on UUISpriteSheetTexturePlayer");
static_assert(offsetof(UUISpriteSheetTexturePlayer, Texture) == 0x0000E0, "Member 'UUISpriteSheetTexturePlayer::Texture' has a wrong offset!");
static_assert(offsetof(UUISpriteSheetTexturePlayer, WidthCount) == 0x0000E8, "Member 'UUISpriteSheetTexturePlayer::WidthCount' has a wrong offset!");
static_assert(offsetof(UUISpriteSheetTexturePlayer, HeightCount) == 0x0000EC, "Member 'UUISpriteSheetTexturePlayer::HeightCount' has a wrong offset!");

// Class LGUI.LGUISpriteData_BaseObject
// 0x0000 (0x0030 - 0x0030)
class ULGUISpriteData_BaseObject : public UObject
{
public:
	class UTexture2D* GetAtlasTexture();
	struct FLGUISpriteInfo GetSpriteInfo();

	bool IsIndividual() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUISpriteData_BaseObject">();
	}
	static class ULGUISpriteData_BaseObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUISpriteData_BaseObject>();
	}
};
static_assert(alignof(ULGUISpriteData_BaseObject) == 0x000008, "Wrong alignment on ULGUISpriteData_BaseObject");
static_assert(sizeof(ULGUISpriteData_BaseObject) == 0x000030, "Wrong size on ULGUISpriteData_BaseObject");

// Class LGUI.LGUISpriteData
// 0x0058 (0x0088 - 0x0030)
class ULGUISpriteData final : public ULGUISpriteData_BaseObject
{
public:
	class UTexture2D*                             SpriteTexture;                                     // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLGUISpriteInfo                        SpriteInfo;                                        // 0x0038(0x0034)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	class FName                                   PackingTag;                                        // 0x006C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11E2[0x8];                                     // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             AtlasTexture;                                      // 0x0080(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class ULGUISpriteData* CreateLGUISpriteData(class UObject* Param_Outer, class UTexture2D* InSpriteTexture, const struct FVector2D& InHorizontalBorder, const struct FVector2D& InVerticalBorder, class FName InPackingTag);

	const class FName GetPackingTag() const;
	class UTexture2D* GetSpriteTexture() const;
	bool HavePackingTag() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUISpriteData">();
	}
	static class ULGUISpriteData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUISpriteData>();
	}
};
static_assert(alignof(ULGUISpriteData) == 0x000008, "Wrong alignment on ULGUISpriteData");
static_assert(sizeof(ULGUISpriteData) == 0x000088, "Wrong size on ULGUISpriteData");
static_assert(offsetof(ULGUISpriteData, SpriteTexture) == 0x000030, "Member 'ULGUISpriteData::SpriteTexture' has a wrong offset!");
static_assert(offsetof(ULGUISpriteData, SpriteInfo) == 0x000038, "Member 'ULGUISpriteData::SpriteInfo' has a wrong offset!");
static_assert(offsetof(ULGUISpriteData, PackingTag) == 0x00006C, "Member 'ULGUISpriteData::PackingTag' has a wrong offset!");
static_assert(offsetof(ULGUISpriteData, AtlasTexture) == 0x000080, "Member 'ULGUISpriteData::AtlasTexture' has a wrong offset!");

// Class LGUI.UISpineActor
// 0x0008 (0x0398 - 0x0390)
class AUISpineActor final : public AUIBaseActor
{
public:
	class UUISpineRenderable*                     UISpine;                                           // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISpineActor">();
	}
	static class AUISpineActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUISpineActor>();
	}
};
static_assert(alignof(AUISpineActor) == 0x000008, "Wrong alignment on AUISpineActor");
static_assert(sizeof(AUISpineActor) == 0x000398, "Wrong size on AUISpineActor");
static_assert(offsetof(AUISpineActor, UISpine) == 0x000390, "Member 'AUISpineActor::UISpine' has a wrong offset!");

// Class LGUI.LGUITextureData
// 0x0040 (0x0070 - 0x0030)
class ULGUITextureData final : public UObject
{
public:
	class UTexture2D*                             Texture;                                           // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLGUISpriteInfo                        SpriteInfo;                                        // 0x0038(0x0034)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11E4[0x4];                                     // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUITextureData">();
	}
	static class ULGUITextureData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUITextureData>();
	}
};
static_assert(alignof(ULGUITextureData) == 0x000008, "Wrong alignment on ULGUITextureData");
static_assert(sizeof(ULGUITextureData) == 0x000070, "Wrong size on ULGUITextureData");
static_assert(offsetof(ULGUITextureData, Texture) == 0x000030, "Member 'ULGUITextureData::Texture' has a wrong offset!");
static_assert(offsetof(ULGUITextureData, SpriteInfo) == 0x000038, "Member 'ULGUITextureData::SpriteInfo' has a wrong offset!");

// Class LGUI.LGUIWorldSpaceInteraction
// 0x0010 (0x0280 - 0x0270)
class ULGUIWorldSpaceInteraction final : public ULGUI_UIRaycaster
{
public:
	float                                         ClickThreshold;                                    // 0x0268(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          HoldToDrag;                                        // 0x026C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11E5[0x3];                                     // 0x026D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HoldToDragTime;                                    // 0x0270(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELGUIWorldSpaceInteractionSource              InteractionSource;                                 // 0x0274(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11E6[0xB];                                     // 0x0275(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetClickThreshold(float Value);
	void SetHoldToDrag(bool Value);
	void SetHoldToDragTime(float Value);
	void SetInteractionSource(ELGUIWorldSpaceInteractionSource Value);

	float GetClickThreshold() const;
	bool GetHoldToDrag() const;
	float GetHoldToDragTime() const;
	ELGUIWorldSpaceInteractionSource GetInteractionSource() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIWorldSpaceInteraction">();
	}
	static class ULGUIWorldSpaceInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIWorldSpaceInteraction>();
	}
};
static_assert(alignof(ULGUIWorldSpaceInteraction) == 0x000010, "Wrong alignment on ULGUIWorldSpaceInteraction");
static_assert(sizeof(ULGUIWorldSpaceInteraction) == 0x000280, "Wrong size on ULGUIWorldSpaceInteraction");
static_assert(offsetof(ULGUIWorldSpaceInteraction, ClickThreshold) == 0x000268, "Member 'ULGUIWorldSpaceInteraction::ClickThreshold' has a wrong offset!");
static_assert(offsetof(ULGUIWorldSpaceInteraction, HoldToDrag) == 0x00026C, "Member 'ULGUIWorldSpaceInteraction::HoldToDrag' has a wrong offset!");
static_assert(offsetof(ULGUIWorldSpaceInteraction, HoldToDragTime) == 0x000270, "Member 'ULGUIWorldSpaceInteraction::HoldToDragTime' has a wrong offset!");
static_assert(offsetof(ULGUIWorldSpaceInteraction, InteractionSource) == 0x000274, "Member 'ULGUIWorldSpaceInteraction::InteractionSource' has a wrong offset!");

// Class LGUI.UISelectableStateHolder
// 0x0018 (0x0128 - 0x0110)
class UUISelectableStateHolder final : public UUISelectableTransitionComponent
{
public:
	uint8                                         Pad_11E7[0x10];                                    // 0x0110(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EStateTransitionType                          TransitionType;                                    // 0x0120(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11E8[0x7];                                     // 0x0121(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAllTransitionsEnable(bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISelectableStateHolder">();
	}
	static class UUISelectableStateHolder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISelectableStateHolder>();
	}
};
static_assert(alignof(UUISelectableStateHolder) == 0x000008, "Wrong alignment on UUISelectableStateHolder");
static_assert(sizeof(UUISelectableStateHolder) == 0x000128, "Wrong size on UUISelectableStateHolder");
static_assert(offsetof(UUISelectableStateHolder, TransitionType) == 0x000120, "Member 'UUISelectableStateHolder::TransitionType' has a wrong offset!");

// Class LGUI.LGUIWorldSpaceInteractionForNoneUI
// 0x0010 (0x0270 - 0x0260)
class ULGUIWorldSpaceInteractionForNoneUI final : public ULGUI_WorldRaycaster
{
public:
	float                                         ClickThreshold;                                    // 0x0260(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          HoldToDrag;                                        // 0x0264(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11E9[0x3];                                     // 0x0265(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HoldToDragTime;                                    // 0x0268(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELGUIWorldSpaceInteractionSource              InteractionSource;                                 // 0x026C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11EA[0x3];                                     // 0x026D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetClickThreshold(float Value);
	void SetHoldToDrag(bool Value);
	void SetHoldToDragTime(float Value);
	void SetInteractionSource(ELGUIWorldSpaceInteractionSource Value);

	float GetClickThreshold() const;
	bool GetHoldToDrag() const;
	float GetHoldToDragTime() const;
	ELGUIWorldSpaceInteractionSource GetInteractionSource() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIWorldSpaceInteractionForNoneUI">();
	}
	static class ULGUIWorldSpaceInteractionForNoneUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIWorldSpaceInteractionForNoneUI>();
	}
};
static_assert(alignof(ULGUIWorldSpaceInteractionForNoneUI) == 0x000010, "Wrong alignment on ULGUIWorldSpaceInteractionForNoneUI");
static_assert(sizeof(ULGUIWorldSpaceInteractionForNoneUI) == 0x000270, "Wrong size on ULGUIWorldSpaceInteractionForNoneUI");
static_assert(offsetof(ULGUIWorldSpaceInteractionForNoneUI, ClickThreshold) == 0x000260, "Member 'ULGUIWorldSpaceInteractionForNoneUI::ClickThreshold' has a wrong offset!");
static_assert(offsetof(ULGUIWorldSpaceInteractionForNoneUI, HoldToDrag) == 0x000264, "Member 'ULGUIWorldSpaceInteractionForNoneUI::HoldToDrag' has a wrong offset!");
static_assert(offsetof(ULGUIWorldSpaceInteractionForNoneUI, HoldToDragTime) == 0x000268, "Member 'ULGUIWorldSpaceInteractionForNoneUI::HoldToDragTime' has a wrong offset!");
static_assert(offsetof(ULGUIWorldSpaceInteractionForNoneUI, InteractionSource) == 0x00026C, "Member 'ULGUIWorldSpaceInteractionForNoneUI::InteractionSource' has a wrong offset!");

// Class LGUI.RootTextItemMapDataV2
// 0x0100 (0x01C0 - 0x00C0)
class URootTextItemMapDataV2 final : public UActorComponent
{
public:
	TMap<uint32, TWeakObjectPtr<class AUITextActor>> TextActorMap;                                      // 0x00C0(0x0050)(Edit, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<uint32, TWeakObjectPtr<class AUITextActor>> DirtyTextActorMap;                                 // 0x0110(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<uint32, uint32>                          TransitionTextIdMap;                               // 0x0160(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	bool                                          bUnpackAllText;                                    // 0x01B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPartOfNested;                                   // 0x01B1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11EB[0xE];                                     // 0x01B2(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RootTextItemMapDataV2">();
	}
	static class URootTextItemMapDataV2* GetDefaultObj()
	{
		return GetDefaultObjImpl<URootTextItemMapDataV2>();
	}
};
static_assert(alignof(URootTextItemMapDataV2) == 0x000008, "Wrong alignment on URootTextItemMapDataV2");
static_assert(sizeof(URootTextItemMapDataV2) == 0x0001C0, "Wrong size on URootTextItemMapDataV2");
static_assert(offsetof(URootTextItemMapDataV2, TextActorMap) == 0x0000C0, "Member 'URootTextItemMapDataV2::TextActorMap' has a wrong offset!");
static_assert(offsetof(URootTextItemMapDataV2, DirtyTextActorMap) == 0x000110, "Member 'URootTextItemMapDataV2::DirtyTextActorMap' has a wrong offset!");
static_assert(offsetof(URootTextItemMapDataV2, TransitionTextIdMap) == 0x000160, "Member 'URootTextItemMapDataV2::TransitionTextIdMap' has a wrong offset!");
static_assert(offsetof(URootTextItemMapDataV2, bUnpackAllText) == 0x0001B0, "Member 'URootTextItemMapDataV2::bUnpackAllText' has a wrong offset!");
static_assert(offsetof(URootTextItemMapDataV2, bIsPartOfNested) == 0x0001B1, "Member 'URootTextItemMapDataV2::bIsPartOfNested' has a wrong offset!");

// Class LGUI.UISpriteBase_BP
// 0x0010 (0x0780 - 0x0770)
class UUISpriteBase_BP final : public UUISpriteBase
{
public:
	class ULGUICreateGeometryHelper*              CreateGeometryHelper;                              // 0x0768(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULGUIUpdateGeometryHelper*              UpdateGeometryHelper;                              // 0x0770(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11EC[0x8];                                     // 0x0778(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MarkRebuildGeometry_BP();
	void MarkVertexChanged_BP();
	void OnBeforeCreateOrUpdateGeometry_BP();
	void OnCreateGeometry_BP(class ULGUICreateGeometryHelper* InCreateGeometryHelper, class ULGUISpriteData_BaseObject* InSpriteData);
	void OnUpdateGeometry_BP(class ULGUIUpdateGeometryHelper* InUpdateGoemetryHelper, class ULGUISpriteData_BaseObject* InSpriteData, bool InVertexPositionChanged, bool InVertexUVChanged, bool InVertexColorChanged);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISpriteBase_BP">();
	}
	static class UUISpriteBase_BP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISpriteBase_BP>();
	}
};
static_assert(alignof(UUISpriteBase_BP) == 0x000010, "Wrong alignment on UUISpriteBase_BP");
static_assert(sizeof(UUISpriteBase_BP) == 0x000780, "Wrong size on UUISpriteBase_BP");
static_assert(offsetof(UUISpriteBase_BP, CreateGeometryHelper) == 0x000768, "Member 'UUISpriteBase_BP::CreateGeometryHelper' has a wrong offset!");
static_assert(offsetof(UUISpriteBase_BP, UpdateGeometryHelper) == 0x000770, "Member 'UUISpriteBase_BP::UpdateGeometryHelper' has a wrong offset!");

// Class LGUI.SequencePlayContext
// 0x0178 (0x01A8 - 0x0030)
class USequencePlayContext final : public UObject
{
public:
	struct FSequenceInfo                          PlayInfo;                                          // 0x0030(0x0038)(NativeAccessSpecifierPublic)
	bool                                          bReverse;                                          // 0x0068(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAsync;                                          // 0x0069(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11EE[0x6];                                     // 0x006A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             OnLoaded;                                          // 0x0070(0x0028)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnPlay;                                            // 0x0098(0x0028)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnFinish;                                          // 0x00C0(0x0028)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnPlayReverse;                                     // 0x00E8(0x0028)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnStop;                                            // 0x0110(0x0028)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnPause;                                           // 0x0138(0x0028)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnInterrupt;                                       // 0x0160(0x0028)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_11EF[0x10];                                    // 0x0188(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AUIBaseActor*>                   Roots;                                             // 0x0198(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void ExecutePlay();
	void SetBatchRoots(const TArray<class AUIBaseActor*>& BatchRoots);
	void TryStop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SequencePlayContext">();
	}
	static class USequencePlayContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<USequencePlayContext>();
	}
};
static_assert(alignof(USequencePlayContext) == 0x000008, "Wrong alignment on USequencePlayContext");
static_assert(sizeof(USequencePlayContext) == 0x0001A8, "Wrong size on USequencePlayContext");
static_assert(offsetof(USequencePlayContext, PlayInfo) == 0x000030, "Member 'USequencePlayContext::PlayInfo' has a wrong offset!");
static_assert(offsetof(USequencePlayContext, bReverse) == 0x000068, "Member 'USequencePlayContext::bReverse' has a wrong offset!");
static_assert(offsetof(USequencePlayContext, bIsAsync) == 0x000069, "Member 'USequencePlayContext::bIsAsync' has a wrong offset!");
static_assert(offsetof(USequencePlayContext, OnLoaded) == 0x000070, "Member 'USequencePlayContext::OnLoaded' has a wrong offset!");
static_assert(offsetof(USequencePlayContext, OnPlay) == 0x000098, "Member 'USequencePlayContext::OnPlay' has a wrong offset!");
static_assert(offsetof(USequencePlayContext, OnFinish) == 0x0000C0, "Member 'USequencePlayContext::OnFinish' has a wrong offset!");
static_assert(offsetof(USequencePlayContext, OnPlayReverse) == 0x0000E8, "Member 'USequencePlayContext::OnPlayReverse' has a wrong offset!");
static_assert(offsetof(USequencePlayContext, OnStop) == 0x000110, "Member 'USequencePlayContext::OnStop' has a wrong offset!");
static_assert(offsetof(USequencePlayContext, OnPause) == 0x000138, "Member 'USequencePlayContext::OnPause' has a wrong offset!");
static_assert(offsetof(USequencePlayContext, OnInterrupt) == 0x000160, "Member 'USequencePlayContext::OnInterrupt' has a wrong offset!");
static_assert(offsetof(USequencePlayContext, Roots) == 0x000198, "Member 'USequencePlayContext::Roots' has a wrong offset!");

// Class LGUI.SequencerManager
// 0x0178 (0x01A8 - 0x0030)
class USequencerManager final : public UObject
{
public:
	uint8                                         Pad_11F0[0x8];                                     // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLevelSequencerActor>           AllLvlSequencerActors;                             // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11F1[0x138];                                   // 0x0048(0x0138)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USequencePlayContext*>           BatchPlayContexts;                                 // 0x0180(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class USequencePlayContext*                   TransientSyncParamContext;                         // 0x0190(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11F2[0x10];                                    // 0x0198(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ALevelSequenceActor* BatchPlaySequenceOnActors(class UObject* Context, const struct FSoftObjectPath& SequencePath, const TArray<class AUIBaseActor*>& BatchRoots, const struct FMovieSceneSequencePlaybackSettings& PlaySetting);
	static class USequencePlayContext* GetBatchPlayContext(class UObject* Context);
	static ESequenceLoadState GetSequenceLoadState(const class UObject* Context, const struct FSoftObjectPath& Path);
	static void LoadSequenceAssetAsync(const class UObject* Context, const struct FSoftObjectPath& Path, const TDelegate<void(class ULevelSequence* Sequence)>& OnLoad);

	void ClearInvalidBind(class ALevelSequenceActor* SeqActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SequencerManager">();
	}
	static class USequencerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USequencerManager>();
	}
};
static_assert(alignof(USequencerManager) == 0x000008, "Wrong alignment on USequencerManager");
static_assert(sizeof(USequencerManager) == 0x0001A8, "Wrong size on USequencerManager");
static_assert(offsetof(USequencerManager, AllLvlSequencerActors) == 0x000038, "Member 'USequencerManager::AllLvlSequencerActors' has a wrong offset!");
static_assert(offsetof(USequencerManager, BatchPlayContexts) == 0x000180, "Member 'USequencerManager::BatchPlayContexts' has a wrong offset!");
static_assert(offsetof(USequencerManager, TransientSyncParamContext) == 0x000190, "Member 'USequencerManager::TransientSyncParamContext' has a wrong offset!");

// Class LGUI.UITextActor
// 0x0008 (0x0398 - 0x0390)
class AUITextActor final : public AUIBaseActor
{
public:
	class UUIText*                                UIText;                                            // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITextActor">();
	}
	static class AUITextActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUITextActor>();
	}
};
static_assert(alignof(AUITextActor) == 0x000008, "Wrong alignment on AUITextActor");
static_assert(sizeof(AUITextActor) == 0x000398, "Wrong size on AUITextActor");
static_assert(offsetof(AUITextActor, UIText) == 0x000390, "Member 'AUITextActor::UIText' has a wrong offset!");

// Class LGUI.UISpriteTransition
// 0x0080 (0x02E8 - 0x0268)
class UUISpriteTransition final : public UUITransitionBase
{
public:
	struct FSpriteTransitionInfo                  TransitionInfo;                                    // 0x0268(0x0080)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void SetAllTransitionSprite(class ULGUISpriteData_BaseObject* NewSprite);
	void SetStateSprite(EUISelectableSelectionState State, class ULGUISpriteData_BaseObject* NewSprite);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISpriteTransition">();
	}
	static class UUISpriteTransition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISpriteTransition>();
	}
};
static_assert(alignof(UUISpriteTransition) == 0x000008, "Wrong alignment on UUISpriteTransition");
static_assert(sizeof(UUISpriteTransition) == 0x0002E8, "Wrong size on UUISpriteTransition");
static_assert(offsetof(UUISpriteTransition, TransitionInfo) == 0x000268, "Member 'UUISpriteTransition::TransitionInfo' has a wrong offset!");

// Class LGUI.UISprite
// 0x0030 (0x07A0 - 0x0770)
class UUISprite final : public UUISpriteBase
{
public:
	EUISpriteType                                 Type;                                              // 0x0768(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUISpriteFillMethod                           FillMethod;                                        // 0x0769(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         FillOrigin;                                        // 0x076A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FillDirectionFlip;                                 // 0x076B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FillAmount;                                        // 0x076C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTileAutoFit;                                      // 0x0770(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11F6[0x3];                                     // 0x0771(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClampEdge;                                         // 0x0774(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TileX;                                             // 0x0778(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TileY;                                             // 0x077C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OffsetX;                                           // 0x0780(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OffsetY;                                           // 0x0784(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     HistoryCustomMaterial;                             // 0x0788(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11F7[0x10];                                    // 0x0790(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetFillAmount(float NewValue);
	void SetFillDirectionFlip(bool NewValue);
	void SetFillMethod(EUISpriteFillMethod NewValue);
	void SetFillOrigin(uint8 NewValue);
	void SetOffsetX(float NewValue);
	void SetOffsetY(float NewValue);
	void SetSpriteType(EUISpriteType NewType);
	void SetTileOffset(const struct FLinearColor& In);
	void SetTileX(float NewValue);
	void SetTileY(float NewValue);

	float GetFillAmount() const;
	bool GetFillDirectionFlip() const;
	EUISpriteFillMethod GetFillMethod() const;
	uint8 GetFillOrigin() const;
	EUISpriteType GetSpriteType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISprite">();
	}
	static class UUISprite* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISprite>();
	}
};
static_assert(alignof(UUISprite) == 0x000010, "Wrong alignment on UUISprite");
static_assert(sizeof(UUISprite) == 0x0007A0, "Wrong size on UUISprite");
static_assert(offsetof(UUISprite, Type) == 0x000768, "Member 'UUISprite::Type' has a wrong offset!");
static_assert(offsetof(UUISprite, FillMethod) == 0x000769, "Member 'UUISprite::FillMethod' has a wrong offset!");
static_assert(offsetof(UUISprite, FillOrigin) == 0x00076A, "Member 'UUISprite::FillOrigin' has a wrong offset!");
static_assert(offsetof(UUISprite, FillDirectionFlip) == 0x00076B, "Member 'UUISprite::FillDirectionFlip' has a wrong offset!");
static_assert(offsetof(UUISprite, FillAmount) == 0x00076C, "Member 'UUISprite::FillAmount' has a wrong offset!");
static_assert(offsetof(UUISprite, bTileAutoFit) == 0x000770, "Member 'UUISprite::bTileAutoFit' has a wrong offset!");
static_assert(offsetof(UUISprite, ClampEdge) == 0x000774, "Member 'UUISprite::ClampEdge' has a wrong offset!");
static_assert(offsetof(UUISprite, TileX) == 0x000778, "Member 'UUISprite::TileX' has a wrong offset!");
static_assert(offsetof(UUISprite, TileY) == 0x00077C, "Member 'UUISprite::TileY' has a wrong offset!");
static_assert(offsetof(UUISprite, OffsetX) == 0x000780, "Member 'UUISprite::OffsetX' has a wrong offset!");
static_assert(offsetof(UUISprite, OffsetY) == 0x000784, "Member 'UUISprite::OffsetY' has a wrong offset!");
static_assert(offsetof(UUISprite, HistoryCustomMaterial) == 0x000788, "Member 'UUISprite::HistoryCustomMaterial' has a wrong offset!");

// Class LGUI.UI2DLineChildrenAsPoints
// 0x0030 (0x07B0 - 0x0780)
class UUI2DLineChildrenAsPoints final : public UUI2DLineRendererBase
{
public:
	uint8                                         Pad_11F8[0x10];                                    // 0x0780(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector2D>                      CurrentPointArray;                                 // 0x0790(0x0010)(Edit, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class UUIItem*>                        SortedItemArray;                                   // 0x07A0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI2DLineChildrenAsPoints">();
	}
	static class UUI2DLineChildrenAsPoints* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI2DLineChildrenAsPoints>();
	}
};
static_assert(alignof(UUI2DLineChildrenAsPoints) == 0x000010, "Wrong alignment on UUI2DLineChildrenAsPoints");
static_assert(sizeof(UUI2DLineChildrenAsPoints) == 0x0007B0, "Wrong size on UUI2DLineChildrenAsPoints");
static_assert(offsetof(UUI2DLineChildrenAsPoints, CurrentPointArray) == 0x000790, "Member 'UUI2DLineChildrenAsPoints::CurrentPointArray' has a wrong offset!");
static_assert(offsetof(UUI2DLineChildrenAsPoints, SortedItemArray) == 0x0007A0, "Member 'UUI2DLineChildrenAsPoints::SortedItemArray' has a wrong offset!");

// Class LGUI.UI2DLineChildrenAsPointsActor
// 0x0008 (0x0398 - 0x0390)
class AUI2DLineChildrenAsPointsActor final : public AUIBaseActor
{
public:
	class UUI2DLineChildrenAsPoints*              UIElement;                                         // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI2DLineChildrenAsPointsActor">();
	}
	static class AUI2DLineChildrenAsPointsActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUI2DLineChildrenAsPointsActor>();
	}
};
static_assert(alignof(AUI2DLineChildrenAsPointsActor) == 0x000008, "Wrong alignment on AUI2DLineChildrenAsPointsActor");
static_assert(sizeof(AUI2DLineChildrenAsPointsActor) == 0x000398, "Wrong size on AUI2DLineChildrenAsPointsActor");
static_assert(offsetof(AUI2DLineChildrenAsPointsActor, UIElement) == 0x000390, "Member 'AUI2DLineChildrenAsPointsActor::UIElement' has a wrong offset!");

// Class LGUI.UITextureBoxActor
// 0x0008 (0x0398 - 0x0390)
class AUITextureBoxActor final : public AUIBaseActor
{
public:
	class UUITextureBox*                          UITextureBox;                                      // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITextureBoxActor">();
	}
	static class AUITextureBoxActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUITextureBoxActor>();
	}
};
static_assert(alignof(AUITextureBoxActor) == 0x000008, "Wrong alignment on AUITextureBoxActor");
static_assert(sizeof(AUITextureBoxActor) == 0x000398, "Wrong size on AUITextureBoxActor");
static_assert(offsetof(AUITextureBoxActor, UITextureBox) == 0x000390, "Member 'AUITextureBoxActor::UITextureBox' has a wrong offset!");

// Class LGUI.UI2DLineRaw
// 0x0010 (0x0790 - 0x0780)
class UUI2DLineRaw final : public UUI2DLineRendererBase
{
public:
	TArray<struct FVector2D>                      PointArray;                                        // 0x0780(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void AdjustSize();
	void SetPoints(const TArray<struct FVector2D>& InPoints, bool bAdjustSize);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI2DLineRaw">();
	}
	static class UUI2DLineRaw* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI2DLineRaw>();
	}
};
static_assert(alignof(UUI2DLineRaw) == 0x000010, "Wrong alignment on UUI2DLineRaw");
static_assert(sizeof(UUI2DLineRaw) == 0x000790, "Wrong size on UUI2DLineRaw");
static_assert(offsetof(UUI2DLineRaw, PointArray) == 0x000780, "Member 'UUI2DLineRaw::PointArray' has a wrong offset!");

// Class LGUI.UI2DLineActor
// 0x0008 (0x0398 - 0x0390)
class AUI2DLineActor final : public AUIBaseActor
{
public:
	class UUI2DLineRaw*                           UIElement;                                         // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI2DLineActor">();
	}
	static class AUI2DLineActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUI2DLineActor>();
	}
};
static_assert(alignof(AUI2DLineActor) == 0x000008, "Wrong alignment on AUI2DLineActor");
static_assert(sizeof(AUI2DLineActor) == 0x000398, "Wrong size on AUI2DLineActor");
static_assert(offsetof(AUI2DLineActor, UIElement) == 0x000390, "Member 'AUI2DLineActor::UIElement' has a wrong offset!");

// Class LGUI.UIAndroidBackComponent
// 0x0008 (0x0108 - 0x0100)
class UUIAndroidBackComponent final : public ULGUIBehaviour
{
public:
	struct FVector2D                              ClickPivot;                                        // 0x0100(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static void ClearAndroidBackComponent();
	static int32 GetActiveAndroidBackComponentSize();
	static class UUIAndroidBackComponent* GetTopActiveAndroidBack();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIAndroidBackComponent">();
	}
	static class UUIAndroidBackComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIAndroidBackComponent>();
	}
};
static_assert(alignof(UUIAndroidBackComponent) == 0x000008, "Wrong alignment on UUIAndroidBackComponent");
static_assert(sizeof(UUIAndroidBackComponent) == 0x000108, "Wrong size on UUIAndroidBackComponent");
static_assert(offsetof(UUIAndroidBackComponent, ClickPivot) == 0x000100, "Member 'UUIAndroidBackComponent::ClickPivot' has a wrong offset!");

// Class LGUI.UIPostProcessRenderable
// 0x0050 (0x05B0 - 0x0560)
class UUIPostProcessRenderable : public UUIBaseRenderable
{
public:
	uint8                                         Pad_11FA[0x10];                                    // 0x0560(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             MaskTexture;                                       // 0x0570(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11FB[0x38];                                    // 0x0578(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMaskTexture(class UTexture2D* NewValue);

	class UTexture2D* GetMaskTexture() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPostProcessRenderable">();
	}
	static class UUIPostProcessRenderable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPostProcessRenderable>();
	}
};
static_assert(alignof(UUIPostProcessRenderable) == 0x000010, "Wrong alignment on UUIPostProcessRenderable");
static_assert(sizeof(UUIPostProcessRenderable) == 0x0005B0, "Wrong size on UUIPostProcessRenderable");
static_assert(offsetof(UUIPostProcessRenderable, MaskTexture) == 0x000570, "Member 'UUIPostProcessRenderable::MaskTexture' has a wrong offset!");

// Class LGUI.UIBackgroundBlur
// 0x0020 (0x05D0 - 0x05B0)
class UUIBackgroundBlur final : public UUIPostProcessRenderable
{
public:
	float                                         blurStrength;                                      // 0x05B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ApplyAlphaToBlur;                                  // 0x05B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11FC[0x3];                                     // 0x05B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxDownSampleLevel;                                // 0x05B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11FD[0x4];                                     // 0x05BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             StrengthTexture;                                   // 0x05C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11FE[0x8];                                     // 0x05C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetApplyAlphaToBlur(bool NewValue);
	void SetBlurStrength(float NewValue);
	void SetMaxDownSampleLevel(int32 NewValue);
	void SetStrengthTexture(class UTexture2D* NewValue);

	bool GetApplyAlphaToBlur() const;
	float GetBlurStrength() const;
	int32 GetMaxDownSampleLevel() const;
	class UTexture2D* GetStrengthTexture() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBackgroundBlur">();
	}
	static class UUIBackgroundBlur* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBackgroundBlur>();
	}
};
static_assert(alignof(UUIBackgroundBlur) == 0x000010, "Wrong alignment on UUIBackgroundBlur");
static_assert(sizeof(UUIBackgroundBlur) == 0x0005D0, "Wrong size on UUIBackgroundBlur");
static_assert(offsetof(UUIBackgroundBlur, blurStrength) == 0x0005B0, "Member 'UUIBackgroundBlur::blurStrength' has a wrong offset!");
static_assert(offsetof(UUIBackgroundBlur, ApplyAlphaToBlur) == 0x0005B4, "Member 'UUIBackgroundBlur::ApplyAlphaToBlur' has a wrong offset!");
static_assert(offsetof(UUIBackgroundBlur, MaxDownSampleLevel) == 0x0005B8, "Member 'UUIBackgroundBlur::MaxDownSampleLevel' has a wrong offset!");
static_assert(offsetof(UUIBackgroundBlur, StrengthTexture) == 0x0005C0, "Member 'UUIBackgroundBlur::StrengthTexture' has a wrong offset!");

// Class LGUI.UIPostProcessBaseActor
// 0x0000 (0x0390 - 0x0390)
class AUIPostProcessBaseActor : public AUIBaseActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPostProcessBaseActor">();
	}
	static class AUIPostProcessBaseActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIPostProcessBaseActor>();
	}
};
static_assert(alignof(AUIPostProcessBaseActor) == 0x000008, "Wrong alignment on AUIPostProcessBaseActor");
static_assert(sizeof(AUIPostProcessBaseActor) == 0x000390, "Wrong size on AUIPostProcessBaseActor");

// Class LGUI.UITextureBase
// 0x0040 (0x07A0 - 0x0760)
#pragma pack(push, 0x1)
class alignas(0x10) UUITextureBase : public UUIBatchGeometryRenderable
{
public:
	class UTexture*                               Texture;                                           // 0x0758(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11FF[0x38];                                    // 0x0760(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDynamicAtlasSlotBuilt(const struct FDynamicAtlasSlotManagedHandle& ManagedHandle);
	void SetDynamicAtlasTextureAsync(const class FString& InAtlasTag, const struct FSoftObjectPath& InSoftObjectPath);
	void SetSizeFromTexture();
	void SetTexture(class UTexture* NewTexture);

	class UTexture* GetTexture() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITextureBase">();
	}
	static class UUITextureBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITextureBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(UUITextureBase) == 0x000010, "Wrong alignment on UUITextureBase");
static_assert(sizeof(UUITextureBase) == 0x0007A0, "Wrong size on UUITextureBase");
static_assert(offsetof(UUITextureBase, Texture) == 0x000758, "Member 'UUITextureBase::Texture' has a wrong offset!");

// Class LGUI.UITextureBase_BP
// 0x0010 (0x07B0 - 0x07A0)
class UUITextureBase_BP final : public UUITextureBase
{
public:
	class ULGUICreateGeometryHelper*              CreateGeometryHelper;                              // 0x0798(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULGUIUpdateGeometryHelper*              UpdateGeometryHelper;                              // 0x07A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1200[0x8];                                     // 0x07A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MarkRebuildGeometry_BP();
	void MarkVertexChanged_BP();
	void OnBeforeCreateOrUpdateGeometry_BP();
	void OnCreateGeometry_BP(class ULGUICreateGeometryHelper* InCreateGeometryHelper);
	void OnUpdateGeometry_BP(class ULGUIUpdateGeometryHelper* InUpdateGoemetryHelper, bool InVertexPositionChanged, bool InVertexUVChanged, bool InVertexColorChanged);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITextureBase_BP">();
	}
	static class UUITextureBase_BP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITextureBase_BP>();
	}
};
static_assert(alignof(UUITextureBase_BP) == 0x000010, "Wrong alignment on UUITextureBase_BP");
static_assert(sizeof(UUITextureBase_BP) == 0x0007B0, "Wrong size on UUITextureBase_BP");
static_assert(offsetof(UUITextureBase_BP, CreateGeometryHelper) == 0x000798, "Member 'UUITextureBase_BP::CreateGeometryHelper' has a wrong offset!");
static_assert(offsetof(UUITextureBase_BP, UpdateGeometryHelper) == 0x0007A0, "Member 'UUITextureBase_BP::UpdateGeometryHelper' has a wrong offset!");

// Class LGUI.UIBackgroundBlurActor
// 0x0008 (0x0398 - 0x0390)
class AUIBackgroundBlurActor final : public AUIPostProcessBaseActor
{
public:
	class UUIBackgroundBlur*                      UIBackgroundBlur;                                  // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBackgroundBlurActor">();
	}
	static class AUIBackgroundBlurActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIBackgroundBlurActor>();
	}
};
static_assert(alignof(AUIBackgroundBlurActor) == 0x000008, "Wrong alignment on AUIBackgroundBlurActor");
static_assert(sizeof(AUIBackgroundBlurActor) == 0x000398, "Wrong size on AUIBackgroundBlurActor");
static_assert(offsetof(AUIBackgroundBlurActor, UIBackgroundBlur) == 0x000390, "Member 'AUIBackgroundBlurActor::UIBackgroundBlur' has a wrong offset!");

// Class LGUI.UIBackgroundPixelate
// 0x0010 (0x05C0 - 0x05B0)
class UUIBackgroundPixelate final : public UUIPostProcessRenderable
{
public:
	float                                         PixelateStrength;                                  // 0x05B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ApplyAlphaToStrength;                              // 0x05B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1202[0xB];                                     // 0x05B5(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetApplyAlphaToStrength(bool NewValue);
	void SetPixelateStrength(float NewValue);

	bool GetApplyAlphaToStrength() const;
	float GetPixelateStrength() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBackgroundPixelate">();
	}
	static class UUIBackgroundPixelate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBackgroundPixelate>();
	}
};
static_assert(alignof(UUIBackgroundPixelate) == 0x000010, "Wrong alignment on UUIBackgroundPixelate");
static_assert(sizeof(UUIBackgroundPixelate) == 0x0005C0, "Wrong size on UUIBackgroundPixelate");
static_assert(offsetof(UUIBackgroundPixelate, PixelateStrength) == 0x0005B0, "Member 'UUIBackgroundPixelate::PixelateStrength' has a wrong offset!");
static_assert(offsetof(UUIBackgroundPixelate, ApplyAlphaToStrength) == 0x0005B4, "Member 'UUIBackgroundPixelate::ApplyAlphaToStrength' has a wrong offset!");

// Class LGUI.LGUIMapTilesSyncer
// 0x0008 (0x0108 - 0x0100)
class ULGUIMapTilesSyncer final : public ULGUIBehaviour
{
public:
	class AActor*                                 TilesRoot;                                         // 0x0100(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIMapTilesSyncer">();
	}
	static class ULGUIMapTilesSyncer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIMapTilesSyncer>();
	}
};
static_assert(alignof(ULGUIMapTilesSyncer) == 0x000008, "Wrong alignment on ULGUIMapTilesSyncer");
static_assert(sizeof(ULGUIMapTilesSyncer) == 0x000108, "Wrong size on ULGUIMapTilesSyncer");
static_assert(offsetof(ULGUIMapTilesSyncer, TilesRoot) == 0x000100, "Member 'ULGUIMapTilesSyncer::TilesRoot' has a wrong offset!");

// Class LGUI.UIBackgroundPixelateActor
// 0x0008 (0x0398 - 0x0390)
class AUIBackgroundPixelateActor final : public AUIPostProcessBaseActor
{
public:
	class UUIBackgroundPixelate*                  UIBackgroundPixelate;                              // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBackgroundPixelateActor">();
	}
	static class AUIBackgroundPixelateActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIBackgroundPixelateActor>();
	}
};
static_assert(alignof(AUIBackgroundPixelateActor) == 0x000008, "Wrong alignment on AUIBackgroundPixelateActor");
static_assert(sizeof(AUIBackgroundPixelateActor) == 0x000398, "Wrong size on AUIBackgroundPixelateActor");
static_assert(offsetof(AUIBackgroundPixelateActor, UIBackgroundPixelate) == 0x000390, "Member 'AUIBackgroundPixelateActor::UIBackgroundPixelate' has a wrong offset!");

// Class LGUI.TextureTransitionUtil
// 0x0000 (0x0030 - 0x0030)
class UTextureTransitionUtil final : public UBlueprintFunctionLibrary
{
public:
	static void SetTextureByTransitionInfo(class UUITexture* Texture, const struct FTextureTransitionOfState& Info);
	static void SetTextureSize(class UUITexture* Texture, bool bIsSnapSize, float Width, float Height);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TextureTransitionUtil">();
	}
	static class UTextureTransitionUtil* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTextureTransitionUtil>();
	}
};
static_assert(alignof(UTextureTransitionUtil) == 0x000008, "Wrong alignment on UTextureTransitionUtil");
static_assert(sizeof(UTextureTransitionUtil) == 0x000030, "Wrong size on UTextureTransitionUtil");

// Class LGUI.LevelSequencePrefabData
// 0x0010 (0x0040 - 0x0030)
class ULevelSequencePrefabData final : public UAssetUserData
{
public:
	TArray<struct FGuid>                          SourcePrefabGuids;                                 // 0x0030(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelSequencePrefabData">();
	}
	static class ULevelSequencePrefabData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelSequencePrefabData>();
	}
};
static_assert(alignof(ULevelSequencePrefabData) == 0x000008, "Wrong alignment on ULevelSequencePrefabData");
static_assert(sizeof(ULevelSequencePrefabData) == 0x000040, "Wrong size on ULevelSequencePrefabData");
static_assert(offsetof(ULevelSequencePrefabData, SourcePrefabGuids) == 0x000030, "Member 'ULevelSequencePrefabData::SourcePrefabGuids' has a wrong offset!");

// Class LGUI.LGUICreateGeometryHelper
// 0x0010 (0x0040 - 0x0030)
class ULGUICreateGeometryHelper final : public UObject
{
public:
	uint8                                         Pad_1205[0x10];                                    // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddTriangle(int32 Index0, int32 Index1, int32 Index2);
	void AddVertexFull(const struct FVector& Position, const struct FColor& Color, const struct FVector2D& Uv0, const struct FVector2D& Uv1, const struct FVector2D& Uv2, const struct FVector2D& Uv3, const struct FVector& Normal, const struct FVector& Tangent);
	void AddVertexSimple(const struct FVector& Position, const struct FColor& Color, const struct FVector2D& Uv0);
	void AddVertexStruct(const struct FLGUIGeometryVertex& Vertex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUICreateGeometryHelper">();
	}
	static class ULGUICreateGeometryHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUICreateGeometryHelper>();
	}
};
static_assert(alignof(ULGUICreateGeometryHelper) == 0x000008, "Wrong alignment on ULGUICreateGeometryHelper");
static_assert(sizeof(ULGUICreateGeometryHelper) == 0x000040, "Wrong size on ULGUICreateGeometryHelper");

// Class LGUI.UITexture
// 0x0080 (0x0820 - 0x07A0)
class UUITexture : public UUITextureBase
{
public:
	EUITextureType                                Type;                                              // 0x0798(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1206[0x3];                                     // 0x0799(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUISpriteInfo                        SpriteData;                                        // 0x079C(0x0034)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class ULGUITextureData*                       TextureData;                                       // 0x07D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1207[0x8];                                     // 0x07D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4                               UvRect;                                            // 0x07E0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUISpriteFillMethod                           FillMethod;                                        // 0x07F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         FillOrigin;                                        // 0x07F1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FillDirectionFlip;                                 // 0x07F2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1208[0x1];                                     // 0x07F3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FillAmount;                                        // 0x07F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFrameAnimate;                                   // 0x07F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseFrameSize;                                     // 0x07F9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1209[0x2];                                     // 0x07FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FrameAnimateRows;                                  // 0x07FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FrameAnimateColumn;                                // 0x0800(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurFrame;                                          // 0x0804(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              FrameSize;                                         // 0x0808(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture*                               DynamicAtlasTexture;                               // 0x0810(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_120A[0x8];                                     // 0x0818(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCurFrame(float NewCurFrame);
	void SetFillAmount(float NewValue);
	void SetFillDirectionFlip(bool NewValue);
	void SetFillMethod(EUISpriteFillMethod NewValue);
	void SetFillOrigin(uint8 NewValue);
	void SetSpriteData(const struct FLGUISpriteInfo& NewSpriteData);
	void SetTextureData(class ULGUITextureData* NewTextureData);
	void SetTextureType(EUITextureType NewType);
	void SetUVRect(const struct FVector4& NewUVRect);

	float GetFillAmount() const;
	bool GetFillDirectionFlip() const;
	EUISpriteFillMethod GetFillMethod() const;
	uint8 GetFillOrigin() const;
	struct FLGUISpriteInfo GetSpriteData() const;
	class ULGUITextureData* GetTextureData() const;
	EUITextureType GetTextureType() const;
	struct FVector4 GetUVRect() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITexture">();
	}
	static class UUITexture* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITexture>();
	}
};
static_assert(alignof(UUITexture) == 0x000010, "Wrong alignment on UUITexture");
static_assert(sizeof(UUITexture) == 0x000820, "Wrong size on UUITexture");
static_assert(offsetof(UUITexture, Type) == 0x000798, "Member 'UUITexture::Type' has a wrong offset!");
static_assert(offsetof(UUITexture, SpriteData) == 0x00079C, "Member 'UUITexture::SpriteData' has a wrong offset!");
static_assert(offsetof(UUITexture, TextureData) == 0x0007D0, "Member 'UUITexture::TextureData' has a wrong offset!");
static_assert(offsetof(UUITexture, UvRect) == 0x0007E0, "Member 'UUITexture::UvRect' has a wrong offset!");
static_assert(offsetof(UUITexture, FillMethod) == 0x0007F0, "Member 'UUITexture::FillMethod' has a wrong offset!");
static_assert(offsetof(UUITexture, FillOrigin) == 0x0007F1, "Member 'UUITexture::FillOrigin' has a wrong offset!");
static_assert(offsetof(UUITexture, FillDirectionFlip) == 0x0007F2, "Member 'UUITexture::FillDirectionFlip' has a wrong offset!");
static_assert(offsetof(UUITexture, FillAmount) == 0x0007F4, "Member 'UUITexture::FillAmount' has a wrong offset!");
static_assert(offsetof(UUITexture, bIsFrameAnimate) == 0x0007F8, "Member 'UUITexture::bIsFrameAnimate' has a wrong offset!");
static_assert(offsetof(UUITexture, bUseFrameSize) == 0x0007F9, "Member 'UUITexture::bUseFrameSize' has a wrong offset!");
static_assert(offsetof(UUITexture, FrameAnimateRows) == 0x0007FC, "Member 'UUITexture::FrameAnimateRows' has a wrong offset!");
static_assert(offsetof(UUITexture, FrameAnimateColumn) == 0x000800, "Member 'UUITexture::FrameAnimateColumn' has a wrong offset!");
static_assert(offsetof(UUITexture, CurFrame) == 0x000804, "Member 'UUITexture::CurFrame' has a wrong offset!");
static_assert(offsetof(UUITexture, FrameSize) == 0x000808, "Member 'UUITexture::FrameSize' has a wrong offset!");
static_assert(offsetof(UUITexture, DynamicAtlasTexture) == 0x000810, "Member 'UUITexture::DynamicAtlasTexture' has a wrong offset!");

// Class LGUI.LGUIUpdateGeometryHelper
// 0x0020 (0x0050 - 0x0030)
class ULGUIUpdateGeometryHelper final : public UObject
{
public:
	uint8                                         Pad_120B[0x10];                                    // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLGUIGeometryVertex>            CacheVertices;                                     // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)

public:
	void BeginUpdateVertices();
	void EndUpdateVertices();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LGUIUpdateGeometryHelper">();
	}
	static class ULGUIUpdateGeometryHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULGUIUpdateGeometryHelper>();
	}
};
static_assert(alignof(ULGUIUpdateGeometryHelper) == 0x000008, "Wrong alignment on ULGUIUpdateGeometryHelper");
static_assert(sizeof(ULGUIUpdateGeometryHelper) == 0x000050, "Wrong size on ULGUIUpdateGeometryHelper");
static_assert(offsetof(ULGUIUpdateGeometryHelper, CacheVertices) == 0x000040, "Member 'ULGUIUpdateGeometryHelper::CacheVertices' has a wrong offset!");

// Class LGUI.UIBatchGeometryRenderable_BP
// 0x0010 (0x0770 - 0x0760)
class UUIBatchGeometryRenderable_BP final : public UUIBatchGeometryRenderable
{
public:
	class ULGUICreateGeometryHelper*              CreateGeometryHelper;                              // 0x0758(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULGUIUpdateGeometryHelper*              UpdateGeometryHelper;                              // 0x0760(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120C[0x8];                                     // 0x0768(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MarkRebuildGeometry_BP();
	void MarkVertexChanged_BP();
	void OnBeforeCreateOrUpdateGeometry_BP();
	void OnCreateGeometry_BP(class ULGUICreateGeometryHelper* InCreateGeometryHelper);
	void OnUpdateGeometry_BP(class ULGUIUpdateGeometryHelper* InUpdateGoemetryHelper, bool InVertexPositionChanged, bool InVertexUVChanged, bool InVertexColorChanged);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIBatchGeometryRenderable_BP">();
	}
	static class UUIBatchGeometryRenderable_BP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIBatchGeometryRenderable_BP>();
	}
};
static_assert(alignof(UUIBatchGeometryRenderable_BP) == 0x000010, "Wrong alignment on UUIBatchGeometryRenderable_BP");
static_assert(sizeof(UUIBatchGeometryRenderable_BP) == 0x000770, "Wrong size on UUIBatchGeometryRenderable_BP");
static_assert(offsetof(UUIBatchGeometryRenderable_BP, CreateGeometryHelper) == 0x000758, "Member 'UUIBatchGeometryRenderable_BP::CreateGeometryHelper' has a wrong offset!");
static_assert(offsetof(UUIBatchGeometryRenderable_BP, UpdateGeometryHelper) == 0x000760, "Member 'UUIBatchGeometryRenderable_BP::UpdateGeometryHelper' has a wrong offset!");

// Class LGUI.UIViewAudioEffectComponent
// 0x0010 (0x00D0 - 0x00C0)
class UUIViewAudioEffectComponent final : public UActorComponent
{
public:
	bool                                          bAudioCoverEnable;                                 // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_120E[0x3];                                     // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AudioUiAlpha;                                      // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AudioUiCover;                                      // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_120F[0x4];                                     // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIViewAudioEffectComponent">();
	}
	static class UUIViewAudioEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIViewAudioEffectComponent>();
	}
};
static_assert(alignof(UUIViewAudioEffectComponent) == 0x000008, "Wrong alignment on UUIViewAudioEffectComponent");
static_assert(sizeof(UUIViewAudioEffectComponent) == 0x0000D0, "Wrong size on UUIViewAudioEffectComponent");
static_assert(offsetof(UUIViewAudioEffectComponent, bAudioCoverEnable) == 0x0000C0, "Member 'UUIViewAudioEffectComponent::bAudioCoverEnable' has a wrong offset!");
static_assert(offsetof(UUIViewAudioEffectComponent, AudioUiAlpha) == 0x0000C4, "Member 'UUIViewAudioEffectComponent::AudioUiAlpha' has a wrong offset!");
static_assert(offsetof(UUIViewAudioEffectComponent, AudioUiCover) == 0x0000C8, "Member 'UUIViewAudioEffectComponent::AudioUiCover' has a wrong offset!");

// Class LGUI.UIButtonComponent
// 0x0210 (0x05E0 - 0x03D0)
class UUIButtonComponent : public UUISelectableComponent
{
public:
	uint8                                         Pad_1210[0x8];                                     // 0x03D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUIDrawableEvent                     OnClick;                                           // 0x03D8(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1211[0x18];                                    // 0x03F0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAllowChangeCursorStyleWhenEnter;                  // 0x0408(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1212[0x7];                                     // 0x0409(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             OnClickCallBack;                                   // 0x0410(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnPointDownCallBack;                               // 0x0438(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnPointUpCallBack;                                 // 0x0460(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnPointCancelCallBack;                             // 0x0488(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnPointEnterCallBack;                              // 0x04B0(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnPointExitCallBack;                               // 0x04D8(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        AkAudioEvent;                                      // 0x0500(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const class FString& EventName)> OnPostAudioEvent;                                  // 0x0520(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TMap<EButtonAudioStateTransferType, struct FSoftObjectPath> AudioConfig;                                       // 0x0548(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        LongPressAudioEvent;                               // 0x0598(0x0020)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(EButtonAudioStateTransferType StateTransfer, const class FString& EventName)> OnPostAudioStateEvent;                             // 0x05B8(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)

public:
	bool OnPointerDown_Implementation(class ULGUIPointerEventData* EventData);
	struct FLGUIDelegateHandleWrapper RegisterClickEvent(const TDelegate<void()>& InDelegate);
	void UnregisterClickEvent(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIButtonComponent">();
	}
	static class UUIButtonComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIButtonComponent>();
	}
};
static_assert(alignof(UUIButtonComponent) == 0x000008, "Wrong alignment on UUIButtonComponent");
static_assert(sizeof(UUIButtonComponent) == 0x0005E0, "Wrong size on UUIButtonComponent");
static_assert(offsetof(UUIButtonComponent, OnClick) == 0x0003D8, "Member 'UUIButtonComponent::OnClick' has a wrong offset!");
static_assert(offsetof(UUIButtonComponent, bAllowChangeCursorStyleWhenEnter) == 0x000408, "Member 'UUIButtonComponent::bAllowChangeCursorStyleWhenEnter' has a wrong offset!");
static_assert(offsetof(UUIButtonComponent, OnClickCallBack) == 0x000410, "Member 'UUIButtonComponent::OnClickCallBack' has a wrong offset!");
static_assert(offsetof(UUIButtonComponent, OnPointDownCallBack) == 0x000438, "Member 'UUIButtonComponent::OnPointDownCallBack' has a wrong offset!");
static_assert(offsetof(UUIButtonComponent, OnPointUpCallBack) == 0x000460, "Member 'UUIButtonComponent::OnPointUpCallBack' has a wrong offset!");
static_assert(offsetof(UUIButtonComponent, OnPointCancelCallBack) == 0x000488, "Member 'UUIButtonComponent::OnPointCancelCallBack' has a wrong offset!");
static_assert(offsetof(UUIButtonComponent, OnPointEnterCallBack) == 0x0004B0, "Member 'UUIButtonComponent::OnPointEnterCallBack' has a wrong offset!");
static_assert(offsetof(UUIButtonComponent, OnPointExitCallBack) == 0x0004D8, "Member 'UUIButtonComponent::OnPointExitCallBack' has a wrong offset!");
static_assert(offsetof(UUIButtonComponent, AkAudioEvent) == 0x000500, "Member 'UUIButtonComponent::AkAudioEvent' has a wrong offset!");
static_assert(offsetof(UUIButtonComponent, OnPostAudioEvent) == 0x000520, "Member 'UUIButtonComponent::OnPostAudioEvent' has a wrong offset!");
static_assert(offsetof(UUIButtonComponent, AudioConfig) == 0x000548, "Member 'UUIButtonComponent::AudioConfig' has a wrong offset!");
static_assert(offsetof(UUIButtonComponent, LongPressAudioEvent) == 0x000598, "Member 'UUIButtonComponent::LongPressAudioEvent' has a wrong offset!");
static_assert(offsetof(UUIButtonComponent, OnPostAudioStateEvent) == 0x0005B8, "Member 'UUIButtonComponent::OnPostAudioStateEvent' has a wrong offset!");

// Class LGUI.UIComboBox
// 0x0038 (0x00F8 - 0x00C0)
class UUIComboBox final : public UActorComponent
{
public:
	uint8                                         Pad_1214[0x8];                                     // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AUIBaseActor*                           _RootUIActor;                                      // 0x00C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AUIBaseActor*                           _SrcItemActor;                                     // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1215[0x20];                                    // 0x00D8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UUIComboBox* CreateComboBoxFromArray(const TArray<class FString>& InItemNameArray, const TDelegate<void(int32 InSelectIndex, const class FString& InSelectItem)>& InCallback, class AUIBaseActor* InParentActor, int32 InSelectedItemIndex, EComboBoxPosition InPosition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIComboBox">();
	}
	static class UUIComboBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIComboBox>();
	}
};
static_assert(alignof(UUIComboBox) == 0x000008, "Wrong alignment on UUIComboBox");
static_assert(sizeof(UUIComboBox) == 0x0000F8, "Wrong size on UUIComboBox");
static_assert(offsetof(UUIComboBox, _RootUIActor) == 0x0000C8, "Member 'UUIComboBox::_RootUIActor' has a wrong offset!");
static_assert(offsetof(UUIComboBox, _SrcItemActor) == 0x0000D0, "Member 'UUIComboBox::_SrcItemActor' has a wrong offset!");

// Class LGUI.UIComboBoxItem
// 0x0030 (0x00F0 - 0x00C0)
class UUIComboBoxItem final : public UActorComponent
{
public:
	uint8                                         Pad_1217[0x8];                                     // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AUIBaseActor*                           _RootUIActor;                                      // 0x00C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AUITextActor*                           _TextActor;                                        // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AUISpriteActor*                         _HighlightSpriteActor;                             // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1218[0x10];                                    // 0x00E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIComboBoxItem">();
	}
	static class UUIComboBoxItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIComboBoxItem>();
	}
};
static_assert(alignof(UUIComboBoxItem) == 0x000008, "Wrong alignment on UUIComboBoxItem");
static_assert(sizeof(UUIComboBoxItem) == 0x0000F0, "Wrong size on UUIComboBoxItem");
static_assert(offsetof(UUIComboBoxItem, _RootUIActor) == 0x0000C8, "Member 'UUIComboBoxItem::_RootUIActor' has a wrong offset!");
static_assert(offsetof(UUIComboBoxItem, _TextActor) == 0x0000D0, "Member 'UUIComboBoxItem::_TextActor' has a wrong offset!");
static_assert(offsetof(UUIComboBoxItem, _HighlightSpriteActor) == 0x0000D8, "Member 'UUIComboBoxItem::_HighlightSpriteActor' has a wrong offset!");

// Class LGUI.ViewportUITextureActor
// 0x0008 (0x0398 - 0x0390)
class AViewportUITextureActor final : public AUIBaseActor
{
public:
	class UViewportUITexture*                     UITextureComponent;                                // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UViewportUITexture* GetUITexture();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ViewportUITextureActor">();
	}
	static class AViewportUITextureActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AViewportUITextureActor>();
	}
};
static_assert(alignof(AViewportUITextureActor) == 0x000008, "Wrong alignment on AViewportUITextureActor");
static_assert(sizeof(AViewportUITextureActor) == 0x000398, "Wrong size on AViewportUITextureActor");
static_assert(offsetof(AViewportUITextureActor, UITextureComponent) == 0x000390, "Member 'AViewportUITextureActor::UITextureComponent' has a wrong offset!");

// Class LGUI.UIContainerActor
// 0x0008 (0x0398 - 0x0390)
class AUIContainerActor : public AUIBaseActor
{
public:
	class UUIItem*                                UIItem;                                            // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIContainerActor">();
	}
	static class AUIContainerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIContainerActor>();
	}
};
static_assert(alignof(AUIContainerActor) == 0x000008, "Wrong alignment on AUIContainerActor");
static_assert(sizeof(AUIContainerActor) == 0x000398, "Wrong size on AUIContainerActor");
static_assert(offsetof(AUIContainerActor, UIItem) == 0x000390, "Member 'AUIContainerActor::UIItem' has a wrong offset!");

// Class LGUI.UICustomDepthStencilMask
// 0x0010 (0x05C0 - 0x05B0)
class UUICustomDepthStencilMask final : public UUIPostProcessRenderable
{
public:
	bool                                          bFullScreen;                                       // 0x05B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUICustomDepthStencilMaskSourceType           SourceType;                                        // 0x05B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1219[0x2];                                     // 0x05B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StencilValue;                                      // 0x05B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_121A[0x8];                                     // 0x05B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetFullScreen(bool Value);
	void SetSourceType(EUICustomDepthStencilMaskSourceType Value);
	void SetStencilValue(int32 Value);

	bool GetFullScreen() const;
	EUICustomDepthStencilMaskSourceType GetSourceType() const;
	int32 GetStencilValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICustomDepthStencilMask">();
	}
	static class UUICustomDepthStencilMask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUICustomDepthStencilMask>();
	}
};
static_assert(alignof(UUICustomDepthStencilMask) == 0x000010, "Wrong alignment on UUICustomDepthStencilMask");
static_assert(sizeof(UUICustomDepthStencilMask) == 0x0005C0, "Wrong size on UUICustomDepthStencilMask");
static_assert(offsetof(UUICustomDepthStencilMask, bFullScreen) == 0x0005B0, "Member 'UUICustomDepthStencilMask::bFullScreen' has a wrong offset!");
static_assert(offsetof(UUICustomDepthStencilMask, SourceType) == 0x0005B1, "Member 'UUICustomDepthStencilMask::SourceType' has a wrong offset!");
static_assert(offsetof(UUICustomDepthStencilMask, StencilValue) == 0x0005B4, "Member 'UUICustomDepthStencilMask::StencilValue' has a wrong offset!");

// Class LGUI.UIToggleGroupComponent
// 0x0080 (0x0140 - 0x00C0)
class UUIToggleGroupComponent final : public UActorComponent
{
public:
	uint8                                         Pad_121B[0x8];                                     // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UUIToggleComponent>      LastSelect;                                        // 0x00C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class UUIToggleComponent>> ToggleCollection;                                  // 0x00D0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          bAllowNoneSelected;                                // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_121C[0x1F];                                    // 0x00E1(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUIDrawableEvent                     OnToggle;                                          // 0x0100(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          AllowEventBubbleUp;                                // 0x0118(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121D[0x3];                                     // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UUIToggleComponent>      Selected;                                          // 0x011C(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UUIToggleComponent>      Highlighted;                                       // 0x0124(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_121E[0x4];                                     // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class UUIToggleComponent>> SelectableComponents;                              // 0x0130(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void ClearSelection();
	void OnComponentHighlighted(class UUIToggleComponent* Component);
	void OnComponentSelected(class UUIToggleComponent* Component);
	void OnComponentUnhighlighted();
	void OnComponentUnselected();
	struct FLGUIDelegateHandleWrapper RegisterToggleEvent(const TDelegate<void(int32 Index)>& InDelegate);
	void SetAllowNoneSelected(bool InBool);
	void SetSelection(class UUIToggleComponent* Target);
	void UnregisterToggleEvent(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);

	bool GetAllowNoneSelected() const;
	class UUIToggleComponent* GetSelectedItem() const;
	class UUIToggleComponent* GetToggleByIndex(int32 InIndex) const;
	int32 GetToggleIndex(const class UUIToggleComponent* InComp) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIToggleGroupComponent">();
	}
	static class UUIToggleGroupComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIToggleGroupComponent>();
	}
};
static_assert(alignof(UUIToggleGroupComponent) == 0x000008, "Wrong alignment on UUIToggleGroupComponent");
static_assert(sizeof(UUIToggleGroupComponent) == 0x000140, "Wrong size on UUIToggleGroupComponent");
static_assert(offsetof(UUIToggleGroupComponent, LastSelect) == 0x0000C8, "Member 'UUIToggleGroupComponent::LastSelect' has a wrong offset!");
static_assert(offsetof(UUIToggleGroupComponent, ToggleCollection) == 0x0000D0, "Member 'UUIToggleGroupComponent::ToggleCollection' has a wrong offset!");
static_assert(offsetof(UUIToggleGroupComponent, bAllowNoneSelected) == 0x0000E0, "Member 'UUIToggleGroupComponent::bAllowNoneSelected' has a wrong offset!");
static_assert(offsetof(UUIToggleGroupComponent, OnToggle) == 0x000100, "Member 'UUIToggleGroupComponent::OnToggle' has a wrong offset!");
static_assert(offsetof(UUIToggleGroupComponent, AllowEventBubbleUp) == 0x000118, "Member 'UUIToggleGroupComponent::AllowEventBubbleUp' has a wrong offset!");
static_assert(offsetof(UUIToggleGroupComponent, Selected) == 0x00011C, "Member 'UUIToggleGroupComponent::Selected' has a wrong offset!");
static_assert(offsetof(UUIToggleGroupComponent, Highlighted) == 0x000124, "Member 'UUIToggleGroupComponent::Highlighted' has a wrong offset!");
static_assert(offsetof(UUIToggleGroupComponent, SelectableComponents) == 0x000130, "Member 'UUIToggleGroupComponent::SelectableComponents' has a wrong offset!");

// Class LGUI.UICustomDepthStencilMaskActor
// 0x0008 (0x0398 - 0x0390)
class AUICustomDepthStencilMaskActor final : public AUIPostProcessBaseActor
{
public:
	class UUICustomDepthStencilMask*              UICustomDepthStencilMask;                          // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UICustomDepthStencilMaskActor">();
	}
	static class AUICustomDepthStencilMaskActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUICustomDepthStencilMaskActor>();
	}
};
static_assert(alignof(AUICustomDepthStencilMaskActor) == 0x000008, "Wrong alignment on AUICustomDepthStencilMaskActor");
static_assert(sizeof(AUICustomDepthStencilMaskActor) == 0x000398, "Wrong size on AUICustomDepthStencilMaskActor");
static_assert(offsetof(AUICustomDepthStencilMaskActor, UICustomDepthStencilMask) == 0x000390, "Member 'AUICustomDepthStencilMaskActor::UICustomDepthStencilMask' has a wrong offset!");

// Class LGUI.UIDraggableComponent
// 0x01F0 (0x02F0 - 0x0100)
class UUIDraggableComponent final : public ULGUIBehaviour
{
public:
	uint8                                         Pad_1221[0x28];                                    // 0x0100(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(class ULGUIPointerEventData* EventData)> OnPointerDownCallBack;                             // 0x0128(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(class ULGUIPointerEventData* EventData)> OnPointerUpCallBack;                               // 0x0150(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(class ULGUIPointerEventData* EventData)> OnPointerCancelCallBack;                           // 0x0178(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(class ULGUIPointerEventData* EventData)> OnPointerBeginDragCallBack;                        // 0x01A0(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(class ULGUIPointerEventData* EventData)> OnPointerDragCallBack;                             // 0x01C8(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(class ULGUIPointerEventData* EventData)> OnPointerEndDragCallBack;                          // 0x01F0(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(class ULGUIPointerEventData* EventData)> OnPointerScrollCallBack;                           // 0x0218(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(bool PositionChanged, bool SizeChanged)> OnUIDimensionsChangedCallBack;                     // 0x0240(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(class ULGUIBaseEventData* EventData)> NeedInterruptDelegate;                             // 0x0268(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	bool                                          bNeedInterrupt;                                    // 0x0290(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1222[0xF];                                     // 0x0291(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             NavigateToPrevDelegate;                            // 0x02A0(0x0028)(Edit, ZeroConstructor, InstancedReference, Protected, NativeAccessSpecifierProtected)
	TDelegate<void()>                             NavigateToNextDelegate;                            // 0x02C8(0x0028)(Edit, ZeroConstructor, InstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void NotifyNavigateToNext();
	void NotifyNavigateToPrev();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDraggableComponent">();
	}
	static class UUIDraggableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDraggableComponent>();
	}
};
static_assert(alignof(UUIDraggableComponent) == 0x000008, "Wrong alignment on UUIDraggableComponent");
static_assert(sizeof(UUIDraggableComponent) == 0x0002F0, "Wrong size on UUIDraggableComponent");
static_assert(offsetof(UUIDraggableComponent, OnPointerDownCallBack) == 0x000128, "Member 'UUIDraggableComponent::OnPointerDownCallBack' has a wrong offset!");
static_assert(offsetof(UUIDraggableComponent, OnPointerUpCallBack) == 0x000150, "Member 'UUIDraggableComponent::OnPointerUpCallBack' has a wrong offset!");
static_assert(offsetof(UUIDraggableComponent, OnPointerCancelCallBack) == 0x000178, "Member 'UUIDraggableComponent::OnPointerCancelCallBack' has a wrong offset!");
static_assert(offsetof(UUIDraggableComponent, OnPointerBeginDragCallBack) == 0x0001A0, "Member 'UUIDraggableComponent::OnPointerBeginDragCallBack' has a wrong offset!");
static_assert(offsetof(UUIDraggableComponent, OnPointerDragCallBack) == 0x0001C8, "Member 'UUIDraggableComponent::OnPointerDragCallBack' has a wrong offset!");
static_assert(offsetof(UUIDraggableComponent, OnPointerEndDragCallBack) == 0x0001F0, "Member 'UUIDraggableComponent::OnPointerEndDragCallBack' has a wrong offset!");
static_assert(offsetof(UUIDraggableComponent, OnPointerScrollCallBack) == 0x000218, "Member 'UUIDraggableComponent::OnPointerScrollCallBack' has a wrong offset!");
static_assert(offsetof(UUIDraggableComponent, OnUIDimensionsChangedCallBack) == 0x000240, "Member 'UUIDraggableComponent::OnUIDimensionsChangedCallBack' has a wrong offset!");
static_assert(offsetof(UUIDraggableComponent, NeedInterruptDelegate) == 0x000268, "Member 'UUIDraggableComponent::NeedInterruptDelegate' has a wrong offset!");
static_assert(offsetof(UUIDraggableComponent, bNeedInterrupt) == 0x000290, "Member 'UUIDraggableComponent::bNeedInterrupt' has a wrong offset!");
static_assert(offsetof(UUIDraggableComponent, NavigateToPrevDelegate) == 0x0002A0, "Member 'UUIDraggableComponent::NavigateToPrevDelegate' has a wrong offset!");
static_assert(offsetof(UUIDraggableComponent, NavigateToNextDelegate) == 0x0002C8, "Member 'UUIDraggableComponent::NavigateToNextDelegate' has a wrong offset!");

// Class LGUI.UIDrawcallMesh
// 0x0010 (0x0570 - 0x0560)
class UUIDrawcallMesh final : public ULGUIMeshComponent
{
public:
	uint8                                         Pad_1223[0x10];                                    // 0x0560(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDrawcallMesh">();
	}
	static class UUIDrawcallMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDrawcallMesh>();
	}
};
static_assert(alignof(UUIDrawcallMesh) == 0x000010, "Wrong alignment on UUIDrawcallMesh");
static_assert(sizeof(UUIDrawcallMesh) == 0x000570, "Wrong size on UUIDrawcallMesh");

// Class LGUI.UIDropdownComponent
// 0x0108 (0x04D8 - 0x03D0)
class UUIDropdownComponent final : public UUISelectableComponent
{
public:
	TWeakObjectPtr<class AUIBaseActor>            ListRoot;                                          // 0x03D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AUITextActor>            CaptionText;                                       // 0x03D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AUITextActor>            SecondCaptionText;                                 // 0x03E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AUISpriteActor>          CaptionSprite;                                     // 0x03E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLGUIComponentReference                ItemTemplate;                                      // 0x03F0(0x0028)(Edit, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	EUIDropdownVerticalPosition                   VerticalPosition;                                  // 0x0418(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          VerticalOverlap;                                   // 0x0419(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUIDropdownHorizontalPosition                 HorizontalPosition;                                // 0x041A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1224[0x1];                                     // 0x041B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Value;                                             // 0x041C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FUIDropdownOptionData>          Options;                                           // 0x0420(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1225[0x18];                                    // 0x0430(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class UUIDropdownItemComponent>> CreatedItemArray;                                  // 0x0448(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_1226[0x18];                                    // 0x0458(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUIDrawableEvent                     OnSelectionChange;                                 // 0x0470(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	TDelegate<void(int32 InSelectIndex)>          OnSelectChange;                                    // 0x0488(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(bool IsShow)>                  OnPanelActiveChange;                               // 0x04B0(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)

public:
	void AddOptions(const TArray<struct FUIDropdownOptionData>& InOptions);
	void Hide();
	void MarkRecreateList();
	struct FLGUIDelegateHandleWrapper RegisterSelectionChangeEvent(const TDelegate<void(int32 InSelectIndex)>& InDelegate);
	void SetHorizontalPosition(EUIDropdownHorizontalPosition InValue);
	void SetMaxHeight(float NewValue);
	void SetOptions(const TArray<struct FUIDropdownOptionData>& InOptions);
	void SetValue(int32 NewValue, bool FireEvent);
	void SetVerticalOverlap(bool NewValue);
	void SetVerticalPosition(EUIDropdownVerticalPosition InValue);
	void Show();
	void UnbindAllToggleDelegate();
	void UnregisterSelectionChangeEvent(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);

	struct FUIDropdownOptionData GetCurrentOption() const;
	EUIDropdownHorizontalPosition GetHorizontalPosition() const;
	float GetMaxHeight() const;
	struct FUIDropdownOptionData GetOption(int32 Param_Index) const;
	const TArray<struct FUIDropdownOptionData> GetOptions() const;
	int32 GetValue() const;
	bool GetVerticalOverlap() const;
	EUIDropdownVerticalPosition GetVerticalPosition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDropdownComponent">();
	}
	static class UUIDropdownComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDropdownComponent>();
	}
};
static_assert(alignof(UUIDropdownComponent) == 0x000008, "Wrong alignment on UUIDropdownComponent");
static_assert(sizeof(UUIDropdownComponent) == 0x0004D8, "Wrong size on UUIDropdownComponent");
static_assert(offsetof(UUIDropdownComponent, ListRoot) == 0x0003D0, "Member 'UUIDropdownComponent::ListRoot' has a wrong offset!");
static_assert(offsetof(UUIDropdownComponent, CaptionText) == 0x0003D8, "Member 'UUIDropdownComponent::CaptionText' has a wrong offset!");
static_assert(offsetof(UUIDropdownComponent, SecondCaptionText) == 0x0003E0, "Member 'UUIDropdownComponent::SecondCaptionText' has a wrong offset!");
static_assert(offsetof(UUIDropdownComponent, CaptionSprite) == 0x0003E8, "Member 'UUIDropdownComponent::CaptionSprite' has a wrong offset!");
static_assert(offsetof(UUIDropdownComponent, ItemTemplate) == 0x0003F0, "Member 'UUIDropdownComponent::ItemTemplate' has a wrong offset!");
static_assert(offsetof(UUIDropdownComponent, VerticalPosition) == 0x000418, "Member 'UUIDropdownComponent::VerticalPosition' has a wrong offset!");
static_assert(offsetof(UUIDropdownComponent, VerticalOverlap) == 0x000419, "Member 'UUIDropdownComponent::VerticalOverlap' has a wrong offset!");
static_assert(offsetof(UUIDropdownComponent, HorizontalPosition) == 0x00041A, "Member 'UUIDropdownComponent::HorizontalPosition' has a wrong offset!");
static_assert(offsetof(UUIDropdownComponent, Value) == 0x00041C, "Member 'UUIDropdownComponent::Value' has a wrong offset!");
static_assert(offsetof(UUIDropdownComponent, Options) == 0x000420, "Member 'UUIDropdownComponent::Options' has a wrong offset!");
static_assert(offsetof(UUIDropdownComponent, CreatedItemArray) == 0x000448, "Member 'UUIDropdownComponent::CreatedItemArray' has a wrong offset!");
static_assert(offsetof(UUIDropdownComponent, OnSelectionChange) == 0x000470, "Member 'UUIDropdownComponent::OnSelectionChange' has a wrong offset!");
static_assert(offsetof(UUIDropdownComponent, OnSelectChange) == 0x000488, "Member 'UUIDropdownComponent::OnSelectChange' has a wrong offset!");
static_assert(offsetof(UUIDropdownComponent, OnPanelActiveChange) == 0x0004B0, "Member 'UUIDropdownComponent::OnPanelActiveChange' has a wrong offset!");

// Class LGUI.UIDropdownItemComponent
// 0x0050 (0x0110 - 0x00C0)
class UUIDropdownItemComponent final : public UActorComponent
{
public:
	uint8                                         Pad_1229[0x8];                                     // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AUITextActor>            TextActor;                                         // 0x00C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AUITextActor>            SecondTextActor;                                   // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AUISpriteActor>          SpriteActor;                                       // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLGUIComponentReference                Toggle;                                            // 0x00E0(0x0028)(Edit, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_122A[0x8];                                     // 0x0108(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDropdownItemComponent">();
	}
	static class UUIDropdownItemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDropdownItemComponent>();
	}
};
static_assert(alignof(UUIDropdownItemComponent) == 0x000008, "Wrong alignment on UUIDropdownItemComponent");
static_assert(sizeof(UUIDropdownItemComponent) == 0x000110, "Wrong size on UUIDropdownItemComponent");
static_assert(offsetof(UUIDropdownItemComponent, TextActor) == 0x0000C8, "Member 'UUIDropdownItemComponent::TextActor' has a wrong offset!");
static_assert(offsetof(UUIDropdownItemComponent, SecondTextActor) == 0x0000D0, "Member 'UUIDropdownItemComponent::SecondTextActor' has a wrong offset!");
static_assert(offsetof(UUIDropdownItemComponent, SpriteActor) == 0x0000D8, "Member 'UUIDropdownItemComponent::SpriteActor' has a wrong offset!");
static_assert(offsetof(UUIDropdownItemComponent, Toggle) == 0x0000E0, "Member 'UUIDropdownItemComponent::Toggle' has a wrong offset!");

// Class LGUI.UIDynmaicTextureAtlasMgr
// 0x0150 (0x0180 - 0x0030)
class UUIDynmaicTextureAtlasMgr final : public UObject
{
public:
	TMap<struct FSoftObjectPath, struct FRenderableCollection> PathRenderableMap;                                 // 0x0030(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<struct FSoftObjectPath, struct FRenderableCollection> FailInsertRenderableMap;                           // 0x0080(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<int32, struct FLoadingPathRenderableMap> BatchLoadingPathRenderableMap;                     // 0x00D0(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_122B[0x60];                                    // 0x0120(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDynamicAtlasExpandCallback(const struct FTextureExpandParam& TextureExpandParam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDynmaicTextureAtlasMgr">();
	}
	static class UUIDynmaicTextureAtlasMgr* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDynmaicTextureAtlasMgr>();
	}
};
static_assert(alignof(UUIDynmaicTextureAtlasMgr) == 0x000008, "Wrong alignment on UUIDynmaicTextureAtlasMgr");
static_assert(sizeof(UUIDynmaicTextureAtlasMgr) == 0x000180, "Wrong size on UUIDynmaicTextureAtlasMgr");
static_assert(offsetof(UUIDynmaicTextureAtlasMgr, PathRenderableMap) == 0x000030, "Member 'UUIDynmaicTextureAtlasMgr::PathRenderableMap' has a wrong offset!");
static_assert(offsetof(UUIDynmaicTextureAtlasMgr, FailInsertRenderableMap) == 0x000080, "Member 'UUIDynmaicTextureAtlasMgr::FailInsertRenderableMap' has a wrong offset!");
static_assert(offsetof(UUIDynmaicTextureAtlasMgr, BatchLoadingPathRenderableMap) == 0x0000D0, "Member 'UUIDynmaicTextureAtlasMgr::BatchLoadingPathRenderableMap' has a wrong offset!");

// Class LGUI.UIScrollViewComponent
// 0x00E0 (0x01E0 - 0x0100)
class UUIScrollViewComponent : public ULGUIBehaviour
{
public:
	uint8                                         Pad_122C[0x20];                                    // 0x0100(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AUIBaseActor>            Content;                                           // 0x0120(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Horizontal;                                        // 0x0128(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Vertical;                                          // 0x0129(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_122D[0x2];                                     // 0x012A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScrollSensitivity;                                 // 0x012C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          AllowEventBubbleUp;                                // 0x0130(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_122E[0x3];                                     // 0x0131(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DecelerationRate;                                  // 0x0134(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Elasticity;                                        // 0x0138(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScrollOutOfRangeModulus;                           // 0x013C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUnderSizeScrollEnabled;                           // 0x0140(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CanScroll;                                         // 0x0141(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          RayCastTargetForScrollView;                        // 0x0142(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_122F[0x1];                                     // 0x0143(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UUIItem>                 ContentUIItem;                                     // 0x0144(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UUIItem>                 ContentParentUIItem;                               // 0x014C(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1230[0x64];                                    // 0x0154(0x0064)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(const struct FVector2D& InVector2)> OnScrollValueChange;                               // 0x01B8(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)

public:
	static float GetDecelerationRateDegbug();
	static float GetElasticityDegbug();
	static float GetScrollOutOfRangeModulusDebug();
	static float GetScrollSensitivityDebug();
	static bool GetScrollUseDebug();
	static void SetDecelerationRateDebug(float Value);
	static void SetElasticityDebug(float Value);
	static void SetScrollOutOfRangeModulusDebug(float Value);
	static void SetScrollSensitivityDebug(float Value);
	static void SetScrollUseDebug(bool Value);

	void SetCanScroll(bool bCanScroll);
	void SetHorizontal(bool Value);
	void SetRayCastTargetForScrollView(bool NewRayCastTarget);
	void SetScrollProgress(float Value);
	void SetScrollProgressIncrement(float Value);
	void SetScrollValue(const struct FVector2D& Value);
	void SetUnderSizeScrollEnabled(bool bEnabled);
	void SetVelocity(float Value);
	void SetVertical(bool Value);
	void StopMovement();

	bool GetCanScroll() const;
	class AUIBaseActor* GetContent() const;
	bool GetHorizontal() const;
	bool GetRayCastTargetForScrollView() const;
	bool GetUnderSizeScrollEnabled() const;
	bool GetVertical() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIScrollViewComponent">();
	}
	static class UUIScrollViewComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIScrollViewComponent>();
	}
};
static_assert(alignof(UUIScrollViewComponent) == 0x000008, "Wrong alignment on UUIScrollViewComponent");
static_assert(sizeof(UUIScrollViewComponent) == 0x0001E0, "Wrong size on UUIScrollViewComponent");
static_assert(offsetof(UUIScrollViewComponent, Content) == 0x000120, "Member 'UUIScrollViewComponent::Content' has a wrong offset!");
static_assert(offsetof(UUIScrollViewComponent, Horizontal) == 0x000128, "Member 'UUIScrollViewComponent::Horizontal' has a wrong offset!");
static_assert(offsetof(UUIScrollViewComponent, Vertical) == 0x000129, "Member 'UUIScrollViewComponent::Vertical' has a wrong offset!");
static_assert(offsetof(UUIScrollViewComponent, ScrollSensitivity) == 0x00012C, "Member 'UUIScrollViewComponent::ScrollSensitivity' has a wrong offset!");
static_assert(offsetof(UUIScrollViewComponent, AllowEventBubbleUp) == 0x000130, "Member 'UUIScrollViewComponent::AllowEventBubbleUp' has a wrong offset!");
static_assert(offsetof(UUIScrollViewComponent, DecelerationRate) == 0x000134, "Member 'UUIScrollViewComponent::DecelerationRate' has a wrong offset!");
static_assert(offsetof(UUIScrollViewComponent, Elasticity) == 0x000138, "Member 'UUIScrollViewComponent::Elasticity' has a wrong offset!");
static_assert(offsetof(UUIScrollViewComponent, ScrollOutOfRangeModulus) == 0x00013C, "Member 'UUIScrollViewComponent::ScrollOutOfRangeModulus' has a wrong offset!");
static_assert(offsetof(UUIScrollViewComponent, bUnderSizeScrollEnabled) == 0x000140, "Member 'UUIScrollViewComponent::bUnderSizeScrollEnabled' has a wrong offset!");
static_assert(offsetof(UUIScrollViewComponent, CanScroll) == 0x000141, "Member 'UUIScrollViewComponent::CanScroll' has a wrong offset!");
static_assert(offsetof(UUIScrollViewComponent, RayCastTargetForScrollView) == 0x000142, "Member 'UUIScrollViewComponent::RayCastTargetForScrollView' has a wrong offset!");
static_assert(offsetof(UUIScrollViewComponent, ContentUIItem) == 0x000144, "Member 'UUIScrollViewComponent::ContentUIItem' has a wrong offset!");
static_assert(offsetof(UUIScrollViewComponent, ContentParentUIItem) == 0x00014C, "Member 'UUIScrollViewComponent::ContentParentUIItem' has a wrong offset!");
static_assert(offsetof(UUIScrollViewComponent, OnScrollValueChange) == 0x0001B8, "Member 'UUIScrollViewComponent::OnScrollValueChange' has a wrong offset!");

// Class LGUI.UIScrollViewWithScrollbarComponent
// 0x0038 (0x0218 - 0x01E0)
class UUIScrollViewWithScrollbarComponent : public UUIScrollViewComponent
{
public:
	TWeakObjectPtr<class AUIBaseActor>            Viewport;                                          // 0x01E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AUIBaseActor>            HorizontalScrollbar;                               // 0x01E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EScrollViewScrollbarVisibility                HorizontalScrollbarVisibility;                     // 0x01F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1231[0x3];                                     // 0x01F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AUIBaseActor>            VerticalScrollbar;                                 // 0x01F4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EScrollViewScrollbarVisibility                VerticalScrollbarVisibility;                       // 0x01FC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1232[0x3];                                     // 0x01FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UUIScrollbarComponent>   HorizontalScrollbarComp;                           // 0x0200(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UUIScrollbarComponent>   VerticalScrollbarComp;                             // 0x0208(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1233[0x2];                                     // 0x0210(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsChangeNavigation;                                // 0x0212(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1234[0x5];                                     // 0x0213(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindParentUIItem(class UUISelectableComponent* Component);
	class UUISelectableComponent* FindNavigationComponent(class UUISelectableComponent* Component, const struct FVector& Direction, EUINavigationWrapMode Mode, bool bHasOtherNode);
	void GetOutOfBottomBoundsType(class UUIItem* UIItem, EOutOfBoundsType* OutOfTopOrBottomType, EOutOfBoundsType* OutOfLeftOrRightType, float ErrorTolerance);
	void ResetIsChangeNavigation();
	void ScrollTo(class UUIItem* UIItem);
	void ScrollToBottom(struct FVector2D* NewPosition, class UUIItem* UIItem);
	void ScrollToLeft(struct FVector2D* NewPosition, class UUIItem* UIItem);
	void ScrollToRight(struct FVector2D* NewPosition, class UUIItem* UIItem);
	void ScrollToSelectableComponent(class UUISelectableComponent* Component);
	void ScrollToTop(struct FVector2D* NewPosition, class UUIItem* UIItem);
	void SetHorizontalScrollbarVisibility(EScrollViewScrollbarVisibility Value);
	void SetVerticalScrollbarVisibility(EScrollViewScrollbarVisibility Value);
	void UnBindParentUIItem(class UUISelectableComponent* Component);

	class AUIBaseActor* GetHorizontalScrollbar() const;
	EScrollViewScrollbarVisibility GetHorizontalScrollbarVisibility() const;
	class AUIBaseActor* GetVerticalScrollbar() const;
	EScrollViewScrollbarVisibility GetVerticalScrollbarVisibility() const;
	class AUIBaseActor* GetViewport() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIScrollViewWithScrollbarComponent">();
	}
	static class UUIScrollViewWithScrollbarComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIScrollViewWithScrollbarComponent>();
	}
};
static_assert(alignof(UUIScrollViewWithScrollbarComponent) == 0x000008, "Wrong alignment on UUIScrollViewWithScrollbarComponent");
static_assert(sizeof(UUIScrollViewWithScrollbarComponent) == 0x000218, "Wrong size on UUIScrollViewWithScrollbarComponent");
static_assert(offsetof(UUIScrollViewWithScrollbarComponent, Viewport) == 0x0001E0, "Member 'UUIScrollViewWithScrollbarComponent::Viewport' has a wrong offset!");
static_assert(offsetof(UUIScrollViewWithScrollbarComponent, HorizontalScrollbar) == 0x0001E8, "Member 'UUIScrollViewWithScrollbarComponent::HorizontalScrollbar' has a wrong offset!");
static_assert(offsetof(UUIScrollViewWithScrollbarComponent, HorizontalScrollbarVisibility) == 0x0001F0, "Member 'UUIScrollViewWithScrollbarComponent::HorizontalScrollbarVisibility' has a wrong offset!");
static_assert(offsetof(UUIScrollViewWithScrollbarComponent, VerticalScrollbar) == 0x0001F4, "Member 'UUIScrollViewWithScrollbarComponent::VerticalScrollbar' has a wrong offset!");
static_assert(offsetof(UUIScrollViewWithScrollbarComponent, VerticalScrollbarVisibility) == 0x0001FC, "Member 'UUIScrollViewWithScrollbarComponent::VerticalScrollbarVisibility' has a wrong offset!");
static_assert(offsetof(UUIScrollViewWithScrollbarComponent, HorizontalScrollbarComp) == 0x000200, "Member 'UUIScrollViewWithScrollbarComponent::HorizontalScrollbarComp' has a wrong offset!");
static_assert(offsetof(UUIScrollViewWithScrollbarComponent, VerticalScrollbarComp) == 0x000208, "Member 'UUIScrollViewWithScrollbarComponent::VerticalScrollbarComp' has a wrong offset!");
static_assert(offsetof(UUIScrollViewWithScrollbarComponent, IsChangeNavigation) == 0x000212, "Member 'UUIScrollViewWithScrollbarComponent::IsChangeNavigation' has a wrong offset!");

// Class LGUI.UIDynScrollViewComponent
// 0x0218 (0x0430 - 0x0218)
class UUIDynScrollViewComponent final : public UUIScrollViewWithScrollbarComponent
{
public:
	uint8                                         Pad_1237[0x10];                                    // 0x0218(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AUIBaseActor>            TemplateItem;                                      // 0x0228(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         TotalItemNum;                                      // 0x0230(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          ItemDefaultUIActive;                               // 0x0234(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1238[0x3];                                     // 0x0235(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpacingHorizontal;                                 // 0x0238(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpacingVertical;                                   // 0x023C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PaddingHorizontal;                                 // 0x0240(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PaddingVertical;                                   // 0x0244(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GridAnimationStartTime;                            // 0x0248(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GridAnimationInterval;                             // 0x024C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInAnimation;                                     // 0x0250(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SizeMatchContent;                                  // 0x0251(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1239[0x6];                                     // 0x0252(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(int32 DisplayIndex, class AUIBaseActor* Actor)> OnItemCreate;                                      // 0x0258(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(int32 Index, class AUIBaseActor* Actor)> OnItemUpdate;                                      // 0x0280(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(int32 Index)>                  ItemSizeDelegate;                                  // 0x02A8(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(int32 Index, class AUIBaseActor* Actor)> OnItemClear;                                       // 0x02D0(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnDestroyCallBack;                                 // 0x02F8(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_123A[0x10];                                    // 0x0320(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AUIBaseActor>>    DisplayItemArray;                                  // 0x0330(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class AUIBaseActor>>    IdleItemArray;                                     // 0x0340(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<class AUIBaseActor*, class AUIBaseActor*> ToUsingItemMap;                                    // 0x0350(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_123B[0x90];                                    // 0x03A0(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetItemPositionToContent(class UUIItem* TargetItem);
	struct FVector GetItemPositionToViewport(class UUIItem* TargetItem);
	class AUIBaseActor* GetRealUsingItem(int32 ItemIndex);
	void NavigateScrollToUIItem(class UUIItem* UIItem, bool bReversed, EUINavigationWrapMode Mode);
	void Refresh();
	void RefreshByData(class AUIBaseActor* Item, int32 ItemNum, bool KeepContentPosition);
	void ScrollItemIndex(bool bReversed);
	void ScrollToEndItemIndex(bool bScrollToTop, float Offset);
	void ScrollToItemIndex(int32 ItemIndex, bool bScrollToTop, float Offset);
	void ScrollToLastItem();
	void ScrollToNextLine(bool bReversed);
	void ScrollToOffset(float Offset);
	void ScrollToStartItemIndex(bool bScrollToTop, float Offset);
	void ScrollToUIItem(class UUIItem* UIItem, bool bScrollToTop);
	void SetGridAnimationInterval(float Value);
	void SetGridAnimationStartTime(float Value);
	void SetInAnimation(bool State);

	float GetGridAnimationInterval() const;
	float GetGridAnimationStartTime() const;
	bool GetInAnimation() const;
	class AUIBaseActor* GetItem(int32 ItemIndex) const;
	bool GetItemDisplayIndex(int32 ItemIndex, int32* DisplayIndex) const;
	bool GetItemIndex(int32 DisplayIndex, int32* ItemIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDynScrollViewComponent">();
	}
	static class UUIDynScrollViewComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDynScrollViewComponent>();
	}
};
static_assert(alignof(UUIDynScrollViewComponent) == 0x000008, "Wrong alignment on UUIDynScrollViewComponent");
static_assert(sizeof(UUIDynScrollViewComponent) == 0x000430, "Wrong size on UUIDynScrollViewComponent");
static_assert(offsetof(UUIDynScrollViewComponent, TemplateItem) == 0x000228, "Member 'UUIDynScrollViewComponent::TemplateItem' has a wrong offset!");
static_assert(offsetof(UUIDynScrollViewComponent, TotalItemNum) == 0x000230, "Member 'UUIDynScrollViewComponent::TotalItemNum' has a wrong offset!");
static_assert(offsetof(UUIDynScrollViewComponent, ItemDefaultUIActive) == 0x000234, "Member 'UUIDynScrollViewComponent::ItemDefaultUIActive' has a wrong offset!");
static_assert(offsetof(UUIDynScrollViewComponent, SpacingHorizontal) == 0x000238, "Member 'UUIDynScrollViewComponent::SpacingHorizontal' has a wrong offset!");
static_assert(offsetof(UUIDynScrollViewComponent, SpacingVertical) == 0x00023C, "Member 'UUIDynScrollViewComponent::SpacingVertical' has a wrong offset!");
static_assert(offsetof(UUIDynScrollViewComponent, PaddingHorizontal) == 0x000240, "Member 'UUIDynScrollViewComponent::PaddingHorizontal' has a wrong offset!");
static_assert(offsetof(UUIDynScrollViewComponent, PaddingVertical) == 0x000244, "Member 'UUIDynScrollViewComponent::PaddingVertical' has a wrong offset!");
static_assert(offsetof(UUIDynScrollViewComponent, GridAnimationStartTime) == 0x000248, "Member 'UUIDynScrollViewComponent::GridAnimationStartTime' has a wrong offset!");
static_assert(offsetof(UUIDynScrollViewComponent, GridAnimationInterval) == 0x00024C, "Member 'UUIDynScrollViewComponent::GridAnimationInterval' has a wrong offset!");
static_assert(offsetof(UUIDynScrollViewComponent, IsInAnimation) == 0x000250, "Member 'UUIDynScrollViewComponent::IsInAnimation' has a wrong offset!");
static_assert(offsetof(UUIDynScrollViewComponent, SizeMatchContent) == 0x000251, "Member 'UUIDynScrollViewComponent::SizeMatchContent' has a wrong offset!");
static_assert(offsetof(UUIDynScrollViewComponent, OnItemCreate) == 0x000258, "Member 'UUIDynScrollViewComponent::OnItemCreate' has a wrong offset!");
static_assert(offsetof(UUIDynScrollViewComponent, OnItemUpdate) == 0x000280, "Member 'UUIDynScrollViewComponent::OnItemUpdate' has a wrong offset!");
static_assert(offsetof(UUIDynScrollViewComponent, ItemSizeDelegate) == 0x0002A8, "Member 'UUIDynScrollViewComponent::ItemSizeDelegate' has a wrong offset!");
static_assert(offsetof(UUIDynScrollViewComponent, OnItemClear) == 0x0002D0, "Member 'UUIDynScrollViewComponent::OnItemClear' has a wrong offset!");
static_assert(offsetof(UUIDynScrollViewComponent, OnDestroyCallBack) == 0x0002F8, "Member 'UUIDynScrollViewComponent::OnDestroyCallBack' has a wrong offset!");
static_assert(offsetof(UUIDynScrollViewComponent, DisplayItemArray) == 0x000330, "Member 'UUIDynScrollViewComponent::DisplayItemArray' has a wrong offset!");
static_assert(offsetof(UUIDynScrollViewComponent, IdleItemArray) == 0x000340, "Member 'UUIDynScrollViewComponent::IdleItemArray' has a wrong offset!");
static_assert(offsetof(UUIDynScrollViewComponent, ToUsingItemMap) == 0x000350, "Member 'UUIDynScrollViewComponent::ToUsingItemMap' has a wrong offset!");

// Class LGUI.UIPolygon
// 0x0020 (0x0790 - 0x0770)
class UUIPolygon final : public UUISpriteBase
{
public:
	bool                                          FullCycle;                                         // 0x0768(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1248[0x3];                                     // 0x0769(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartAngle;                                        // 0x076C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndAngle;                                          // 0x0770(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Sides;                                             // 0x0774(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUIPolygonUVType                              UVType;                                            // 0x0778(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1249[0x7];                                     // 0x0779(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 VertexOffsetArray;                                 // 0x0780(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	class ULTweener* EndAngleTo(float EndValue, float Duration, float Delay, ELTweenEase EaseType);
	void SetEndAngle(float Value);
	void SetSides(int32 Value);
	void SetStartAngle(float Value);
	void SetUVType(EUIPolygonUVType Value);
	void SetVertexOffsetArray(const TArray<float>& Value);
	class ULTweener* StartAngleTo(float EndValue, float Duration, float Delay, ELTweenEase EaseType);

	float GetEndAngle() const;
	int32 GetSides() const;
	float GetStartAngle() const;
	EUIPolygonUVType GetUVType() const;
	const TArray<float> GetVertexOffsetArray() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPolygon">();
	}
	static class UUIPolygon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPolygon>();
	}
};
static_assert(alignof(UUIPolygon) == 0x000010, "Wrong alignment on UUIPolygon");
static_assert(sizeof(UUIPolygon) == 0x000790, "Wrong size on UUIPolygon");
static_assert(offsetof(UUIPolygon, FullCycle) == 0x000768, "Member 'UUIPolygon::FullCycle' has a wrong offset!");
static_assert(offsetof(UUIPolygon, StartAngle) == 0x00076C, "Member 'UUIPolygon::StartAngle' has a wrong offset!");
static_assert(offsetof(UUIPolygon, EndAngle) == 0x000770, "Member 'UUIPolygon::EndAngle' has a wrong offset!");
static_assert(offsetof(UUIPolygon, Sides) == 0x000774, "Member 'UUIPolygon::Sides' has a wrong offset!");
static_assert(offsetof(UUIPolygon, UVType) == 0x000778, "Member 'UUIPolygon::UVType' has a wrong offset!");
static_assert(offsetof(UUIPolygon, VertexOffsetArray) == 0x000780, "Member 'UUIPolygon::VertexOffsetArray' has a wrong offset!");

// Class LGUI.UIGeometryModifierBase
// 0x0018 (0x00D8 - 0x00C0)
class UUIGeometryModifierBase : public UActorComponent
{
public:
	int32                                         ExecuteOrder;                                      // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ComponentName;                                     // 0x00C4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_124C[0x8];                                     // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGeometryModifierBase">();
	}
	static class UUIGeometryModifierBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGeometryModifierBase>();
	}
};
static_assert(alignof(UUIGeometryModifierBase) == 0x000008, "Wrong alignment on UUIGeometryModifierBase");
static_assert(sizeof(UUIGeometryModifierBase) == 0x0000D8, "Wrong size on UUIGeometryModifierBase");
static_assert(offsetof(UUIGeometryModifierBase, ExecuteOrder) == 0x0000C0, "Member 'UUIGeometryModifierBase::ExecuteOrder' has a wrong offset!");
static_assert(offsetof(UUIGeometryModifierBase, ComponentName) == 0x0000C4, "Member 'UUIGeometryModifierBase::ComponentName' has a wrong offset!");

// Class LGUI.UIEffectGradientColor
// 0x0018 (0x00F0 - 0x00D8)
class UUIEffectGradientColor final : public UUIGeometryModifierBase
{
public:
	EUIEffectGradientColorDirection               DirectionType;                                     // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MultiplySourceAlpha;                               // 0x00D9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_124D[0x2];                                     // 0x00DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 Color1;                                            // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 Color2;                                            // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 Color3;                                            // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 Color4;                                            // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_124E[0x4];                                     // 0x00EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectGradientColor">();
	}
	static class UUIEffectGradientColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectGradientColor>();
	}
};
static_assert(alignof(UUIEffectGradientColor) == 0x000008, "Wrong alignment on UUIEffectGradientColor");
static_assert(sizeof(UUIEffectGradientColor) == 0x0000F0, "Wrong size on UUIEffectGradientColor");
static_assert(offsetof(UUIEffectGradientColor, DirectionType) == 0x0000D8, "Member 'UUIEffectGradientColor::DirectionType' has a wrong offset!");
static_assert(offsetof(UUIEffectGradientColor, MultiplySourceAlpha) == 0x0000D9, "Member 'UUIEffectGradientColor::MultiplySourceAlpha' has a wrong offset!");
static_assert(offsetof(UUIEffectGradientColor, Color1) == 0x0000DC, "Member 'UUIEffectGradientColor::Color1' has a wrong offset!");
static_assert(offsetof(UUIEffectGradientColor, Color2) == 0x0000E0, "Member 'UUIEffectGradientColor::Color2' has a wrong offset!");
static_assert(offsetof(UUIEffectGradientColor, Color3) == 0x0000E4, "Member 'UUIEffectGradientColor::Color3' has a wrong offset!");
static_assert(offsetof(UUIEffectGradientColor, Color4) == 0x0000E8, "Member 'UUIEffectGradientColor::Color4' has a wrong offset!");

// Class LGUI.UIEffectLongShadow
// 0x0020 (0x00F8 - 0x00D8)
class UUIEffectLongShadow final : public UUIGeometryModifierBase
{
public:
	struct FColor                                 ShadowColor;                                       // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ShadowSize;                                        // 0x00DC(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         ShadowSegment;                                     // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UseGradientColor;                                  // 0x00E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_124F[0x2];                                     // 0x00EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 GradientColor;                                     // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MultiplySourceAlpha;                               // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1250[0x7];                                     // 0x00F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetGradientColor(const struct FColor& NewColor);
	void SetShadowColor(const struct FColor& NewColor);
	void SetShadowSegment(uint8 NewSegment);
	void SetShadowSize(const struct FVector& NewSize);
	void SetUseGradientColor(bool NewBool);

	struct FColor GetGradientColor() const;
	struct FColor GetShadowColor() const;
	uint8 GetShadowSegments() const;
	struct FVector GetShadowSize() const;
	bool GetUseGradientColor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectLongShadow">();
	}
	static class UUIEffectLongShadow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectLongShadow>();
	}
};
static_assert(alignof(UUIEffectLongShadow) == 0x000008, "Wrong alignment on UUIEffectLongShadow");
static_assert(sizeof(UUIEffectLongShadow) == 0x0000F8, "Wrong size on UUIEffectLongShadow");
static_assert(offsetof(UUIEffectLongShadow, ShadowColor) == 0x0000D8, "Member 'UUIEffectLongShadow::ShadowColor' has a wrong offset!");
static_assert(offsetof(UUIEffectLongShadow, ShadowSize) == 0x0000DC, "Member 'UUIEffectLongShadow::ShadowSize' has a wrong offset!");
static_assert(offsetof(UUIEffectLongShadow, ShadowSegment) == 0x0000E8, "Member 'UUIEffectLongShadow::ShadowSegment' has a wrong offset!");
static_assert(offsetof(UUIEffectLongShadow, UseGradientColor) == 0x0000E9, "Member 'UUIEffectLongShadow::UseGradientColor' has a wrong offset!");
static_assert(offsetof(UUIEffectLongShadow, GradientColor) == 0x0000EC, "Member 'UUIEffectLongShadow::GradientColor' has a wrong offset!");
static_assert(offsetof(UUIEffectLongShadow, MultiplySourceAlpha) == 0x0000F0, "Member 'UUIEffectLongShadow::MultiplySourceAlpha' has a wrong offset!");

// Class LGUI.UIEffectOutline
// 0x0010 (0x00E8 - 0x00D8)
class UUIEffectOutline final : public UUIGeometryModifierBase
{
public:
	struct FColor                                 OutlineColor;                                      // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              OutlineSize;                                       // 0x00DC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MultiplySourceAlpha;                               // 0x00E4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Use8Direction;                                     // 0x00E5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1251[0x2];                                     // 0x00E6(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetOutlineColor(const struct FColor& NewColor);
	void SetOutlineSize(const struct FVector2D& NewSize);
	void SetUse8Direction(bool NewValue);

	struct FColor GetOutlineColor() const;
	struct FVector2D GetOutlineSize() const;
	bool GetUse8Direction() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectOutline">();
	}
	static class UUIEffectOutline* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectOutline>();
	}
};
static_assert(alignof(UUIEffectOutline) == 0x000008, "Wrong alignment on UUIEffectOutline");
static_assert(sizeof(UUIEffectOutline) == 0x0000E8, "Wrong size on UUIEffectOutline");
static_assert(offsetof(UUIEffectOutline, OutlineColor) == 0x0000D8, "Member 'UUIEffectOutline::OutlineColor' has a wrong offset!");
static_assert(offsetof(UUIEffectOutline, OutlineSize) == 0x0000DC, "Member 'UUIEffectOutline::OutlineSize' has a wrong offset!");
static_assert(offsetof(UUIEffectOutline, MultiplySourceAlpha) == 0x0000E4, "Member 'UUIEffectOutline::MultiplySourceAlpha' has a wrong offset!");
static_assert(offsetof(UUIEffectOutline, Use8Direction) == 0x0000E5, "Member 'UUIEffectOutline::Use8Direction' has a wrong offset!");

// Class LGUI.UIRaycastRangeComponent
// 0x0020 (0x0120 - 0x0100)
class UUIRaycastRangeComponent final : public ULGUIBehaviour
{
public:
	float                                         PointSize;                                         // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DragDistance;                                      // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector2D>                      Points;                                            // 0x0108(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1252[0x8];                                     // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIRaycastRangeComponent">();
	}
	static class UUIRaycastRangeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIRaycastRangeComponent>();
	}
};
static_assert(alignof(UUIRaycastRangeComponent) == 0x000008, "Wrong alignment on UUIRaycastRangeComponent");
static_assert(sizeof(UUIRaycastRangeComponent) == 0x000120, "Wrong size on UUIRaycastRangeComponent");
static_assert(offsetof(UUIRaycastRangeComponent, PointSize) == 0x000100, "Member 'UUIRaycastRangeComponent::PointSize' has a wrong offset!");
static_assert(offsetof(UUIRaycastRangeComponent, DragDistance) == 0x000104, "Member 'UUIRaycastRangeComponent::DragDistance' has a wrong offset!");
static_assert(offsetof(UUIRaycastRangeComponent, Points) == 0x000108, "Member 'UUIRaycastRangeComponent::Points' has a wrong offset!");

// Class LGUI.UIEffectPositionAsUV
// 0x0008 (0x00E0 - 0x00D8)
class UUIEffectPositionAsUV final : public UUIGeometryModifierBase
{
public:
	uint8                                         UvChannel;                                         // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1253[0x7];                                     // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectPositionAsUV">();
	}
	static class UUIEffectPositionAsUV* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectPositionAsUV>();
	}
};
static_assert(alignof(UUIEffectPositionAsUV) == 0x000008, "Wrong alignment on UUIEffectPositionAsUV");
static_assert(sizeof(UUIEffectPositionAsUV) == 0x0000E0, "Wrong size on UUIEffectPositionAsUV");
static_assert(offsetof(UUIEffectPositionAsUV, UvChannel) == 0x0000D8, "Member 'UUIEffectPositionAsUV::UvChannel' has a wrong offset!");

// Class LGUI.UIEffectShadow
// 0x0010 (0x00E8 - 0x00D8)
class UUIEffectShadow final : public UUIGeometryModifierBase
{
public:
	struct FColor                                 ShadowColor;                                       // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MultiplySourceAlpha;                               // 0x00DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1254[0x3];                                     // 0x00DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ShadowOffset;                                      // 0x00E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetShadowColor(const struct FColor& NewColor);
	void SetShadowOffset(const struct FVector2D& NewOffset);

	struct FColor GetShadowColor() const;
	struct FVector2D GetShadowOffset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectShadow">();
	}
	static class UUIEffectShadow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectShadow>();
	}
};
static_assert(alignof(UUIEffectShadow) == 0x000008, "Wrong alignment on UUIEffectShadow");
static_assert(sizeof(UUIEffectShadow) == 0x0000E8, "Wrong size on UUIEffectShadow");
static_assert(offsetof(UUIEffectShadow, ShadowColor) == 0x0000D8, "Member 'UUIEffectShadow::ShadowColor' has a wrong offset!");
static_assert(offsetof(UUIEffectShadow, MultiplySourceAlpha) == 0x0000DC, "Member 'UUIEffectShadow::MultiplySourceAlpha' has a wrong offset!");
static_assert(offsetof(UUIEffectShadow, ShadowOffset) == 0x0000E0, "Member 'UUIEffectShadow::ShadowOffset' has a wrong offset!");

// Class LGUI.UINiagara
// 0x07E0 (0x0D40 - 0x0560)
class UUINiagara final : public UUIBaseRenderable
{
public:
	class UNiagaraSystem*                         NiagaraSystemReference;                            // 0x0560(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNiagaraActive;                                   // 0x0568(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1255[0x3];                                     // 0x0569(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartTime;                                         // 0x056C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoopTime;                                          // 0x0570(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndTime;                                           // 0x0574(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       NiagaraLocation;                                   // 0x0578(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       NiagaraRotation;                                   // 0x0720(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       NiagaraScale;                                      // 0x08C8(0x01A8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FString, struct FKuroCurveFloat>   FloatParameter;                                    // 0x0A70(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FString, struct FKuroCurveVector>  VectorParameter;                                   // 0x0AC0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FString, struct FKuroCurveLinearColor> ColorParameter;                                    // 0x0B10(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bAdaptPosAndSizeChanged;                           // 0x0B60(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCircleClip;                                 // 0x0B61(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1256[0x2];                                     // 0x0B62(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCircleClipParameters                  CircleClipParameters;                              // 0x0B64(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1257[0x4];                                     // 0x0B74(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULGUINiagaraComponent*                  NiagaraComponent;                                  // 0x0B78(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1258[0x1A0];                                   // 0x0B80(0x01A0)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bResetNiagara;                                     // 0x0D20(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1259[0x7];                                     // 0x0D21(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          StartEvent;                                        // 0x0D28(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanInterupt;                                      // 0x0D30(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_125A[0x3];                                     // 0x0D31(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FadeOutMs;                                         // 0x0D34(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_125B[0x8];                                     // 0x0D38(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateSystem(bool Reset);
	void DeactivateSystem();
	bool GetIsActive();
	bool IsCircleClipEnable();
	void ReinitializeSystem();
	void SetCircleClipEnable(bool Enable);
	void SetCircleClipParameters(const struct FCircleClipParameters& NewCircleClipParameters);
	void SetNiagaraEmitterCustomTexture(const class FString& InEmitterName, const class FString& InVariableName, class UTexture* InTexture);
	void SetNiagaraEmitterFloatParam(const class FString& InEmitterName, const class FString& InVariableName, float InValue);
	void SetNiagaraEmitterVectorParam(const class FString& InEmitterName, const class FString& InVariableName, const struct FVector4& InVector);
	void SetNiagaraSystem(class UNiagaraSystem* InSystem);
	void SetNiagaraUIActive(bool Active, bool bInResetNiagara);
	void SetNiagaraVarFloat(const class FString& VarName, float Value);
	void SetNiagaraVarLinearColor(const class FString& VarName, const struct FLinearColor& Value);
	void SwitchToStop();

	struct FCircleClipParameters GetCircleClipParameters() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINiagara">();
	}
	static class UUINiagara* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINiagara>();
	}
};
static_assert(alignof(UUINiagara) == 0x000010, "Wrong alignment on UUINiagara");
static_assert(sizeof(UUINiagara) == 0x000D40, "Wrong size on UUINiagara");
static_assert(offsetof(UUINiagara, NiagaraSystemReference) == 0x000560, "Member 'UUINiagara::NiagaraSystemReference' has a wrong offset!");
static_assert(offsetof(UUINiagara, IsNiagaraActive) == 0x000568, "Member 'UUINiagara::IsNiagaraActive' has a wrong offset!");
static_assert(offsetof(UUINiagara, StartTime) == 0x00056C, "Member 'UUINiagara::StartTime' has a wrong offset!");
static_assert(offsetof(UUINiagara, LoopTime) == 0x000570, "Member 'UUINiagara::LoopTime' has a wrong offset!");
static_assert(offsetof(UUINiagara, EndTime) == 0x000574, "Member 'UUINiagara::EndTime' has a wrong offset!");
static_assert(offsetof(UUINiagara, NiagaraLocation) == 0x000578, "Member 'UUINiagara::NiagaraLocation' has a wrong offset!");
static_assert(offsetof(UUINiagara, NiagaraRotation) == 0x000720, "Member 'UUINiagara::NiagaraRotation' has a wrong offset!");
static_assert(offsetof(UUINiagara, NiagaraScale) == 0x0008C8, "Member 'UUINiagara::NiagaraScale' has a wrong offset!");
static_assert(offsetof(UUINiagara, FloatParameter) == 0x000A70, "Member 'UUINiagara::FloatParameter' has a wrong offset!");
static_assert(offsetof(UUINiagara, VectorParameter) == 0x000AC0, "Member 'UUINiagara::VectorParameter' has a wrong offset!");
static_assert(offsetof(UUINiagara, ColorParameter) == 0x000B10, "Member 'UUINiagara::ColorParameter' has a wrong offset!");
static_assert(offsetof(UUINiagara, bAdaptPosAndSizeChanged) == 0x000B60, "Member 'UUINiagara::bAdaptPosAndSizeChanged' has a wrong offset!");
static_assert(offsetof(UUINiagara, bEnableCircleClip) == 0x000B61, "Member 'UUINiagara::bEnableCircleClip' has a wrong offset!");
static_assert(offsetof(UUINiagara, CircleClipParameters) == 0x000B64, "Member 'UUINiagara::CircleClipParameters' has a wrong offset!");
static_assert(offsetof(UUINiagara, NiagaraComponent) == 0x000B78, "Member 'UUINiagara::NiagaraComponent' has a wrong offset!");
static_assert(offsetof(UUINiagara, bResetNiagara) == 0x000D20, "Member 'UUINiagara::bResetNiagara' has a wrong offset!");
static_assert(offsetof(UUINiagara, StartEvent) == 0x000D28, "Member 'UUINiagara::StartEvent' has a wrong offset!");
static_assert(offsetof(UUINiagara, bCanInterupt) == 0x000D30, "Member 'UUINiagara::bCanInterupt' has a wrong offset!");
static_assert(offsetof(UUINiagara, FadeOutMs) == 0x000D34, "Member 'UUINiagara::FadeOutMs' has a wrong offset!");

// Class LGUI.UIEffectTextAnimation_Selector
// 0x0008 (0x0038 - 0x0030)
class UUIEffectTextAnimation_Selector : public UObject
{
public:
	float                                         Offset;                                            // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_125E[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetOffset(float Value);

	float GetOffset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation_Selector">();
	}
	static class UUIEffectTextAnimation_Selector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation_Selector>();
	}
};
static_assert(alignof(UUIEffectTextAnimation_Selector) == 0x000008, "Wrong alignment on UUIEffectTextAnimation_Selector");
static_assert(sizeof(UUIEffectTextAnimation_Selector) == 0x000038, "Wrong size on UUIEffectTextAnimation_Selector");
static_assert(offsetof(UUIEffectTextAnimation_Selector, Offset) == 0x000030, "Member 'UUIEffectTextAnimation_Selector::Offset' has a wrong offset!");

// Class LGUI.UIEffectTextAnimation_Property
// 0x0000 (0x0030 - 0x0030)
class UUIEffectTextAnimation_Property : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation_Property">();
	}
	static class UUIEffectTextAnimation_Property* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation_Property>();
	}
};
static_assert(alignof(UUIEffectTextAnimation_Property) == 0x000008, "Wrong alignment on UUIEffectTextAnimation_Property");
static_assert(sizeof(UUIEffectTextAnimation_Property) == 0x000030, "Wrong size on UUIEffectTextAnimation_Property");

// Class LGUI.UIEffectTextAnimation
// 0x0038 (0x0110 - 0x00D8)
class UUIEffectTextAnimation final : public UUIGeometryModifierBase
{
public:
	class UUIEffectTextAnimation_Selector*        Selector;                                          // 0x00D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIEffectTextAnimation_Property*> Properties;                                        // 0x00E0(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UUIText*                                UiText;                                            // 0x00F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_125F[0x18];                                    // 0x00F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetProperties(const TArray<class UUIEffectTextAnimation_Property*>& Value);
	void SetProperty(int32 Param_Index, class UUIEffectTextAnimation_Property* Value);
	void SetSelector(class UUIEffectTextAnimation_Selector* Value);
	void SetSelectorOffset(float Value);

	const TArray<class UUIEffectTextAnimation_Property*> GetProperties() const;
	class UUIEffectTextAnimation_Property* GetProperty(int32 Param_Index) const;
	class UUIEffectTextAnimation_Selector* GetSelector() const;
	float GetSelectorOffset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation">();
	}
	static class UUIEffectTextAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation>();
	}
};
static_assert(alignof(UUIEffectTextAnimation) == 0x000008, "Wrong alignment on UUIEffectTextAnimation");
static_assert(sizeof(UUIEffectTextAnimation) == 0x000110, "Wrong size on UUIEffectTextAnimation");
static_assert(offsetof(UUIEffectTextAnimation, Selector) == 0x0000D8, "Member 'UUIEffectTextAnimation::Selector' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation, Properties) == 0x0000E0, "Member 'UUIEffectTextAnimation::Properties' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation, UiText) == 0x0000F0, "Member 'UUIEffectTextAnimation::UiText' has a wrong offset!");

// Class LGUI.UIEffectTextAnimation_PropertyWithEase
// 0x0020 (0x0050 - 0x0030)
class UUIEffectTextAnimation_PropertyWithEase : public UUIEffectTextAnimation_Property
{
public:
	ELTweenEase                                   EaseType;                                          // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1262[0x7];                                     // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            EaseCurve;                                         // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1263[0x10];                                    // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetEaseCurve(class UCurveFloat* Value);
	void SetEaseType(ELTweenEase Value);

	class UCurveFloat* GetCurveFloat() const;
	ELTweenEase GetEaseType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation_PropertyWithEase">();
	}
	static class UUIEffectTextAnimation_PropertyWithEase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation_PropertyWithEase>();
	}
};
static_assert(alignof(UUIEffectTextAnimation_PropertyWithEase) == 0x000008, "Wrong alignment on UUIEffectTextAnimation_PropertyWithEase");
static_assert(sizeof(UUIEffectTextAnimation_PropertyWithEase) == 0x000050, "Wrong size on UUIEffectTextAnimation_PropertyWithEase");
static_assert(offsetof(UUIEffectTextAnimation_PropertyWithEase, EaseType) == 0x000030, "Member 'UUIEffectTextAnimation_PropertyWithEase::EaseType' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_PropertyWithEase, EaseCurve) == 0x000038, "Member 'UUIEffectTextAnimation_PropertyWithEase::EaseCurve' has a wrong offset!");

// Class LGUI.UIEffectTextAnimation_PositionProperty
// 0x0010 (0x0060 - 0x0050)
class UUIEffectTextAnimation_PositionProperty final : public UUIEffectTextAnimation_PropertyWithEase
{
public:
	struct FVector                                Position;                                          // 0x0050(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1264[0x4];                                     // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetPosition(const struct FVector& Value);

	struct FVector GetPosition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation_PositionProperty">();
	}
	static class UUIEffectTextAnimation_PositionProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation_PositionProperty>();
	}
};
static_assert(alignof(UUIEffectTextAnimation_PositionProperty) == 0x000008, "Wrong alignment on UUIEffectTextAnimation_PositionProperty");
static_assert(sizeof(UUIEffectTextAnimation_PositionProperty) == 0x000060, "Wrong size on UUIEffectTextAnimation_PositionProperty");
static_assert(offsetof(UUIEffectTextAnimation_PositionProperty, Position) == 0x000050, "Member 'UUIEffectTextAnimation_PositionProperty::Position' has a wrong offset!");

// Class LGUI.UIEffectTextAnimation_PositionRandomProperty
// 0x0020 (0x0070 - 0x0050)
class UUIEffectTextAnimation_PositionRandomProperty final : public UUIEffectTextAnimation_PropertyWithEase
{
public:
	int32                                         Seed;                                              // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                Min;                                               // 0x0054(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                Max;                                               // 0x0060(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1265[0x4];                                     // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMax(const struct FVector& Value);
	void SetMin(const struct FVector& Value);
	void SetSeed(int32 Value);

	struct FVector GetMax() const;
	struct FVector GetMin() const;
	int32 GetSeed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation_PositionRandomProperty">();
	}
	static class UUIEffectTextAnimation_PositionRandomProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation_PositionRandomProperty>();
	}
};
static_assert(alignof(UUIEffectTextAnimation_PositionRandomProperty) == 0x000008, "Wrong alignment on UUIEffectTextAnimation_PositionRandomProperty");
static_assert(sizeof(UUIEffectTextAnimation_PositionRandomProperty) == 0x000070, "Wrong size on UUIEffectTextAnimation_PositionRandomProperty");
static_assert(offsetof(UUIEffectTextAnimation_PositionRandomProperty, Seed) == 0x000050, "Member 'UUIEffectTextAnimation_PositionRandomProperty::Seed' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_PositionRandomProperty, Min) == 0x000054, "Member 'UUIEffectTextAnimation_PositionRandomProperty::Min' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_PositionRandomProperty, Max) == 0x000060, "Member 'UUIEffectTextAnimation_PositionRandomProperty::Max' has a wrong offset!");

// Class LGUI.UIEffectTextAnimation_RotationProperty
// 0x0010 (0x0060 - 0x0050)
class UUIEffectTextAnimation_RotationProperty final : public UUIEffectTextAnimation_PropertyWithEase
{
public:
	struct FRotator                               Rotator;                                           // 0x0050(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1266[0x4];                                     // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetRotator(const struct FRotator& Value);

	struct FRotator GetRotator() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation_RotationProperty">();
	}
	static class UUIEffectTextAnimation_RotationProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation_RotationProperty>();
	}
};
static_assert(alignof(UUIEffectTextAnimation_RotationProperty) == 0x000008, "Wrong alignment on UUIEffectTextAnimation_RotationProperty");
static_assert(sizeof(UUIEffectTextAnimation_RotationProperty) == 0x000060, "Wrong size on UUIEffectTextAnimation_RotationProperty");
static_assert(offsetof(UUIEffectTextAnimation_RotationProperty, Rotator) == 0x000050, "Member 'UUIEffectTextAnimation_RotationProperty::Rotator' has a wrong offset!");

// Class LGUI.UIEffectTextAnimation_RotationRandomProperty
// 0x0020 (0x0070 - 0x0050)
class UUIEffectTextAnimation_RotationRandomProperty final : public UUIEffectTextAnimation_PropertyWithEase
{
public:
	int32                                         Seed;                                              // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               Min;                                               // 0x0054(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FRotator                               Max;                                               // 0x0060(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1267[0x4];                                     // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMax(const struct FRotator& Value);
	void SetMin(const struct FRotator& Value);
	void SetSeed(int32 Value);

	struct FRotator GetMax() const;
	struct FRotator GetMin() const;
	int32 GetSeed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation_RotationRandomProperty">();
	}
	static class UUIEffectTextAnimation_RotationRandomProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation_RotationRandomProperty>();
	}
};
static_assert(alignof(UUIEffectTextAnimation_RotationRandomProperty) == 0x000008, "Wrong alignment on UUIEffectTextAnimation_RotationRandomProperty");
static_assert(sizeof(UUIEffectTextAnimation_RotationRandomProperty) == 0x000070, "Wrong size on UUIEffectTextAnimation_RotationRandomProperty");
static_assert(offsetof(UUIEffectTextAnimation_RotationRandomProperty, Seed) == 0x000050, "Member 'UUIEffectTextAnimation_RotationRandomProperty::Seed' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_RotationRandomProperty, Min) == 0x000054, "Member 'UUIEffectTextAnimation_RotationRandomProperty::Min' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_RotationRandomProperty, Max) == 0x000060, "Member 'UUIEffectTextAnimation_RotationRandomProperty::Max' has a wrong offset!");

// Class LGUI.UIEffectTextAnimation_ScaleProperty
// 0x0010 (0x0060 - 0x0050)
class UUIEffectTextAnimation_ScaleProperty final : public UUIEffectTextAnimation_PropertyWithEase
{
public:
	struct FVector                                Scale;                                             // 0x0050(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1268[0x4];                                     // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetScale(const struct FVector& Value);

	struct FVector GetScale() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation_ScaleProperty">();
	}
	static class UUIEffectTextAnimation_ScaleProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation_ScaleProperty>();
	}
};
static_assert(alignof(UUIEffectTextAnimation_ScaleProperty) == 0x000008, "Wrong alignment on UUIEffectTextAnimation_ScaleProperty");
static_assert(sizeof(UUIEffectTextAnimation_ScaleProperty) == 0x000060, "Wrong size on UUIEffectTextAnimation_ScaleProperty");
static_assert(offsetof(UUIEffectTextAnimation_ScaleProperty, Scale) == 0x000050, "Member 'UUIEffectTextAnimation_ScaleProperty::Scale' has a wrong offset!");

// Class LGUI.UIEffectTextAnimation_ScaleRandomProperty
// 0x0020 (0x0070 - 0x0050)
class UUIEffectTextAnimation_ScaleRandomProperty final : public UUIEffectTextAnimation_PropertyWithEase
{
public:
	int32                                         Seed;                                              // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                Min;                                               // 0x0054(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                Max;                                               // 0x0060(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1269[0x4];                                     // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMax(const struct FVector& Value);
	void SetMin(const struct FVector& Value);
	void SetSeed(int32 Value);

	struct FVector GetMax() const;
	struct FVector GetMin() const;
	int32 GetSeed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation_ScaleRandomProperty">();
	}
	static class UUIEffectTextAnimation_ScaleRandomProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation_ScaleRandomProperty>();
	}
};
static_assert(alignof(UUIEffectTextAnimation_ScaleRandomProperty) == 0x000008, "Wrong alignment on UUIEffectTextAnimation_ScaleRandomProperty");
static_assert(sizeof(UUIEffectTextAnimation_ScaleRandomProperty) == 0x000070, "Wrong size on UUIEffectTextAnimation_ScaleRandomProperty");
static_assert(offsetof(UUIEffectTextAnimation_ScaleRandomProperty, Seed) == 0x000050, "Member 'UUIEffectTextAnimation_ScaleRandomProperty::Seed' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_ScaleRandomProperty, Min) == 0x000054, "Member 'UUIEffectTextAnimation_ScaleRandomProperty::Min' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_ScaleRandomProperty, Max) == 0x000060, "Member 'UUIEffectTextAnimation_ScaleRandomProperty::Max' has a wrong offset!");

// Class LGUI.UIEffectTextAnimation_AlphaProperty
// 0x0008 (0x0058 - 0x0050)
class UUIEffectTextAnimation_AlphaProperty final : public UUIEffectTextAnimation_PropertyWithEase
{
public:
	float                                         Alpha;                                             // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_126A[0x4];                                     // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAlpha(float Value);

	float GetAlpha() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation_AlphaProperty">();
	}
	static class UUIEffectTextAnimation_AlphaProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation_AlphaProperty>();
	}
};
static_assert(alignof(UUIEffectTextAnimation_AlphaProperty) == 0x000008, "Wrong alignment on UUIEffectTextAnimation_AlphaProperty");
static_assert(sizeof(UUIEffectTextAnimation_AlphaProperty) == 0x000058, "Wrong size on UUIEffectTextAnimation_AlphaProperty");
static_assert(offsetof(UUIEffectTextAnimation_AlphaProperty, Alpha) == 0x000050, "Member 'UUIEffectTextAnimation_AlphaProperty::Alpha' has a wrong offset!");

// Class LGUI.UIEffectTextAnimation_ColorProperty
// 0x0008 (0x0058 - 0x0050)
class UUIEffectTextAnimation_ColorProperty final : public UUIEffectTextAnimation_PropertyWithEase
{
public:
	struct FColor                                 Color;                                             // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          UseHSV;                                            // 0x0054(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_126B[0x3];                                     // 0x0055(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetColor(const struct FColor& Value);
	void SetUseHSV(bool Value);

	struct FColor GetColor() const;
	bool GetUseHSV() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation_ColorProperty">();
	}
	static class UUIEffectTextAnimation_ColorProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation_ColorProperty>();
	}
};
static_assert(alignof(UUIEffectTextAnimation_ColorProperty) == 0x000008, "Wrong alignment on UUIEffectTextAnimation_ColorProperty");
static_assert(sizeof(UUIEffectTextAnimation_ColorProperty) == 0x000058, "Wrong size on UUIEffectTextAnimation_ColorProperty");
static_assert(offsetof(UUIEffectTextAnimation_ColorProperty, Color) == 0x000050, "Member 'UUIEffectTextAnimation_ColorProperty::Color' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_ColorProperty, UseHSV) == 0x000054, "Member 'UUIEffectTextAnimation_ColorProperty::UseHSV' has a wrong offset!");

// Class LGUI.UIEffectTextAnimation_ColorRandomProperty
// 0x0010 (0x0060 - 0x0050)
class UUIEffectTextAnimation_ColorRandomProperty final : public UUIEffectTextAnimation_PropertyWithEase
{
public:
	int32                                         Seed;                                              // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FColor                                 Min;                                               // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FColor                                 Max;                                               // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          UseHSV;                                            // 0x005C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_126C[0x3];                                     // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMax(const struct FColor& Value);
	void SetMin(const struct FColor& Value);
	void SetSeed(int32 Value);
	void SetUseHSV(bool Value);

	struct FColor GetMax() const;
	struct FColor GetMin() const;
	int32 GetSeed() const;
	bool GetUseHSV() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation_ColorRandomProperty">();
	}
	static class UUIEffectTextAnimation_ColorRandomProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation_ColorRandomProperty>();
	}
};
static_assert(alignof(UUIEffectTextAnimation_ColorRandomProperty) == 0x000008, "Wrong alignment on UUIEffectTextAnimation_ColorRandomProperty");
static_assert(sizeof(UUIEffectTextAnimation_ColorRandomProperty) == 0x000060, "Wrong size on UUIEffectTextAnimation_ColorRandomProperty");
static_assert(offsetof(UUIEffectTextAnimation_ColorRandomProperty, Seed) == 0x000050, "Member 'UUIEffectTextAnimation_ColorRandomProperty::Seed' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_ColorRandomProperty, Min) == 0x000054, "Member 'UUIEffectTextAnimation_ColorRandomProperty::Min' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_ColorRandomProperty, Max) == 0x000058, "Member 'UUIEffectTextAnimation_ColorRandomProperty::Max' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_ColorRandomProperty, UseHSV) == 0x00005C, "Member 'UUIEffectTextAnimation_ColorRandomProperty::UseHSV' has a wrong offset!");

// Class LGUI.UIEffectTextAnimation_PropertyWithWave
// 0x0020 (0x0050 - 0x0030)
class UUIEffectTextAnimation_PropertyWithWave : public UUIEffectTextAnimation_Property
{
public:
	float                                         Frequency;                                         // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Speed;                                             // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FlipDirection;                                     // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_126D[0xF];                                     // 0x0039(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIText*                                UiText;                                            // 0x0048(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetFrequency(float Value);

	float GetFrequency() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation_PropertyWithWave">();
	}
	static class UUIEffectTextAnimation_PropertyWithWave* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation_PropertyWithWave>();
	}
};
static_assert(alignof(UUIEffectTextAnimation_PropertyWithWave) == 0x000008, "Wrong alignment on UUIEffectTextAnimation_PropertyWithWave");
static_assert(sizeof(UUIEffectTextAnimation_PropertyWithWave) == 0x000050, "Wrong size on UUIEffectTextAnimation_PropertyWithWave");
static_assert(offsetof(UUIEffectTextAnimation_PropertyWithWave, Frequency) == 0x000030, "Member 'UUIEffectTextAnimation_PropertyWithWave::Frequency' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_PropertyWithWave, Speed) == 0x000034, "Member 'UUIEffectTextAnimation_PropertyWithWave::Speed' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_PropertyWithWave, FlipDirection) == 0x000038, "Member 'UUIEffectTextAnimation_PropertyWithWave::FlipDirection' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_PropertyWithWave, UiText) == 0x000048, "Member 'UUIEffectTextAnimation_PropertyWithWave::UiText' has a wrong offset!");

// Class LGUI.UIEffectTextAnimation_PositionWaveProperty
// 0x0010 (0x0060 - 0x0050)
class UUIEffectTextAnimation_PositionWaveProperty final : public UUIEffectTextAnimation_PropertyWithWave
{
public:
	struct FVector                                Position;                                          // 0x0050(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_126E[0x4];                                     // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetPosition(const struct FVector& Value);

	struct FVector GetPosition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation_PositionWaveProperty">();
	}
	static class UUIEffectTextAnimation_PositionWaveProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation_PositionWaveProperty>();
	}
};
static_assert(alignof(UUIEffectTextAnimation_PositionWaveProperty) == 0x000008, "Wrong alignment on UUIEffectTextAnimation_PositionWaveProperty");
static_assert(sizeof(UUIEffectTextAnimation_PositionWaveProperty) == 0x000060, "Wrong size on UUIEffectTextAnimation_PositionWaveProperty");
static_assert(offsetof(UUIEffectTextAnimation_PositionWaveProperty, Position) == 0x000050, "Member 'UUIEffectTextAnimation_PositionWaveProperty::Position' has a wrong offset!");

// Class LGUI.UIEffectTextAnimation_RotationWaveProperty
// 0x0010 (0x0060 - 0x0050)
class UUIEffectTextAnimation_RotationWaveProperty final : public UUIEffectTextAnimation_PropertyWithWave
{
public:
	struct FRotator                               Rotator;                                           // 0x0050(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_126F[0x4];                                     // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetRotator(const struct FRotator& Value);

	struct FRotator GetRotator() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation_RotationWaveProperty">();
	}
	static class UUIEffectTextAnimation_RotationWaveProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation_RotationWaveProperty>();
	}
};
static_assert(alignof(UUIEffectTextAnimation_RotationWaveProperty) == 0x000008, "Wrong alignment on UUIEffectTextAnimation_RotationWaveProperty");
static_assert(sizeof(UUIEffectTextAnimation_RotationWaveProperty) == 0x000060, "Wrong size on UUIEffectTextAnimation_RotationWaveProperty");
static_assert(offsetof(UUIEffectTextAnimation_RotationWaveProperty, Rotator) == 0x000050, "Member 'UUIEffectTextAnimation_RotationWaveProperty::Rotator' has a wrong offset!");

// Class LGUI.UIEffectTextAnimation_ScaleWaveProperty
// 0x0010 (0x0060 - 0x0050)
class UUIEffectTextAnimation_ScaleWaveProperty final : public UUIEffectTextAnimation_PropertyWithWave
{
public:
	struct FVector                                Scale;                                             // 0x0050(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1270[0x4];                                     // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetScale(const struct FVector& Value);

	struct FVector GetScale() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation_ScaleWaveProperty">();
	}
	static class UUIEffectTextAnimation_ScaleWaveProperty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation_ScaleWaveProperty>();
	}
};
static_assert(alignof(UUIEffectTextAnimation_ScaleWaveProperty) == 0x000008, "Wrong alignment on UUIEffectTextAnimation_ScaleWaveProperty");
static_assert(sizeof(UUIEffectTextAnimation_ScaleWaveProperty) == 0x000060, "Wrong size on UUIEffectTextAnimation_ScaleWaveProperty");
static_assert(offsetof(UUIEffectTextAnimation_ScaleWaveProperty, Scale) == 0x000050, "Member 'UUIEffectTextAnimation_ScaleWaveProperty::Scale' has a wrong offset!");

// Class LGUI.UIEffectTextAnimation_RangeSelector
// 0x0028 (0x0060 - 0x0038)
class UUIEffectTextAnimation_RangeSelector final : public UUIEffectTextAnimation_Selector
{
public:
	float                                         Range;                                             // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          FlipDirection;                                     // 0x003C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1271[0x3];                                     // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Start;                                             // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         End;                                               // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          LineByLine;                                        // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1272[0x17];                                    // 0x0049(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetEnd(float Value);
	void SetFlipDirection(bool Value);
	void SetRange(float Value);
	void SetStart(float Value);

	float GetEnd() const;
	bool GetFlipDirection() const;
	float GetRange() const;
	float GetStart() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation_RangeSelector">();
	}
	static class UUIEffectTextAnimation_RangeSelector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation_RangeSelector>();
	}
};
static_assert(alignof(UUIEffectTextAnimation_RangeSelector) == 0x000008, "Wrong alignment on UUIEffectTextAnimation_RangeSelector");
static_assert(sizeof(UUIEffectTextAnimation_RangeSelector) == 0x000060, "Wrong size on UUIEffectTextAnimation_RangeSelector");
static_assert(offsetof(UUIEffectTextAnimation_RangeSelector, Range) == 0x000038, "Member 'UUIEffectTextAnimation_RangeSelector::Range' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_RangeSelector, FlipDirection) == 0x00003C, "Member 'UUIEffectTextAnimation_RangeSelector::FlipDirection' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_RangeSelector, Start) == 0x000040, "Member 'UUIEffectTextAnimation_RangeSelector::Start' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_RangeSelector, End) == 0x000044, "Member 'UUIEffectTextAnimation_RangeSelector::End' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_RangeSelector, LineByLine) == 0x000048, "Member 'UUIEffectTextAnimation_RangeSelector::LineByLine' has a wrong offset!");

// Class LGUI.UIEffectTextAnimation_RandomSelector
// 0x0010 (0x0048 - 0x0038)
class UUIEffectTextAnimation_RandomSelector final : public UUIEffectTextAnimation_Selector
{
public:
	int32                                         Seed;                                              // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Start;                                             // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         End;                                               // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1273[0x4];                                     // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetEnd(float Value);
	void SetSeed(int32 Value);
	void SetStart(float Value);

	float GetEnd() const;
	int32 GetSeed() const;
	float GetStart() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation_RandomSelector">();
	}
	static class UUIEffectTextAnimation_RandomSelector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation_RandomSelector>();
	}
};
static_assert(alignof(UUIEffectTextAnimation_RandomSelector) == 0x000008, "Wrong alignment on UUIEffectTextAnimation_RandomSelector");
static_assert(sizeof(UUIEffectTextAnimation_RandomSelector) == 0x000048, "Wrong size on UUIEffectTextAnimation_RandomSelector");
static_assert(offsetof(UUIEffectTextAnimation_RandomSelector, Seed) == 0x000038, "Member 'UUIEffectTextAnimation_RandomSelector::Seed' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_RandomSelector, Start) == 0x00003C, "Member 'UUIEffectTextAnimation_RandomSelector::Start' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_RandomSelector, End) == 0x000040, "Member 'UUIEffectTextAnimation_RandomSelector::End' has a wrong offset!");

// Class LGUI.UIEffectTextAnimation_RichTextTagSelector
// 0x0018 (0x0050 - 0x0038)
class UUIEffectTextAnimation_RichTextTagSelector final : public UUIEffectTextAnimation_Selector
{
public:
	float                                         Range;                                             // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   TagName;                                           // 0x003C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          FlipDirection;                                     // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1274[0x7];                                     // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetFlipDirection(bool Value);
	void SetRange(float Value);
	void SetTagName(const class FName& Value);

	bool GetFlipDirection() const;
	float GetRange() const;
	const class FName GetTagName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEffectTextAnimation_RichTextTagSelector">();
	}
	static class UUIEffectTextAnimation_RichTextTagSelector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEffectTextAnimation_RichTextTagSelector>();
	}
};
static_assert(alignof(UUIEffectTextAnimation_RichTextTagSelector) == 0x000008, "Wrong alignment on UUIEffectTextAnimation_RichTextTagSelector");
static_assert(sizeof(UUIEffectTextAnimation_RichTextTagSelector) == 0x000050, "Wrong size on UUIEffectTextAnimation_RichTextTagSelector");
static_assert(offsetof(UUIEffectTextAnimation_RichTextTagSelector, Range) == 0x000038, "Member 'UUIEffectTextAnimation_RichTextTagSelector::Range' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_RichTextTagSelector, TagName) == 0x00003C, "Member 'UUIEffectTextAnimation_RichTextTagSelector::TagName' has a wrong offset!");
static_assert(offsetof(UUIEffectTextAnimation_RichTextTagSelector, FlipDirection) == 0x000048, "Member 'UUIEffectTextAnimation_RichTextTagSelector::FlipDirection' has a wrong offset!");

// Class LGUI.UIEventBlocker
// 0x0010 (0x03A8 - 0x0398)
class AUIEventBlocker final : public AUIContainerActor
{
public:
	uint8                                         Pad_1275[0x10];                                    // 0x0398(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEventBlocker">();
	}
	static class AUIEventBlocker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIEventBlocker>();
	}
};
static_assert(alignof(AUIEventBlocker) == 0x000008, "Wrong alignment on AUIEventBlocker");
static_assert(sizeof(AUIEventBlocker) == 0x0003A8, "Wrong size on AUIEventBlocker");

// Class LGUI.UIEventBlockerComponent
// 0x0040 (0x0100 - 0x00C0)
class UUIEventBlockerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_1276[0x38];                                    // 0x00C0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          AllowEventBubbleUp;                                // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1277[0x7];                                     // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEventBlockerComponent">();
	}
	static class UUIEventBlockerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEventBlockerComponent>();
	}
};
static_assert(alignof(UUIEventBlockerComponent) == 0x000008, "Wrong alignment on UUIEventBlockerComponent");
static_assert(sizeof(UUIEventBlockerComponent) == 0x000100, "Wrong size on UUIEventBlockerComponent");
static_assert(offsetof(UUIEventBlockerComponent, AllowEventBubbleUp) == 0x0000F8, "Member 'UUIEventBlockerComponent::AllowEventBubbleUp' has a wrong offset!");

// Class LGUI.UIEventTriggerComponent
// 0x02C8 (0x0388 - 0x00C0)
class UUIEventTriggerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_1278[0x38];                                    // 0x00C0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          AllowEventBubbleUp;                                // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1279[0x7];                                     // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUIDrawableEvent                     OnPointerEnter;                                    // 0x0100(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FLGUIDrawableEvent                     OnPointerExit;                                     // 0x0118(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FLGUIDrawableEvent                     OnPointerDown;                                     // 0x0130(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FLGUIDrawableEvent                     OnPointerUp;                                       // 0x0148(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FLGUIDrawableEvent                     OnPointerCancel;                                   // 0x0160(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FLGUIDrawableEvent                     OnPointerClick;                                    // 0x0178(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FLGUIDrawableEvent                     OnPointerBeginDrag;                                // 0x0190(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FLGUIDrawableEvent                     OnPointerDrag;                                     // 0x01A8(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FLGUIDrawableEvent                     OnPointerEndDrag;                                  // 0x01C0(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FLGUIDrawableEvent                     OnPointerDragEnter;                                // 0x01D8(0x0018)(Deprecated, Protected, NativeAccessSpecifierProtected)
	struct FLGUIDrawableEvent                     OnPointerDragExit;                                 // 0x01F0(0x0018)(Deprecated, Protected, NativeAccessSpecifierProtected)
	struct FLGUIDrawableEvent                     OnPointerDragDrop;                                 // 0x0208(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FLGUIDrawableEvent                     OnPointerScroll;                                   // 0x0220(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FLGUIDrawableEvent                     OnPointerSelect;                                   // 0x0238(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FLGUIDrawableEvent                     OnPointerDeselect;                                 // 0x0250(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_127A[0x120];                                   // 0x0268(0x0120)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FLGUIDelegateHandleWrapper RegisterOnPointerBeginDrag(const TDelegate<void(class ULGUIPointerEventData* PointerEventData)>& InDelegate);
	struct FLGUIDelegateHandleWrapper RegisterOnPointerClick(const TDelegate<void(class ULGUIPointerEventData* PointerEventData)>& InDelegate);
	struct FLGUIDelegateHandleWrapper RegisterOnPointerDeselect(const TDelegate<void(class ULGUIBaseEventData* EventData)>& InDelegate);
	struct FLGUIDelegateHandleWrapper RegisterOnPointerDown(const TDelegate<void(class ULGUIPointerEventData* PointerEventData)>& InDelegate);
	struct FLGUIDelegateHandleWrapper RegisterOnPointerDrag(const TDelegate<void(class ULGUIPointerEventData* PointerEventData)>& InDelegate);
	struct FLGUIDelegateHandleWrapper RegisterOnPointerDragDrop(const TDelegate<void(class ULGUIPointerEventData* PointerEventData)>& InDelegate);
	struct FLGUIDelegateHandleWrapper RegisterOnPointerDragEnter(const TDelegate<void(class ULGUIPointerEventData* PointerEventData)>& InDelegate);
	struct FLGUIDelegateHandleWrapper RegisterOnPointerDragExit(const TDelegate<void(class ULGUIPointerEventData* PointerEventData)>& InDelegate);
	struct FLGUIDelegateHandleWrapper RegisterOnPointerEndDrag(const TDelegate<void(class ULGUIPointerEventData* PointerEventData)>& InDelegate);
	struct FLGUIDelegateHandleWrapper RegisterOnPointerEnter(const TDelegate<void(class ULGUIPointerEventData* PointerEventData)>& InDelegate);
	struct FLGUIDelegateHandleWrapper RegisterOnPointerExit(const TDelegate<void(class ULGUIPointerEventData* PointerEventData)>& InDelegate);
	struct FLGUIDelegateHandleWrapper RegisterOnPointerScroll(const TDelegate<void(class ULGUIPointerEventData* PointerEventData)>& InDelegate);
	struct FLGUIDelegateHandleWrapper RegisterOnPointerSelect(const TDelegate<void(class ULGUIBaseEventData* EventData)>& InDelegate);
	struct FLGUIDelegateHandleWrapper RegisterOnPointerUp(const TDelegate<void(class ULGUIPointerEventData* PointerEventData)>& InDelegate);
	void UnregisterOnPointerBeginDrag(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	void UnregisterOnPointerClick(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	void UnregisterOnPointerDeselect(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	void UnregisterOnPointerDown(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	void UnregisterOnPointerDrag(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	void UnregisterOnPointerDragDrop(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	void UnregisterOnPointerDragEnter(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	void UnregisterOnPointerDragExit(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	void UnregisterOnPointerEndDrag(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	void UnregisterOnPointerEnter(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	void UnregisterOnPointerExit(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	void UnregisterOnPointerScroll(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	void UnregisterOnPointerSelect(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	void UnregisterOnPointerUp(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIEventTriggerComponent">();
	}
	static class UUIEventTriggerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIEventTriggerComponent>();
	}
};
static_assert(alignof(UUIEventTriggerComponent) == 0x000008, "Wrong alignment on UUIEventTriggerComponent");
static_assert(sizeof(UUIEventTriggerComponent) == 0x000388, "Wrong size on UUIEventTriggerComponent");
static_assert(offsetof(UUIEventTriggerComponent, AllowEventBubbleUp) == 0x0000F8, "Member 'UUIEventTriggerComponent::AllowEventBubbleUp' has a wrong offset!");
static_assert(offsetof(UUIEventTriggerComponent, OnPointerEnter) == 0x000100, "Member 'UUIEventTriggerComponent::OnPointerEnter' has a wrong offset!");
static_assert(offsetof(UUIEventTriggerComponent, OnPointerExit) == 0x000118, "Member 'UUIEventTriggerComponent::OnPointerExit' has a wrong offset!");
static_assert(offsetof(UUIEventTriggerComponent, OnPointerDown) == 0x000130, "Member 'UUIEventTriggerComponent::OnPointerDown' has a wrong offset!");
static_assert(offsetof(UUIEventTriggerComponent, OnPointerUp) == 0x000148, "Member 'UUIEventTriggerComponent::OnPointerUp' has a wrong offset!");
static_assert(offsetof(UUIEventTriggerComponent, OnPointerCancel) == 0x000160, "Member 'UUIEventTriggerComponent::OnPointerCancel' has a wrong offset!");
static_assert(offsetof(UUIEventTriggerComponent, OnPointerClick) == 0x000178, "Member 'UUIEventTriggerComponent::OnPointerClick' has a wrong offset!");
static_assert(offsetof(UUIEventTriggerComponent, OnPointerBeginDrag) == 0x000190, "Member 'UUIEventTriggerComponent::OnPointerBeginDrag' has a wrong offset!");
static_assert(offsetof(UUIEventTriggerComponent, OnPointerDrag) == 0x0001A8, "Member 'UUIEventTriggerComponent::OnPointerDrag' has a wrong offset!");
static_assert(offsetof(UUIEventTriggerComponent, OnPointerEndDrag) == 0x0001C0, "Member 'UUIEventTriggerComponent::OnPointerEndDrag' has a wrong offset!");
static_assert(offsetof(UUIEventTriggerComponent, OnPointerDragEnter) == 0x0001D8, "Member 'UUIEventTriggerComponent::OnPointerDragEnter' has a wrong offset!");
static_assert(offsetof(UUIEventTriggerComponent, OnPointerDragExit) == 0x0001F0, "Member 'UUIEventTriggerComponent::OnPointerDragExit' has a wrong offset!");
static_assert(offsetof(UUIEventTriggerComponent, OnPointerDragDrop) == 0x000208, "Member 'UUIEventTriggerComponent::OnPointerDragDrop' has a wrong offset!");
static_assert(offsetof(UUIEventTriggerComponent, OnPointerScroll) == 0x000220, "Member 'UUIEventTriggerComponent::OnPointerScroll' has a wrong offset!");
static_assert(offsetof(UUIEventTriggerComponent, OnPointerSelect) == 0x000238, "Member 'UUIEventTriggerComponent::OnPointerSelect' has a wrong offset!");
static_assert(offsetof(UUIEventTriggerComponent, OnPointerDeselect) == 0x000250, "Member 'UUIEventTriggerComponent::OnPointerDeselect' has a wrong offset!");

// Class LGUI.UIExtendButtonComponent
// 0x0008 (0x05E8 - 0x05E0)
class UUIExtendButtonComponent final : public UUIButtonComponent
{
public:
	int32                                         HelpGroupId;                                       // 0x05E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_127B[0x4];                                     // 0x05E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void SetDelegateForHelpClick(const TDelegate<void(int32 HelpGroupId)>& DelegateObj);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIExtendButtonComponent">();
	}
	static class UUIExtendButtonComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIExtendButtonComponent>();
	}
};
static_assert(alignof(UUIExtendButtonComponent) == 0x000008, "Wrong alignment on UUIExtendButtonComponent");
static_assert(sizeof(UUIExtendButtonComponent) == 0x0005E8, "Wrong size on UUIExtendButtonComponent");
static_assert(offsetof(UUIExtendButtonComponent, HelpGroupId) == 0x0005E0, "Member 'UUIExtendButtonComponent::HelpGroupId' has a wrong offset!");

// Class LGUI.UIExtendToggleGroup
// 0x0048 (0x0108 - 0x00C0)
class UUIExtendToggleGroup final : public UActorComponent
{
public:
	uint8                                         Pad_127C[0x8];                                     // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnToggleGroupActivationChanged;                    // 0x00C8(0x0010)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bGroupToggleOnSelect;                              // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_127D[0xF];                                     // 0x00D9(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class UUIExtendToggle>> ToggleCollection;                                  // 0x00E8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          bAllowNoneSelect;                                  // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnable;                                           // 0x00F9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_127E[0xE];                                     // 0x00FA(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void BindOnExtendToggleGroupActive(const TDelegate<void(class UUIExtendToggleGroup* ExtendToggleGroup, bool bCreate)>& Delegate);
	static void UnBindOnExtendToggleGroupActive();

	bool GetAllowNoneSelect();
	void SetAllowNoneSelect(bool bAllowNoneSelection);
	void SetGroupEnable(bool bInEnable);

	class UUIExtendToggle* GetCurSelection() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIExtendToggleGroup">();
	}
	static class UUIExtendToggleGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIExtendToggleGroup>();
	}
};
static_assert(alignof(UUIExtendToggleGroup) == 0x000008, "Wrong alignment on UUIExtendToggleGroup");
static_assert(sizeof(UUIExtendToggleGroup) == 0x000108, "Wrong size on UUIExtendToggleGroup");
static_assert(offsetof(UUIExtendToggleGroup, OnToggleGroupActivationChanged) == 0x0000C8, "Member 'UUIExtendToggleGroup::OnToggleGroupActivationChanged' has a wrong offset!");
static_assert(offsetof(UUIExtendToggleGroup, bGroupToggleOnSelect) == 0x0000D8, "Member 'UUIExtendToggleGroup::bGroupToggleOnSelect' has a wrong offset!");
static_assert(offsetof(UUIExtendToggleGroup, ToggleCollection) == 0x0000E8, "Member 'UUIExtendToggleGroup::ToggleCollection' has a wrong offset!");
static_assert(offsetof(UUIExtendToggleGroup, bAllowNoneSelect) == 0x0000F8, "Member 'UUIExtendToggleGroup::bAllowNoneSelect' has a wrong offset!");
static_assert(offsetof(UUIExtendToggleGroup, bEnable) == 0x0000F9, "Member 'UUIExtendToggleGroup::bEnable' has a wrong offset!");

// Class LGUI.UIExtendToggleSpriteTransition
// 0x01A8 (0x02E8 - 0x0140)
class UUIExtendToggleSpriteTransition final : public UUIExtendToggleTransitionBase
{
public:
	ESpriteTransitionType                         TransitionType;                                    // 0x0140(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_127F[0x3];                                     // 0x0141(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FExtendToggleColorTransition           TransitionColors;                                  // 0x0144(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1280[0x4];                                     // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FExtendToggleSpriteTransitionState     TransitionState;                                   // 0x0170(0x0128)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1281[0x50];                                    // 0x0298(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAllStateSprite(class ULGUISpriteData_BaseObject* NewSprite);
	void SetStateSprite(EToggleTransitionState State, class ULGUISpriteData_BaseObject* NewSprite, bool ForceNoTriggerOnChange);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIExtendToggleSpriteTransition">();
	}
	static class UUIExtendToggleSpriteTransition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIExtendToggleSpriteTransition>();
	}
};
static_assert(alignof(UUIExtendToggleSpriteTransition) == 0x000008, "Wrong alignment on UUIExtendToggleSpriteTransition");
static_assert(sizeof(UUIExtendToggleSpriteTransition) == 0x0002E8, "Wrong size on UUIExtendToggleSpriteTransition");
static_assert(offsetof(UUIExtendToggleSpriteTransition, TransitionType) == 0x000140, "Member 'UUIExtendToggleSpriteTransition::TransitionType' has a wrong offset!");
static_assert(offsetof(UUIExtendToggleSpriteTransition, TransitionColors) == 0x000144, "Member 'UUIExtendToggleSpriteTransition::TransitionColors' has a wrong offset!");
static_assert(offsetof(UUIExtendToggleSpriteTransition, TransitionState) == 0x000170, "Member 'UUIExtendToggleSpriteTransition::TransitionState' has a wrong offset!");

// Class LGUI.UIExtendToggleTextTransition
// 0x0070 (0x01B0 - 0x0140)
class UUIExtendToggleTextTransition final : public UUIExtendToggleTransitionBase
{
public:
	struct FExtendToggleTextTransitionState       TransitionState;                                   // 0x0140(0x0070)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIExtendToggleTextTransition">();
	}
	static class UUIExtendToggleTextTransition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIExtendToggleTextTransition>();
	}
};
static_assert(alignof(UUIExtendToggleTextTransition) == 0x000008, "Wrong alignment on UUIExtendToggleTextTransition");
static_assert(sizeof(UUIExtendToggleTextTransition) == 0x0001B0, "Wrong size on UUIExtendToggleTextTransition");
static_assert(offsetof(UUIExtendToggleTextTransition, TransitionState) == 0x000140, "Member 'UUIExtendToggleTextTransition::TransitionState' has a wrong offset!");

// Class LGUI.UIFlyoutMenu
// 0x0038 (0x00F8 - 0x00C0)
class UUIFlyoutMenu final : public UActorComponent
{
public:
	uint8                                         Pad_1284[0x8];                                     // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AUIBaseActor*                           _RootUIActor;                                      // 0x00C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AUIBaseActor*                           _SrcItemActor;                                     // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUIFlyoutMenuItem*>              _CreatedItemArray;                                 // 0x00D8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1285[0x10];                                    // 0x00E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UUIFlyoutMenu* CreateFlyoutMenuFromArray(const TArray<class FString>& InItemNameArray, const TDelegate<void(int32 InSelectIndex, const class FString& InSelectItem)>& InCallback, class AUIBaseActor* InParentActor, int32 InWidth, EFlyoutMenuVerticalPosition InVerticalPosition, EFlyoutMenuHorizontalAlignment InHorizontalAlign);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFlyoutMenu">();
	}
	static class UUIFlyoutMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFlyoutMenu>();
	}
};
static_assert(alignof(UUIFlyoutMenu) == 0x000008, "Wrong alignment on UUIFlyoutMenu");
static_assert(sizeof(UUIFlyoutMenu) == 0x0000F8, "Wrong size on UUIFlyoutMenu");
static_assert(offsetof(UUIFlyoutMenu, _RootUIActor) == 0x0000C8, "Member 'UUIFlyoutMenu::_RootUIActor' has a wrong offset!");
static_assert(offsetof(UUIFlyoutMenu, _SrcItemActor) == 0x0000D0, "Member 'UUIFlyoutMenu::_SrcItemActor' has a wrong offset!");
static_assert(offsetof(UUIFlyoutMenu, _CreatedItemArray) == 0x0000D8, "Member 'UUIFlyoutMenu::_CreatedItemArray' has a wrong offset!");

// Class LGUI.UIFlyoutMenuItem
// 0x0030 (0x00F0 - 0x00C0)
class UUIFlyoutMenuItem final : public UActorComponent
{
public:
	uint8                                         Pad_1287[0x8];                                     // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AUIBaseActor*                           _RootUIActor;                                      // 0x00C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AUITextActor*                           _TextActor;                                        // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AUISpriteActor*                         _HighlightSpriteActor;                             // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1288[0x10];                                    // 0x00E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFlyoutMenuItem">();
	}
	static class UUIFlyoutMenuItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFlyoutMenuItem>();
	}
};
static_assert(alignof(UUIFlyoutMenuItem) == 0x000008, "Wrong alignment on UUIFlyoutMenuItem");
static_assert(sizeof(UUIFlyoutMenuItem) == 0x0000F0, "Wrong size on UUIFlyoutMenuItem");
static_assert(offsetof(UUIFlyoutMenuItem, _RootUIActor) == 0x0000C8, "Member 'UUIFlyoutMenuItem::_RootUIActor' has a wrong offset!");
static_assert(offsetof(UUIFlyoutMenuItem, _TextActor) == 0x0000D0, "Member 'UUIFlyoutMenuItem::_TextActor' has a wrong offset!");
static_assert(offsetof(UUIFlyoutMenuItem, _HighlightSpriteActor) == 0x0000D8, "Member 'UUIFlyoutMenuItem::_HighlightSpriteActor' has a wrong offset!");

// Class LGUI.UIForcesCursor
// 0x00F0 (0x0310 - 0x0220)
class UUIForcesCursor final : public USceneComponent
{
public:
	bool                                          IsOrthographic;                                    // 0x0218(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1289[0x3];                                     // 0x0219(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ScreenSizeX;                                       // 0x021C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScreenSizeY;                                       // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotatorInfo;                                       // 0x0224(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                MoveVector;                                        // 0x0230(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OriginPos;                                         // 0x023C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrameStepping;                                     // 0x0248(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngleX;                                         // 0x024C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngleY;                                         // 0x0250(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MouseX;                                            // 0x0254(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MouseY;                                            // 0x0258(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OffsetVector;                                      // 0x025C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AroundPoint;                                       // 0x0268(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadRightX;                                     // 0x0274(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GamepadRightY;                                     // 0x0278(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Tilt;                                              // 0x027C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Gravity;                                           // 0x0288(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RotationRate;                                      // 0x0294(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Acceleration;                                      // 0x02A0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_128A[0x64];                                    // 0x02AC(0x0064)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIForcesCursor">();
	}
	static class UUIForcesCursor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIForcesCursor>();
	}
};
static_assert(alignof(UUIForcesCursor) == 0x000010, "Wrong alignment on UUIForcesCursor");
static_assert(sizeof(UUIForcesCursor) == 0x000310, "Wrong size on UUIForcesCursor");
static_assert(offsetof(UUIForcesCursor, IsOrthographic) == 0x000218, "Member 'UUIForcesCursor::IsOrthographic' has a wrong offset!");
static_assert(offsetof(UUIForcesCursor, ScreenSizeX) == 0x00021C, "Member 'UUIForcesCursor::ScreenSizeX' has a wrong offset!");
static_assert(offsetof(UUIForcesCursor, ScreenSizeY) == 0x000220, "Member 'UUIForcesCursor::ScreenSizeY' has a wrong offset!");
static_assert(offsetof(UUIForcesCursor, RotatorInfo) == 0x000224, "Member 'UUIForcesCursor::RotatorInfo' has a wrong offset!");
static_assert(offsetof(UUIForcesCursor, MoveVector) == 0x000230, "Member 'UUIForcesCursor::MoveVector' has a wrong offset!");
static_assert(offsetof(UUIForcesCursor, OriginPos) == 0x00023C, "Member 'UUIForcesCursor::OriginPos' has a wrong offset!");
static_assert(offsetof(UUIForcesCursor, FrameStepping) == 0x000248, "Member 'UUIForcesCursor::FrameStepping' has a wrong offset!");
static_assert(offsetof(UUIForcesCursor, MaxAngleX) == 0x00024C, "Member 'UUIForcesCursor::MaxAngleX' has a wrong offset!");
static_assert(offsetof(UUIForcesCursor, MaxAngleY) == 0x000250, "Member 'UUIForcesCursor::MaxAngleY' has a wrong offset!");
static_assert(offsetof(UUIForcesCursor, MouseX) == 0x000254, "Member 'UUIForcesCursor::MouseX' has a wrong offset!");
static_assert(offsetof(UUIForcesCursor, MouseY) == 0x000258, "Member 'UUIForcesCursor::MouseY' has a wrong offset!");
static_assert(offsetof(UUIForcesCursor, OffsetVector) == 0x00025C, "Member 'UUIForcesCursor::OffsetVector' has a wrong offset!");
static_assert(offsetof(UUIForcesCursor, AroundPoint) == 0x000268, "Member 'UUIForcesCursor::AroundPoint' has a wrong offset!");
static_assert(offsetof(UUIForcesCursor, GamepadRightX) == 0x000274, "Member 'UUIForcesCursor::GamepadRightX' has a wrong offset!");
static_assert(offsetof(UUIForcesCursor, GamepadRightY) == 0x000278, "Member 'UUIForcesCursor::GamepadRightY' has a wrong offset!");
static_assert(offsetof(UUIForcesCursor, Tilt) == 0x00027C, "Member 'UUIForcesCursor::Tilt' has a wrong offset!");
static_assert(offsetof(UUIForcesCursor, Gravity) == 0x000288, "Member 'UUIForcesCursor::Gravity' has a wrong offset!");
static_assert(offsetof(UUIForcesCursor, RotationRate) == 0x000294, "Member 'UUIForcesCursor::RotationRate' has a wrong offset!");
static_assert(offsetof(UUIForcesCursor, Acceleration) == 0x0002A0, "Member 'UUIForcesCursor::Acceleration' has a wrong offset!");

// Class LGUI.UIGridLayout
// 0x0038 (0x01C8 - 0x0190)
class UUIGridLayout final : public UUILayoutWithAnimation
{
public:
	struct FMargin                                Padding;                                           // 0x0190(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              Spacing;                                           // 0x01A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELGUILayoutAlignmentType                      Align;                                             // 0x01A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          LastLineCanAlign;                                  // 0x01A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          HorizontalOrVertical;                              // 0x01AA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          DependOnSizeOrCount;                               // 0x01AB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ExpendChildSize;                                   // 0x01AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_128B[0x3];                                     // 0x01AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              CellSize;                                          // 0x01B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint32                                        LineCount;                                         // 0x01B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          WidthFitToChildren;                                // 0x01BC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          HeightFitToChildren;                               // 0x01BD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGridFitType                                  FitType;                                           // 0x01BE(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_128C[0x9];                                     // 0x01BF(0x0009)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAlign(ELGUILayoutAlignmentType Value);
	void SetCellSize(const struct FVector2D& Value);
	void SetDependOnSizeOrCount(bool Value);
	void SetExpendChildSize(bool Value);
	void SetHeightFitToChildren(bool Value);
	void SetHorizontalOrVertical(bool Value);
	void SetLastLineCanAlign(bool Value);
	void SetLineCount(int32 Value);
	void SetMaxItemCountInOneLine(int32 Value);
	void SetPadding(const struct FMargin& Value);
	void SetSpacing(const struct FVector2D& Value);
	void SetWidthFitToChildren(bool Value);

	struct FVector2D GetActuralRange() const;
	ELGUILayoutAlignmentType GetAlign() const;
	struct FVector2D GetCellSize() const;
	bool GetDependOnSizeOrCount() const;
	bool GetExpendChildSize() const;
	bool GetHeightFitToChildren() const;
	bool GetHorizontalOrVertical() const;
	bool GetLastLineCanAlign() const;
	int32 GetLineCount() const;
	int32 GetMaxItemCountInOneLine() const;
	struct FMargin GetPadding() const;
	struct FVector2D GetSpacing() const;
	bool GetWidthFitToChildren() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGridLayout">();
	}
	static class UUIGridLayout* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGridLayout>();
	}
};
static_assert(alignof(UUIGridLayout) == 0x000008, "Wrong alignment on UUIGridLayout");
static_assert(sizeof(UUIGridLayout) == 0x0001C8, "Wrong size on UUIGridLayout");
static_assert(offsetof(UUIGridLayout, Padding) == 0x000190, "Member 'UUIGridLayout::Padding' has a wrong offset!");
static_assert(offsetof(UUIGridLayout, Spacing) == 0x0001A0, "Member 'UUIGridLayout::Spacing' has a wrong offset!");
static_assert(offsetof(UUIGridLayout, Align) == 0x0001A8, "Member 'UUIGridLayout::Align' has a wrong offset!");
static_assert(offsetof(UUIGridLayout, LastLineCanAlign) == 0x0001A9, "Member 'UUIGridLayout::LastLineCanAlign' has a wrong offset!");
static_assert(offsetof(UUIGridLayout, HorizontalOrVertical) == 0x0001AA, "Member 'UUIGridLayout::HorizontalOrVertical' has a wrong offset!");
static_assert(offsetof(UUIGridLayout, DependOnSizeOrCount) == 0x0001AB, "Member 'UUIGridLayout::DependOnSizeOrCount' has a wrong offset!");
static_assert(offsetof(UUIGridLayout, ExpendChildSize) == 0x0001AC, "Member 'UUIGridLayout::ExpendChildSize' has a wrong offset!");
static_assert(offsetof(UUIGridLayout, CellSize) == 0x0001B0, "Member 'UUIGridLayout::CellSize' has a wrong offset!");
static_assert(offsetof(UUIGridLayout, LineCount) == 0x0001B8, "Member 'UUIGridLayout::LineCount' has a wrong offset!");
static_assert(offsetof(UUIGridLayout, WidthFitToChildren) == 0x0001BC, "Member 'UUIGridLayout::WidthFitToChildren' has a wrong offset!");
static_assert(offsetof(UUIGridLayout, HeightFitToChildren) == 0x0001BD, "Member 'UUIGridLayout::HeightFitToChildren' has a wrong offset!");
static_assert(offsetof(UUIGridLayout, FitType) == 0x0001BE, "Member 'UUIGridLayout::FitType' has a wrong offset!");

// Class LGUI.UIHorizontalLayout
// 0x0030 (0x01C0 - 0x0190)
class UUIHorizontalLayout final : public UUILayoutWithAnimation
{
public:
	struct FMargin                                Padding;                                           // 0x0190(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         Spacing;                                           // 0x01A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELGUILayoutAlignmentType                      Align;                                             // 0x01A4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ExpendChildrenWidth;                               // 0x01A5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ExpendChildrenHeight;                              // 0x01A6(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          WidthFitToChildren;                                // 0x01A7(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          HeightFitToChildren;                               // 0x01A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_128D[0x17];                                    // 0x01A9(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAlign(ELGUILayoutAlignmentType Value);
	void SetExpendChildrenHeight(bool Value);
	void SetExpendChildrenWidth(bool Value);
	void SetHeightFitToChildren(bool Value);
	void SetPadding(const struct FMargin& Value);
	void SetSpacing(float Value);
	void SetWidthFitToChildren(bool Value);

	float GetActuralRange() const;
	ELGUILayoutAlignmentType GetAlign() const;
	bool GetExpendChildrenHeight() const;
	bool GetExpendChildrenWidth() const;
	bool GetHeightFitToChildren() const;
	struct FMargin GetPadding() const;
	float GetSpacing() const;
	bool GetWidthFitToChildren() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIHorizontalLayout">();
	}
	static class UUIHorizontalLayout* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIHorizontalLayout>();
	}
};
static_assert(alignof(UUIHorizontalLayout) == 0x000008, "Wrong alignment on UUIHorizontalLayout");
static_assert(sizeof(UUIHorizontalLayout) == 0x0001C0, "Wrong size on UUIHorizontalLayout");
static_assert(offsetof(UUIHorizontalLayout, Padding) == 0x000190, "Member 'UUIHorizontalLayout::Padding' has a wrong offset!");
static_assert(offsetof(UUIHorizontalLayout, Spacing) == 0x0001A0, "Member 'UUIHorizontalLayout::Spacing' has a wrong offset!");
static_assert(offsetof(UUIHorizontalLayout, Align) == 0x0001A4, "Member 'UUIHorizontalLayout::Align' has a wrong offset!");
static_assert(offsetof(UUIHorizontalLayout, ExpendChildrenWidth) == 0x0001A5, "Member 'UUIHorizontalLayout::ExpendChildrenWidth' has a wrong offset!");
static_assert(offsetof(UUIHorizontalLayout, ExpendChildrenHeight) == 0x0001A6, "Member 'UUIHorizontalLayout::ExpendChildrenHeight' has a wrong offset!");
static_assert(offsetof(UUIHorizontalLayout, WidthFitToChildren) == 0x0001A7, "Member 'UUIHorizontalLayout::WidthFitToChildren' has a wrong offset!");
static_assert(offsetof(UUIHorizontalLayout, HeightFitToChildren) == 0x0001A8, "Member 'UUIHorizontalLayout::HeightFitToChildren' has a wrong offset!");

// Class LGUI.UIInputAdaptZone
// 0x0028 (0x0128 - 0x0100)
class UUIInputAdaptZone final : public ULGUIBehaviour
{
public:
	struct FMargin                                AdaptMargin;                                       // 0x0100(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_128E[0x10];                                    // 0x0110(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bMouseKeyboardAdapt;                               // 0x0120(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bGamepadAdapt;                                     // 0x0121(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_128F[0x6];                                     // 0x0122(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMouseMoved(float Value);
	void OnPressAnyKey(const struct FKey& Key);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIInputAdaptZone">();
	}
	static class UUIInputAdaptZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIInputAdaptZone>();
	}
};
static_assert(alignof(UUIInputAdaptZone) == 0x000008, "Wrong alignment on UUIInputAdaptZone");
static_assert(sizeof(UUIInputAdaptZone) == 0x000128, "Wrong size on UUIInputAdaptZone");
static_assert(offsetof(UUIInputAdaptZone, AdaptMargin) == 0x000100, "Member 'UUIInputAdaptZone::AdaptMargin' has a wrong offset!");
static_assert(offsetof(UUIInputAdaptZone, bMouseKeyboardAdapt) == 0x000120, "Member 'UUIInputAdaptZone::bMouseKeyboardAdapt' has a wrong offset!");
static_assert(offsetof(UUIInputAdaptZone, bGamepadAdapt) == 0x000121, "Member 'UUIInputAdaptZone::bGamepadAdapt' has a wrong offset!");

// Class LGUI.UIInturnAnimController
// 0x0088 (0x0148 - 0x00C0)
class UUIInturnAnimController final : public UActorComponent
{
public:
	TDelegate<void()>                             OnFinish;                                          // 0x00C0(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	class FString                                 AnimName;                                          // 0x00E8(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartTime;                                         // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayInSameTime;                                   // 0x00FC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1290[0x3];                                     // 0x00FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Interval;                                          // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CustomAnimDuration;                                // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bItemDefaultActive;                                // 0x0108(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bItemDefaultAlphaZero;                             // 0x0109(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1291[0x2];                                     // 0x010A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayFromIndex;                                     // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1292[0x38];                                    // 0x0110(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnItemAnimFinish();
	void Play(const class FString& NewAnimName, int32 AssignNum, bool bIsScrollViewItem);
	void PlayInEditor();
	void PlayWithActors(const TArray<TWeakObjectPtr<class AUIBaseActor>>& SpecChildren, const class FString& NewAnimName);
	void PlayWithItems(const TArray<class UUIItem*>& SpecChildren, const class FString& NewAnimName);
	void SetItemDefaultAlphaZero(bool IsItemDefaultAlphaZero);
	void Stop();

	bool GetItemDefaultAlphaZero() const;
	bool IsPlaying() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIInturnAnimController">();
	}
	static class UUIInturnAnimController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIInturnAnimController>();
	}
};
static_assert(alignof(UUIInturnAnimController) == 0x000008, "Wrong alignment on UUIInturnAnimController");
static_assert(sizeof(UUIInturnAnimController) == 0x000148, "Wrong size on UUIInturnAnimController");
static_assert(offsetof(UUIInturnAnimController, OnFinish) == 0x0000C0, "Member 'UUIInturnAnimController::OnFinish' has a wrong offset!");
static_assert(offsetof(UUIInturnAnimController, AnimName) == 0x0000E8, "Member 'UUIInturnAnimController::AnimName' has a wrong offset!");
static_assert(offsetof(UUIInturnAnimController, StartTime) == 0x0000F8, "Member 'UUIInturnAnimController::StartTime' has a wrong offset!");
static_assert(offsetof(UUIInturnAnimController, bPlayInSameTime) == 0x0000FC, "Member 'UUIInturnAnimController::bPlayInSameTime' has a wrong offset!");
static_assert(offsetof(UUIInturnAnimController, Interval) == 0x000100, "Member 'UUIInturnAnimController::Interval' has a wrong offset!");
static_assert(offsetof(UUIInturnAnimController, CustomAnimDuration) == 0x000104, "Member 'UUIInturnAnimController::CustomAnimDuration' has a wrong offset!");
static_assert(offsetof(UUIInturnAnimController, bItemDefaultActive) == 0x000108, "Member 'UUIInturnAnimController::bItemDefaultActive' has a wrong offset!");
static_assert(offsetof(UUIInturnAnimController, bItemDefaultAlphaZero) == 0x000109, "Member 'UUIInturnAnimController::bItemDefaultAlphaZero' has a wrong offset!");
static_assert(offsetof(UUIInturnAnimController, PlayFromIndex) == 0x00010C, "Member 'UUIInturnAnimController::PlayFromIndex' has a wrong offset!");

// Class LGUI.UILayoutElement
// 0x0018 (0x0118 - 0x0100)
class UUILayoutElement final : public ULGUIBehaviour
{
public:
	class UUILayoutBase*                          ParentLayout;                                      // 0x0100(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELayoutElementType                            LayoutElementType;                                 // 0x0108(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1294[0x3];                                     // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConstantSize;                                      // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RatioSize;                                         // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1295[0x4];                                     // 0x0114(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetConstantSize(float Value);
	void SetLayoutType(ELayoutElementType InType);
	void SetRatioSize(float Value);

	float GetConstantSize() const;
	bool GetIgnoreLayout() const;
	ELayoutElementType GetLayoutType() const;
	float GetRatioSize() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILayoutElement">();
	}
	static class UUILayoutElement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILayoutElement>();
	}
};
static_assert(alignof(UUILayoutElement) == 0x000008, "Wrong alignment on UUILayoutElement");
static_assert(sizeof(UUILayoutElement) == 0x000118, "Wrong size on UUILayoutElement");
static_assert(offsetof(UUILayoutElement, ParentLayout) == 0x000100, "Member 'UUILayoutElement::ParentLayout' has a wrong offset!");
static_assert(offsetof(UUILayoutElement, LayoutElementType) == 0x000108, "Member 'UUILayoutElement::LayoutElementType' has a wrong offset!");
static_assert(offsetof(UUILayoutElement, ConstantSize) == 0x00010C, "Member 'UUILayoutElement::ConstantSize' has a wrong offset!");
static_assert(offsetof(UUILayoutElement, RatioSize) == 0x000110, "Member 'UUILayoutElement::RatioSize' has a wrong offset!");

// Class LGUI.UILoopScrollViewComponent
// 0x01B0 (0x03C8 - 0x0218)
class UUILoopScrollViewComponent final : public UUIScrollViewWithScrollbarComponent
{
public:
	uint8                                         Pad_1296[0x38];                                    // 0x0218(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AUIBaseActor>>    GridArray;                                         // 0x0250(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1297[0x50];                                    // 0x0260(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AUIBaseActor>            TemplateGrid;                                      // 0x02B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         DisplayGridNum;                                    // 0x02B8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         TotalGridNum;                                      // 0x02BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          GridDefaultUIActive;                               // 0x02C0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsGridShrinkStrech;                                // 0x02C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1298[0x2];                                     // 0x02C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpacingHorizontal;                                 // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpacingVertical;                                   // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PaddingHorizontal;                                 // 0x02CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PaddingVertical;                                   // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceSingleLine;                                  // 0x02D4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1299[0x3];                                     // 0x02D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GridAnimationStartTime;                            // 0x02D8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GridAnimationInterval;                             // 0x02DC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInAnimation;                                     // 0x02E0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129A[0x7];                                     // 0x02E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(int32 DisplayIndex, class AUIBaseActor* Actor)> OnGridCreate;                                      // 0x02E8(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(int32 StartIndex, int32 EndIndex)> OnGridsUpdate;                                     // 0x0310(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnDestroyCallBack;                                 // 0x0338(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_129B[0x50];                                    // 0x0360(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NavigationIndex;                                   // 0x03B0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_129C[0x14];                                    // 0x03B4(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Refresh();
	void RefreshByData(class AUIBaseActor* UIItem, int32 GridNum, bool KeepContentPosition);
	void ResetPreview();
	void ScrollToGridIndex(int32 GridIndex);
	void ScrollToNextLine(bool bReversed);
	void SetGridAnimationInterval(float Value);
	void SetGridAnimationStartTime(float Value);
	void SetInAnimation(bool State);
	void SetNavigationIndex(int32 GridIndex);

	class AUIBaseActor* GetGrid(int32 GridIndex) const;
	float GetGridAnimationInterval() const;
	float GetGridAnimationStartTime() const;
	bool GetInAnimation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UILoopScrollViewComponent">();
	}
	static class UUILoopScrollViewComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUILoopScrollViewComponent>();
	}
};
static_assert(alignof(UUILoopScrollViewComponent) == 0x000008, "Wrong alignment on UUILoopScrollViewComponent");
static_assert(sizeof(UUILoopScrollViewComponent) == 0x0003C8, "Wrong size on UUILoopScrollViewComponent");
static_assert(offsetof(UUILoopScrollViewComponent, GridArray) == 0x000250, "Member 'UUILoopScrollViewComponent::GridArray' has a wrong offset!");
static_assert(offsetof(UUILoopScrollViewComponent, TemplateGrid) == 0x0002B0, "Member 'UUILoopScrollViewComponent::TemplateGrid' has a wrong offset!");
static_assert(offsetof(UUILoopScrollViewComponent, DisplayGridNum) == 0x0002B8, "Member 'UUILoopScrollViewComponent::DisplayGridNum' has a wrong offset!");
static_assert(offsetof(UUILoopScrollViewComponent, TotalGridNum) == 0x0002BC, "Member 'UUILoopScrollViewComponent::TotalGridNum' has a wrong offset!");
static_assert(offsetof(UUILoopScrollViewComponent, GridDefaultUIActive) == 0x0002C0, "Member 'UUILoopScrollViewComponent::GridDefaultUIActive' has a wrong offset!");
static_assert(offsetof(UUILoopScrollViewComponent, IsGridShrinkStrech) == 0x0002C1, "Member 'UUILoopScrollViewComponent::IsGridShrinkStrech' has a wrong offset!");
static_assert(offsetof(UUILoopScrollViewComponent, SpacingHorizontal) == 0x0002C4, "Member 'UUILoopScrollViewComponent::SpacingHorizontal' has a wrong offset!");
static_assert(offsetof(UUILoopScrollViewComponent, SpacingVertical) == 0x0002C8, "Member 'UUILoopScrollViewComponent::SpacingVertical' has a wrong offset!");
static_assert(offsetof(UUILoopScrollViewComponent, PaddingHorizontal) == 0x0002CC, "Member 'UUILoopScrollViewComponent::PaddingHorizontal' has a wrong offset!");
static_assert(offsetof(UUILoopScrollViewComponent, PaddingVertical) == 0x0002D0, "Member 'UUILoopScrollViewComponent::PaddingVertical' has a wrong offset!");
static_assert(offsetof(UUILoopScrollViewComponent, bForceSingleLine) == 0x0002D4, "Member 'UUILoopScrollViewComponent::bForceSingleLine' has a wrong offset!");
static_assert(offsetof(UUILoopScrollViewComponent, GridAnimationStartTime) == 0x0002D8, "Member 'UUILoopScrollViewComponent::GridAnimationStartTime' has a wrong offset!");
static_assert(offsetof(UUILoopScrollViewComponent, GridAnimationInterval) == 0x0002DC, "Member 'UUILoopScrollViewComponent::GridAnimationInterval' has a wrong offset!");
static_assert(offsetof(UUILoopScrollViewComponent, IsInAnimation) == 0x0002E0, "Member 'UUILoopScrollViewComponent::IsInAnimation' has a wrong offset!");
static_assert(offsetof(UUILoopScrollViewComponent, OnGridCreate) == 0x0002E8, "Member 'UUILoopScrollViewComponent::OnGridCreate' has a wrong offset!");
static_assert(offsetof(UUILoopScrollViewComponent, OnGridsUpdate) == 0x000310, "Member 'UUILoopScrollViewComponent::OnGridsUpdate' has a wrong offset!");
static_assert(offsetof(UUILoopScrollViewComponent, OnDestroyCallBack) == 0x000338, "Member 'UUILoopScrollViewComponent::OnDestroyCallBack' has a wrong offset!");
static_assert(offsetof(UUILoopScrollViewComponent, NavigationIndex) == 0x0003B0, "Member 'UUILoopScrollViewComponent::NavigationIndex' has a wrong offset!");

// Class LGUI.UINavigationBehaviour
// 0x0008 (0x0108 - 0x0100)
class UUINavigationBehaviour : public ULGUIBehaviour
{
public:
	int32                                         LoopScrollViewGridIndex;                           // 0x0100(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_129F[0x4];                                     // 0x0104(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool OnCheckCanSetNavigationBP();
	bool OnCheckLoopScrollChangeNavigationBP();
	void OnNotifyInteractiveBP();
	void OnNotifyNavigationEnterBP(class ULGUIPointerEventData* EventData);
	void OnNotifyNavigationSelectBP(class ULGUIPointerEventData* EventData);
	void OnNotifyNotInteractiveBP();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINavigationBehaviour">();
	}
	static class UUINavigationBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINavigationBehaviour>();
	}
};
static_assert(alignof(UUINavigationBehaviour) == 0x000008, "Wrong alignment on UUINavigationBehaviour");
static_assert(sizeof(UUINavigationBehaviour) == 0x000108, "Wrong size on UUINavigationBehaviour");
static_assert(offsetof(UUINavigationBehaviour, LoopScrollViewGridIndex) == 0x000100, "Member 'UUINavigationBehaviour::LoopScrollViewGridIndex' has a wrong offset!");

// Class LGUI.UINavigationTextChangeListener
// 0x0008 (0x0108 - 0x0100)
class UUINavigationTextChangeListener : public ULGUIBehaviour
{
public:
	class AActor*                                 TextActor;                                         // 0x0100(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnNotifyTextChangeBP(const class FString& NotifyText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINavigationTextChangeListener">();
	}
	static class UUINavigationTextChangeListener* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUINavigationTextChangeListener>();
	}
};
static_assert(alignof(UUINavigationTextChangeListener) == 0x000008, "Wrong alignment on UUINavigationTextChangeListener");
static_assert(sizeof(UUINavigationTextChangeListener) == 0x000108, "Wrong size on UUINavigationTextChangeListener");
static_assert(offsetof(UUINavigationTextChangeListener, TextActor) == 0x000100, "Member 'UUINavigationTextChangeListener::TextActor' has a wrong offset!");

// Class LGUI.UINiagaraActor
// 0x0008 (0x0398 - 0x0390)
class AUINiagaraActor final : public AUIBaseActor
{
public:
	class UUINiagara*                             UINiagara;                                         // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ActivateSystem();
	void DeactivateSystem();
	void SwitchToStop();

	class UUINiagara* GetUINiagara() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UINiagaraActor">();
	}
	static class AUINiagaraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUINiagaraActor>();
	}
};
static_assert(alignof(AUINiagaraActor) == 0x000008, "Wrong alignment on AUINiagaraActor");
static_assert(sizeof(AUINiagaraActor) == 0x000398, "Wrong size on AUINiagaraActor");
static_assert(offsetof(AUINiagaraActor, UINiagara) == 0x000390, "Member 'AUINiagaraActor::UINiagara' has a wrong offset!");

// Class LGUI.UIPolygonActor
// 0x0008 (0x0398 - 0x0390)
class AUIPolygonActor final : public AUIBaseActor
{
public:
	class UUIPolygon*                             UIPolygon;                                         // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPolygonActor">();
	}
	static class AUIPolygonActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIPolygonActor>();
	}
};
static_assert(alignof(AUIPolygonActor) == 0x000008, "Wrong alignment on AUIPolygonActor");
static_assert(sizeof(AUIPolygonActor) == 0x000398, "Wrong size on AUIPolygonActor");
static_assert(offsetof(AUIPolygonActor, UIPolygon) == 0x000390, "Member 'AUIPolygonActor::UIPolygon' has a wrong offset!");

// Class LGUI.UIPolygonLineActor
// 0x0008 (0x0398 - 0x0390)
class AUIPolygonLineActor final : public AUIBaseActor
{
public:
	class UUIPolygonLine*                         UIPolygonLine;                                     // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPolygonLineActor">();
	}
	static class AUIPolygonLineActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIPolygonLineActor>();
	}
};
static_assert(alignof(AUIPolygonLineActor) == 0x000008, "Wrong alignment on AUIPolygonLineActor");
static_assert(sizeof(AUIPolygonLineActor) == 0x000398, "Wrong size on AUIPolygonLineActor");
static_assert(offsetof(AUIPolygonLineActor, UIPolygonLine) == 0x000390, "Member 'AUIPolygonLineActor::UIPolygonLine' has a wrong offset!");

// Class LGUI.UIRing
// 0x0020 (0x07A0 - 0x0780)
class UUIRing final : public UUI2DLineRendererBase
{
public:
	float                                         StartAngle;                                        // 0x0780(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndAngle;                                          // 0x0784(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Segment;                                           // 0x0788(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12A0[0x4];                                     // 0x078C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector2D>                      CurrentPointArray;                                 // 0x0790(0x0010)(Edit, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	class ULTweener* EndAngleTo(float EndValue, float Duration, float Delay, ELTweenEase EaseType);
	void SetEndAngle(float NewValue);
	void SetSegment(int32 NewValue);
	void SetStartAngle(float NewValue);
	class ULTweener* StartAngleTo(float EndValue, float Duration, float Delay, ELTweenEase EaseType);

	float GetEndAngle() const;
	int32 GetSegment() const;
	float GetStartAngle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIRing">();
	}
	static class UUIRing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIRing>();
	}
};
static_assert(alignof(UUIRing) == 0x000010, "Wrong alignment on UUIRing");
static_assert(sizeof(UUIRing) == 0x0007A0, "Wrong size on UUIRing");
static_assert(offsetof(UUIRing, StartAngle) == 0x000780, "Member 'UUIRing::StartAngle' has a wrong offset!");
static_assert(offsetof(UUIRing, EndAngle) == 0x000784, "Member 'UUIRing::EndAngle' has a wrong offset!");
static_assert(offsetof(UUIRing, Segment) == 0x000788, "Member 'UUIRing::Segment' has a wrong offset!");
static_assert(offsetof(UUIRing, CurrentPointArray) == 0x000790, "Member 'UUIRing::CurrentPointArray' has a wrong offset!");

// Class LGUI.UIRoundedLayout
// 0x0010 (0x0180 - 0x0170)
class UUIRoundedLayout final : public UUILayoutBase
{
public:
	float                                         Radius;                                            // 0x0170(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartAngle;                                        // 0x0174(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndAngle;                                          // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSetChildAngle;                                    // 0x017C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12A3[0x3];                                     // 0x017D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIRoundedLayout">();
	}
	static class UUIRoundedLayout* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIRoundedLayout>();
	}
};
static_assert(alignof(UUIRoundedLayout) == 0x000008, "Wrong alignment on UUIRoundedLayout");
static_assert(sizeof(UUIRoundedLayout) == 0x000180, "Wrong size on UUIRoundedLayout");
static_assert(offsetof(UUIRoundedLayout, Radius) == 0x000170, "Member 'UUIRoundedLayout::Radius' has a wrong offset!");
static_assert(offsetof(UUIRoundedLayout, StartAngle) == 0x000174, "Member 'UUIRoundedLayout::StartAngle' has a wrong offset!");
static_assert(offsetof(UUIRoundedLayout, EndAngle) == 0x000178, "Member 'UUIRoundedLayout::EndAngle' has a wrong offset!");
static_assert(offsetof(UUIRoundedLayout, bSetChildAngle) == 0x00017C, "Member 'UUIRoundedLayout::bSetChildAngle' has a wrong offset!");

// Class LGUI.UIScrollbarComponent
// 0x0080 (0x0450 - 0x03D0)
class UUIScrollbarComponent final : public UUISelectableComponent
{
public:
	uint8                                         Pad_12A4[0x8];                                     // 0x03D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x03D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Size;                                              // 0x03DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AUIBaseActor>            HandleActor;                                       // 0x03E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUIScrollbarDirectionType                     DirectionType;                                     // 0x03E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12A5[0x3];                                     // 0x03E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UUIItem>                 Handle;                                            // 0x03EC(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UUIItem>                 HandleArea;                                        // 0x03F4(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12A6[0x1C];                                    // 0x03FC(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUIDrawableEvent                     OnValueChange;                                     // 0x0418(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  ScrollViewBackgroundActor;                         // 0x0430(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UUIItem>                 ScrollViewBackgroundComponent;                     // 0x0438(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MainScrollbar;                                     // 0x0440(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12A7[0x3];                                     // 0x0441(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ViewId;                                            // 0x0444(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12A8[0x8];                                     // 0x0448(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ResetScrollbarDelegate();
	static void SetScrollbarDelegate(const TDelegate<void(class UUIScrollbarComponent* ScrollbarComponent, bool AtiveOrInactive)>& Delegate);

	void ChangeSchedule(ELGUINavigationDirection InDirection);
	struct FLGUIDelegateHandleWrapper RegisterSlideEvent(const TDelegate<void(float InFloat)>& InDelegate);
	void SetSize(float InSize);
	void SetValue(float InValue, bool FireEvent);
	void SetValueAndSize(float InValue, float InSize, bool FireEvent);
	void UnregisterSlideEvent(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);

	float GetSize() const;
	float GetValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIScrollbarComponent">();
	}
	static class UUIScrollbarComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIScrollbarComponent>();
	}
};
static_assert(alignof(UUIScrollbarComponent) == 0x000008, "Wrong alignment on UUIScrollbarComponent");
static_assert(sizeof(UUIScrollbarComponent) == 0x000450, "Wrong size on UUIScrollbarComponent");
static_assert(offsetof(UUIScrollbarComponent, Value) == 0x0003D8, "Member 'UUIScrollbarComponent::Value' has a wrong offset!");
static_assert(offsetof(UUIScrollbarComponent, Size) == 0x0003DC, "Member 'UUIScrollbarComponent::Size' has a wrong offset!");
static_assert(offsetof(UUIScrollbarComponent, HandleActor) == 0x0003E0, "Member 'UUIScrollbarComponent::HandleActor' has a wrong offset!");
static_assert(offsetof(UUIScrollbarComponent, DirectionType) == 0x0003E8, "Member 'UUIScrollbarComponent::DirectionType' has a wrong offset!");
static_assert(offsetof(UUIScrollbarComponent, Handle) == 0x0003EC, "Member 'UUIScrollbarComponent::Handle' has a wrong offset!");
static_assert(offsetof(UUIScrollbarComponent, HandleArea) == 0x0003F4, "Member 'UUIScrollbarComponent::HandleArea' has a wrong offset!");
static_assert(offsetof(UUIScrollbarComponent, OnValueChange) == 0x000418, "Member 'UUIScrollbarComponent::OnValueChange' has a wrong offset!");
static_assert(offsetof(UUIScrollbarComponent, ScrollViewBackgroundActor) == 0x000430, "Member 'UUIScrollbarComponent::ScrollViewBackgroundActor' has a wrong offset!");
static_assert(offsetof(UUIScrollbarComponent, ScrollViewBackgroundComponent) == 0x000438, "Member 'UUIScrollbarComponent::ScrollViewBackgroundComponent' has a wrong offset!");
static_assert(offsetof(UUIScrollbarComponent, MainScrollbar) == 0x000440, "Member 'UUIScrollbarComponent::MainScrollbar' has a wrong offset!");
static_assert(offsetof(UUIScrollbarComponent, ViewId) == 0x000444, "Member 'UUIScrollbarComponent::ViewId' has a wrong offset!");

// Class LGUI.UISelectableButtonComponent
// 0x0008 (0x05E8 - 0x05E0)
class UUISelectableButtonComponent final : public UUIButtonComponent
{
public:
	uint8                                         Pad_12AB[0x8];                                     // 0x05E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetForceSelect(bool ForceSelect);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISelectableButtonComponent">();
	}
	static class UUISelectableButtonComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISelectableButtonComponent>();
	}
};
static_assert(alignof(UUISelectableButtonComponent) == 0x000008, "Wrong alignment on UUISelectableButtonComponent");
static_assert(sizeof(UUISelectableButtonComponent) == 0x0005E8, "Wrong size on UUISelectableButtonComponent");

// Class LGUI.UISizeControlByAspectRatioHelper
// 0x0008 (0x0108 - 0x0100)
class UUISizeControlByAspectRatioHelper final : public ULGUIBehaviour
{
public:
	TWeakObjectPtr<class UUISizeControlByAspectRatio> TargetComp;                                        // 0x0100(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISizeControlByAspectRatioHelper">();
	}
	static class UUISizeControlByAspectRatioHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISizeControlByAspectRatioHelper>();
	}
};
static_assert(alignof(UUISizeControlByAspectRatioHelper) == 0x000008, "Wrong alignment on UUISizeControlByAspectRatioHelper");
static_assert(sizeof(UUISizeControlByAspectRatioHelper) == 0x000108, "Wrong size on UUISizeControlByAspectRatioHelper");
static_assert(offsetof(UUISizeControlByAspectRatioHelper, TargetComp) == 0x000100, "Member 'UUISizeControlByAspectRatioHelper::TargetComp' has a wrong offset!");

// Class LGUI.UISizeControlByOtherHelper
// 0x0008 (0x0108 - 0x0100)
class UUISizeControlByOtherHelper final : public ULGUIBehaviour
{
public:
	TWeakObjectPtr<class UUISizeControlByOther>   TargetComp;                                        // 0x0100(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISizeControlByOtherHelper">();
	}
	static class UUISizeControlByOtherHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISizeControlByOtherHelper>();
	}
};
static_assert(alignof(UUISizeControlByOtherHelper) == 0x000008, "Wrong alignment on UUISizeControlByOtherHelper");
static_assert(sizeof(UUISizeControlByOtherHelper) == 0x000108, "Wrong size on UUISizeControlByOtherHelper");
static_assert(offsetof(UUISizeControlByOtherHelper, TargetComp) == 0x000100, "Member 'UUISizeControlByOtherHelper::TargetComp' has a wrong offset!");

// Class LGUI.UISliderComponent
// 0x00F8 (0x04C8 - 0x03D0)
class UUISliderComponent final : public UUISelectableComponent
{
public:
	uint8                                         Pad_12AC[0x8];                                     // 0x03D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x03D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinValue;                                          // 0x03DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxValue;                                          // 0x03E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          WholeNumbers;                                      // 0x03E4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12AD[0x3];                                     // 0x03E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AUIBaseActor>            FillActor;                                         // 0x03E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AUIBaseActor>            HandleActor;                                       // 0x03F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUISliderDirectionType                        DirectionType;                                     // 0x03F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12AE[0x7];                                     // 0x03F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(float InFloat)>                OnValueChangeCb;                                   // 0x0400(0x0028)(Edit, ZeroConstructor, InstancedReference, Protected, NativeAccessSpecifierProtected)
	TDelegate<void()>                             OnEndDragCb;                                       // 0x0428(0x0028)(Edit, ZeroConstructor, InstancedReference, Protected, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          DragBeginAudioEvent;                               // 0x0450(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          DragEndAudioEvent;                                 // 0x0458(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          DraggingAudioEvent;                                // 0x0460(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DraggingAudioEventInterval;                        // 0x0468(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UUIItem>                 Fill;                                              // 0x046C(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UUIItem>                 FillArea;                                          // 0x0474(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UUIItem>                 Handle;                                            // 0x047C(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UUIItem>                 HandleArea;                                        // 0x0484(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12AF[0x1C];                                    // 0x048C(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUIDrawableEvent                     OnValueChange;                                     // 0x04A8(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_12B0[0x8];                                     // 0x04C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FLGUIDelegateHandleWrapper RegisterSlideEvent(const TDelegate<void(float InFloat)>& InDelegate);
	void SetMaxValue(float InMaxValue, bool KeepRelativeValue, bool FireEvent);
	void SetMinValue(float InMinValue, bool KeepRelativeValue, bool FireEvent);
	void SetProgressIncrement(float IncrementValue, bool NeedRound);
	void SetValue(float InValue, bool FireEvent);
	void UnregisterSlideEvent(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);

	float GetMaxValue() const;
	float GetMinValue() const;
	float GetValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISliderComponent">();
	}
	static class UUISliderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISliderComponent>();
	}
};
static_assert(alignof(UUISliderComponent) == 0x000008, "Wrong alignment on UUISliderComponent");
static_assert(sizeof(UUISliderComponent) == 0x0004C8, "Wrong size on UUISliderComponent");
static_assert(offsetof(UUISliderComponent, Value) == 0x0003D8, "Member 'UUISliderComponent::Value' has a wrong offset!");
static_assert(offsetof(UUISliderComponent, MinValue) == 0x0003DC, "Member 'UUISliderComponent::MinValue' has a wrong offset!");
static_assert(offsetof(UUISliderComponent, MaxValue) == 0x0003E0, "Member 'UUISliderComponent::MaxValue' has a wrong offset!");
static_assert(offsetof(UUISliderComponent, WholeNumbers) == 0x0003E4, "Member 'UUISliderComponent::WholeNumbers' has a wrong offset!");
static_assert(offsetof(UUISliderComponent, FillActor) == 0x0003E8, "Member 'UUISliderComponent::FillActor' has a wrong offset!");
static_assert(offsetof(UUISliderComponent, HandleActor) == 0x0003F0, "Member 'UUISliderComponent::HandleActor' has a wrong offset!");
static_assert(offsetof(UUISliderComponent, DirectionType) == 0x0003F8, "Member 'UUISliderComponent::DirectionType' has a wrong offset!");
static_assert(offsetof(UUISliderComponent, OnValueChangeCb) == 0x000400, "Member 'UUISliderComponent::OnValueChangeCb' has a wrong offset!");
static_assert(offsetof(UUISliderComponent, OnEndDragCb) == 0x000428, "Member 'UUISliderComponent::OnEndDragCb' has a wrong offset!");
static_assert(offsetof(UUISliderComponent, DragBeginAudioEvent) == 0x000450, "Member 'UUISliderComponent::DragBeginAudioEvent' has a wrong offset!");
static_assert(offsetof(UUISliderComponent, DragEndAudioEvent) == 0x000458, "Member 'UUISliderComponent::DragEndAudioEvent' has a wrong offset!");
static_assert(offsetof(UUISliderComponent, DraggingAudioEvent) == 0x000460, "Member 'UUISliderComponent::DraggingAudioEvent' has a wrong offset!");
static_assert(offsetof(UUISliderComponent, DraggingAudioEventInterval) == 0x000468, "Member 'UUISliderComponent::DraggingAudioEventInterval' has a wrong offset!");
static_assert(offsetof(UUISliderComponent, Fill) == 0x00046C, "Member 'UUISliderComponent::Fill' has a wrong offset!");
static_assert(offsetof(UUISliderComponent, FillArea) == 0x000474, "Member 'UUISliderComponent::FillArea' has a wrong offset!");
static_assert(offsetof(UUISliderComponent, Handle) == 0x00047C, "Member 'UUISliderComponent::Handle' has a wrong offset!");
static_assert(offsetof(UUISliderComponent, HandleArea) == 0x000484, "Member 'UUISliderComponent::HandleArea' has a wrong offset!");
static_assert(offsetof(UUISliderComponent, OnValueChange) == 0x0004A8, "Member 'UUISliderComponent::OnValueChange' has a wrong offset!");

// Class LGUI.UISpineRenderable
// 0x03B0 (0x0910 - 0x0560)
class UUISpineRenderable final : public UUIBaseRenderable
{
public:
	float                                         DepthOffset;                                       // 0x0560(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TextureParameterName;                              // 0x0564(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdjustSizeWithAnimation;                          // 0x0570(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12B5[0x17];                                    // 0x0571(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	class USpineSkeletonDataAsset*                CurrSkeletonData;                                  // 0x0588(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12B6[0x200];                                   // 0x0590(0x0200)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ELGUICanvasClipType, class UMaterialInterface*> NormalBlendMaterials;                              // 0x0790(0x0050)(Edit, NativeAccessSpecifierPrivate)
	TMap<ELGUICanvasClipType, class UMaterialInterface*> AdditiveBlendMaterials;                            // 0x07E0(0x0050)(Edit, NativeAccessSpecifierPrivate)
	TMap<ELGUICanvasClipType, class UMaterialInterface*> MultiplyBlendMaterials;                            // 0x0830(0x0050)(Edit, NativeAccessSpecifierPrivate)
	TMap<ELGUICanvasClipType, class UMaterialInterface*> ScreenBlendMaterials;                              // 0x0880(0x0050)(Edit, NativeAccessSpecifierPrivate)
	TArray<class UMaterialInstanceDynamic*>       AtlasNormalBlendMaterials;                         // 0x08D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UMaterialInstanceDynamic*>       AtlasAdditiveBlendMaterials;                       // 0x08E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UMaterialInstanceDynamic*>       AtlasMultiplyBlendMaterials;                       // 0x08F0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UMaterialInstanceDynamic*>       AtlasScreenBlendMaterials;                         // 0x0900(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void AdjustSize();
	void AfterSkeletonUpdate(class USpineSkeletonComponent* SkeletonComponent);

	int32 GetMeshesNum() const;
	int32 GetTotalVerticeNum() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISpineRenderable">();
	}
	static class UUISpineRenderable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISpineRenderable>();
	}
};
static_assert(alignof(UUISpineRenderable) == 0x000010, "Wrong alignment on UUISpineRenderable");
static_assert(sizeof(UUISpineRenderable) == 0x000910, "Wrong size on UUISpineRenderable");
static_assert(offsetof(UUISpineRenderable, DepthOffset) == 0x000560, "Member 'UUISpineRenderable::DepthOffset' has a wrong offset!");
static_assert(offsetof(UUISpineRenderable, TextureParameterName) == 0x000564, "Member 'UUISpineRenderable::TextureParameterName' has a wrong offset!");
static_assert(offsetof(UUISpineRenderable, bAdjustSizeWithAnimation) == 0x000570, "Member 'UUISpineRenderable::bAdjustSizeWithAnimation' has a wrong offset!");
static_assert(offsetof(UUISpineRenderable, CurrSkeletonData) == 0x000588, "Member 'UUISpineRenderable::CurrSkeletonData' has a wrong offset!");
static_assert(offsetof(UUISpineRenderable, NormalBlendMaterials) == 0x000790, "Member 'UUISpineRenderable::NormalBlendMaterials' has a wrong offset!");
static_assert(offsetof(UUISpineRenderable, AdditiveBlendMaterials) == 0x0007E0, "Member 'UUISpineRenderable::AdditiveBlendMaterials' has a wrong offset!");
static_assert(offsetof(UUISpineRenderable, MultiplyBlendMaterials) == 0x000830, "Member 'UUISpineRenderable::MultiplyBlendMaterials' has a wrong offset!");
static_assert(offsetof(UUISpineRenderable, ScreenBlendMaterials) == 0x000880, "Member 'UUISpineRenderable::ScreenBlendMaterials' has a wrong offset!");
static_assert(offsetof(UUISpineRenderable, AtlasNormalBlendMaterials) == 0x0008D0, "Member 'UUISpineRenderable::AtlasNormalBlendMaterials' has a wrong offset!");
static_assert(offsetof(UUISpineRenderable, AtlasAdditiveBlendMaterials) == 0x0008E0, "Member 'UUISpineRenderable::AtlasAdditiveBlendMaterials' has a wrong offset!");
static_assert(offsetof(UUISpineRenderable, AtlasMultiplyBlendMaterials) == 0x0008F0, "Member 'UUISpineRenderable::AtlasMultiplyBlendMaterials' has a wrong offset!");
static_assert(offsetof(UUISpineRenderable, AtlasScreenBlendMaterials) == 0x000900, "Member 'UUISpineRenderable::AtlasScreenBlendMaterials' has a wrong offset!");

// Class LGUI.UISpriteActor
// 0x0008 (0x0398 - 0x0390)
class AUISpriteActor final : public AUIBaseActor
{
public:
	class UUISprite*                              UISprite;                                          // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISpriteActor">();
	}
	static class AUISpriteActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUISpriteActor>();
	}
};
static_assert(alignof(AUISpriteActor) == 0x000008, "Wrong alignment on AUISpriteActor");
static_assert(sizeof(AUISpriteActor) == 0x000398, "Wrong size on AUISpriteActor");
static_assert(offsetof(AUISpriteActor, UISprite) == 0x000390, "Member 'AUISpriteActor::UISprite' has a wrong offset!");

// Class LGUI.UISpriteSequencePlayer
// 0x0018 (0x00F8 - 0x00E0)
class UUISpriteSequencePlayer final : public ULGUIImageSequencePlayer
{
public:
	TWeakObjectPtr<class UUISpriteBase>           Sprite;                                            // 0x00E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ULGUISpriteData_BaseObject*>     SpriteSequence;                                    // 0x00E8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void SetSpriteSequence(const TArray<class ULGUISpriteData_BaseObject*>& Value);

	const TArray<class ULGUISpriteData_BaseObject*> GetSpriteSequence() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISpriteSequencePlayer">();
	}
	static class UUISpriteSequencePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISpriteSequencePlayer>();
	}
};
static_assert(alignof(UUISpriteSequencePlayer) == 0x000008, "Wrong alignment on UUISpriteSequencePlayer");
static_assert(sizeof(UUISpriteSequencePlayer) == 0x0000F8, "Wrong size on UUISpriteSequencePlayer");
static_assert(offsetof(UUISpriteSequencePlayer, Sprite) == 0x0000E0, "Member 'UUISpriteSequencePlayer::Sprite' has a wrong offset!");
static_assert(offsetof(UUISpriteSequencePlayer, SpriteSequence) == 0x0000E8, "Member 'UUISpriteSequencePlayer::SpriteSequence' has a wrong offset!");

// Class LGUI.SpriteTransitionUtil
// 0x0000 (0x0030 - 0x0030)
class USpriteTransitionUtil final : public UBlueprintFunctionLibrary
{
public:
	static void SetSpriteByTransitionInfo(class UUISprite* Sprite, const struct FSpriteTransitionOfState& Info);
	static void SetSpriteSize(class UUISprite* Sprite, bool bSnapSize, float Width, float Height);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpriteTransitionUtil">();
	}
	static class USpriteTransitionUtil* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpriteTransitionUtil>();
	}
};
static_assert(alignof(USpriteTransitionUtil) == 0x000008, "Wrong alignment on USpriteTransitionUtil");
static_assert(sizeof(USpriteTransitionUtil) == 0x000030, "Wrong size on USpriteTransitionUtil");

// Class LGUI.UIStaticMeshActor
// 0x0008 (0x0398 - 0x0390)
class AUIStaticMeshActor final : public AUIBaseActor
{
public:
	class UUIStaticMesh*                          UIStaticMesh;                                      // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIStaticMeshActor">();
	}
	static class AUIStaticMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIStaticMeshActor>();
	}
};
static_assert(alignof(AUIStaticMeshActor) == 0x000008, "Wrong alignment on AUIStaticMeshActor");
static_assert(sizeof(AUIStaticMeshActor) == 0x000398, "Wrong size on AUIStaticMeshActor");
static_assert(offsetof(AUIStaticMeshActor, UIStaticMesh) == 0x000390, "Member 'AUIStaticMeshActor::UIStaticMesh' has a wrong offset!");

// Class LGUI.UIText
// 0x0330 (0x0A90 - 0x0760)
class UUIText final : public UUIBatchGeometryRenderable
{
public:
	uint8                                         Pad_12B9[0x60];                                    // 0x0758(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class ULGUIFontData_BaseObject*               Font;                                              // 0x07B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 Text;                                              // 0x07C0(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Size;                                              // 0x07D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              SpacePercentage;                                   // 0x07D4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              Space;                                             // 0x07DC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         OutlineSize;                                       // 0x07E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 OutlineColor;                                      // 0x07E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUITextParagraphHorizontalAlign               HAlign;                                            // 0x07EC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUITextParagraphVerticalAlign                 VAlign;                                            // 0x07ED(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUITextOverflowType                           OverflowType;                                      // 0x07EE(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12BA[0x1];                                     // 0x07EF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxWidth;                                          // 0x07F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxHeight;                                         // 0x07F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          AdjustWidth;                                       // 0x07F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          AdjustHeight;                                      // 0x07F9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          NeedCustomerLimitWidth;                            // 0x07FA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12BB[0x1];                                     // 0x07FB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CustomerLimitWidth;                                // 0x07FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUITextFontStyle                              FontStyle;                                         // 0x0800(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          RichText;                                          // 0x0801(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplyAlphaOnRichText;                             // 0x0802(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBestFit;                                          // 0x0803(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAlignCenter;                                      // 0x0804(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreWordRules;                                  // 0x0805(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoEllipsis;                                     // 0x0806(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoEllipsisSplitWord;                            // 0x0807(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12BC[0x4];                                     // 0x0808(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BestFitMinSize;                                    // 0x080C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCalculateOutlineSize;                             // 0x0810(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12BD[0x7];                                     // 0x0811(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Hyperlinks;                                        // 0x0818(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_12BE[0x8];                                     // 0x0828(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(const class FString& HyperLink)> OnHyperLinkClickCallBack;                          // 0x0830(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_12BF[0x80];                                    // 0x0858(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableTextRenderSystemV2;                         // 0x08D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12C0[0x10F];                                   // 0x08D9(0x010F)(Fixing Size After Last Property [ Dumper-7 ])
	class UUITextClickComponent*                  ClickComponent;                                    // 0x09E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12C1[0x28];                                    // 0x09F0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             OnSelfLanguageChange;                              // 0x0A18(0x0028)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnTextureAsyncLoaded;                              // 0x0A40(0x0028)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NativeAccessSpecifierPublic)
	uint32                                        TranslateId;                                       // 0x0A68(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12C2[0x24];                                    // 0x0A6C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void OnTsLanguageChange();
	static void SetLocalTextDelegate(const TDelegate<void(class FString& TableName, int32 TextKey, class UUIText* UiText)>& Delegate);
	static void SetLocalTextNewDelegate(const TDelegate<void(class FString& TextKey, class UUIText* UiText)>& Delegate);
	static void SetTextTranslateDelegate(const TDelegate<void(class UUIText* UiText)>& Delegate);

	void AddFloatArgs(float Value);
	void AddFormatTableInfo(const class FString& ConfigTableName, int32 Key);
	void AddFormatTableInfoNew(const class FString& Key);
	void AddInt64Args(int64 Value);
	void AddIntArgs(int32 Value);
	void AddStringArgs(const class FString& Value);
	void Clear();
	int32 GetDisplayCharLength();
	int32 GetRealFontSize();
	struct FVector2D GetRealSize();
	int32 GetRenderLineCharNum(int32 Param_Index);
	float GetRenderLineHeight(int32 LineIndex);
	int32 GetRenderLineNum();
	void GetTextLineNumArray(TArray<int32>* OutArray);
	struct FVector2D GetTextRenderSize();
	void OnTextTextureLoaded(const TArray<struct FDynamicAtlasSlotManagedHandle>& ManagedHandle);
	void SetAdjustHeight(bool NewAdjustHeight);
	void SetAdjustWidth(bool NewAdjustWidth);
	void SetFont(class ULGUIFontData_BaseObject* NewFont);
	void SetFontSize(float NewSize);
	void SetFontSpace(const struct FVector2D& NewSpace);
	void SetFontSpacePercentage(const struct FVector2D& NewSpace);
	void SetFontStyle(EUITextFontStyle NewFontStyle);
	void SetMaxHeight(int32 NewMaxHeight);
	void SetMaxWidth(int32 NewMaxWidth);
	void SetOverflowType(EUITextOverflowType NewOverflowType);
	void SetParagraphHorizontalAlignment(EUITextParagraphHorizontalAlign NewHAlign);
	void SetParagraphVerticalAlignment(EUITextParagraphVerticalAlign NewVAlign);
	void SetRichText(bool NewRichText);
	void SetText(const class FString& NewText, bool DisableTranslate);
	void ShowText(const class FString& ConfigTableName, int32 Key);
	void ShowTextNew(const class FString& Key);

	bool GetAdjustHeight() const;
	bool GetAdjustWidth() const;
	bool GetAlignCenter() const;
	bool GetAutoEllipsis() const;
	bool GetAutoEllipsisSplitWord() const;
	class ULGUIFontData_BaseObject* GetFont() const;
	struct FColor GetFontOutlineColor() const;
	int32 GetFontOutlineSize() const;
	struct FVector2D GetFontSpace() const;
	struct FVector2D GetFontSpaceFinal() const;
	struct FVector2D GetFontSpacePercentage() const;
	EUITextFontStyle GetFontStyle() const;
	TArray<class FString> GetHyperlinks() const;
	int32 GetMaxHeight() const;
	int32 GetMaxWidth() const;
	EUITextOverflowType GetOverflowType() const;
	bool GetRichText() const;
	float GetSize() const;
	class FString GetText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIText">();
	}
	static class UUIText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIText>();
	}
};
static_assert(alignof(UUIText) == 0x000010, "Wrong alignment on UUIText");
static_assert(sizeof(UUIText) == 0x000A90, "Wrong size on UUIText");
static_assert(offsetof(UUIText, Font) == 0x0007B8, "Member 'UUIText::Font' has a wrong offset!");
static_assert(offsetof(UUIText, Text) == 0x0007C0, "Member 'UUIText::Text' has a wrong offset!");
static_assert(offsetof(UUIText, Size) == 0x0007D0, "Member 'UUIText::Size' has a wrong offset!");
static_assert(offsetof(UUIText, SpacePercentage) == 0x0007D4, "Member 'UUIText::SpacePercentage' has a wrong offset!");
static_assert(offsetof(UUIText, Space) == 0x0007DC, "Member 'UUIText::Space' has a wrong offset!");
static_assert(offsetof(UUIText, OutlineSize) == 0x0007E4, "Member 'UUIText::OutlineSize' has a wrong offset!");
static_assert(offsetof(UUIText, OutlineColor) == 0x0007E8, "Member 'UUIText::OutlineColor' has a wrong offset!");
static_assert(offsetof(UUIText, HAlign) == 0x0007EC, "Member 'UUIText::HAlign' has a wrong offset!");
static_assert(offsetof(UUIText, VAlign) == 0x0007ED, "Member 'UUIText::VAlign' has a wrong offset!");
static_assert(offsetof(UUIText, OverflowType) == 0x0007EE, "Member 'UUIText::OverflowType' has a wrong offset!");
static_assert(offsetof(UUIText, MaxWidth) == 0x0007F0, "Member 'UUIText::MaxWidth' has a wrong offset!");
static_assert(offsetof(UUIText, MaxHeight) == 0x0007F4, "Member 'UUIText::MaxHeight' has a wrong offset!");
static_assert(offsetof(UUIText, AdjustWidth) == 0x0007F8, "Member 'UUIText::AdjustWidth' has a wrong offset!");
static_assert(offsetof(UUIText, AdjustHeight) == 0x0007F9, "Member 'UUIText::AdjustHeight' has a wrong offset!");
static_assert(offsetof(UUIText, NeedCustomerLimitWidth) == 0x0007FA, "Member 'UUIText::NeedCustomerLimitWidth' has a wrong offset!");
static_assert(offsetof(UUIText, CustomerLimitWidth) == 0x0007FC, "Member 'UUIText::CustomerLimitWidth' has a wrong offset!");
static_assert(offsetof(UUIText, FontStyle) == 0x000800, "Member 'UUIText::FontStyle' has a wrong offset!");
static_assert(offsetof(UUIText, RichText) == 0x000801, "Member 'UUIText::RichText' has a wrong offset!");
static_assert(offsetof(UUIText, bApplyAlphaOnRichText) == 0x000802, "Member 'UUIText::bApplyAlphaOnRichText' has a wrong offset!");
static_assert(offsetof(UUIText, bBestFit) == 0x000803, "Member 'UUIText::bBestFit' has a wrong offset!");
static_assert(offsetof(UUIText, bAlignCenter) == 0x000804, "Member 'UUIText::bAlignCenter' has a wrong offset!");
static_assert(offsetof(UUIText, bIgnoreWordRules) == 0x000805, "Member 'UUIText::bIgnoreWordRules' has a wrong offset!");
static_assert(offsetof(UUIText, bAutoEllipsis) == 0x000806, "Member 'UUIText::bAutoEllipsis' has a wrong offset!");
static_assert(offsetof(UUIText, bAutoEllipsisSplitWord) == 0x000807, "Member 'UUIText::bAutoEllipsisSplitWord' has a wrong offset!");
static_assert(offsetof(UUIText, BestFitMinSize) == 0x00080C, "Member 'UUIText::BestFitMinSize' has a wrong offset!");
static_assert(offsetof(UUIText, bCalculateOutlineSize) == 0x000810, "Member 'UUIText::bCalculateOutlineSize' has a wrong offset!");
static_assert(offsetof(UUIText, Hyperlinks) == 0x000818, "Member 'UUIText::Hyperlinks' has a wrong offset!");
static_assert(offsetof(UUIText, OnHyperLinkClickCallBack) == 0x000830, "Member 'UUIText::OnHyperLinkClickCallBack' has a wrong offset!");
static_assert(offsetof(UUIText, bEnableTextRenderSystemV2) == 0x0008D8, "Member 'UUIText::bEnableTextRenderSystemV2' has a wrong offset!");
static_assert(offsetof(UUIText, ClickComponent) == 0x0009E8, "Member 'UUIText::ClickComponent' has a wrong offset!");
static_assert(offsetof(UUIText, OnSelfLanguageChange) == 0x000A18, "Member 'UUIText::OnSelfLanguageChange' has a wrong offset!");
static_assert(offsetof(UUIText, OnTextureAsyncLoaded) == 0x000A40, "Member 'UUIText::OnTextureAsyncLoaded' has a wrong offset!");
static_assert(offsetof(UUIText, TranslateId) == 0x000A68, "Member 'UUIText::TranslateId' has a wrong offset!");

// Class LGUI.UITextInputComponent
// 0x0300 (0x06D0 - 0x03D0)
class UUITextInputComponent final : public UUISelectableComponent
{
public:
	uint8                                         Pad_12C6[0x8];                                     // 0x03D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AUITextActor>            TextActor;                                         // 0x03D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 Text;                                              // 0x03E0(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELGUITextInputType                            InputType;                                         // 0x03F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12C7[0x7];                                     // 0x03F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PasswordChar;                                      // 0x03F8(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowMultiLine;                                   // 0x0408(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12C8[0x3];                                     // 0x0409(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AUIBaseActor>            PlaceHolderActor;                                  // 0x040C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CaretBlinkRate;                                    // 0x0414(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CaretWidth;                                        // 0x0418(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsShowDefaultText;                                 // 0x041C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12C9[0x3];                                     // 0x041D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 CaretColor;                                        // 0x0420(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 SelectionColor;                                    // 0x0424(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVirtualKeyboardOptions                VirtualKeyboradOptions;                            // 0x0428(0x0001)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_12CA[0x7];                                     // 0x0429(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKey>                           IgnoreKeys;                                        // 0x0430(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_12CB[0x18];                                    // 0x0440(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUIDrawableEvent                     OnValueChange;                                     // 0x0458(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_12CC[0x18];                                    // 0x0470(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUIDrawableEvent                     OnSubmit;                                          // 0x0488(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_12CD[0x18];                                    // 0x04A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUIDrawableEvent                     OnInputActivate;                                   // 0x04B8(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	TDelegate<void(const class FString& InString)> OnCheckTextInputDelegate;                          // 0x04D0(0x0028)(Edit, ZeroConstructor, InstancedReference, Protected, NativeAccessSpecifierProtected)
	uint32                                        MaxInput;                                          // 0x04F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12CE[0x8C];                                    // 0x04FC(0x008C)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerController*                      PlayerController;                                  // 0x0588(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12CF[0x18];                                    // 0x0590(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UUISprite>               CaretObject;                                       // 0x05A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class UUISprite>>       SelectionMaskObjectArray;                          // 0x05B0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12D0[0x70];                                    // 0x05C0(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(const class FString& InString)> OnTextChange;                                      // 0x0630(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(const class FString& InString)> OnTextSubmit;                                      // 0x0658(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(const class FString& InString)> OnTextClip;                                        // 0x0680(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void(bool InActivate)>              OnInputActivateDelegate;                           // 0x06A8(0x0028)(Edit, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)

public:
	void ActivateInputText();
	void ClearCustomInputTypeEvent();
	void DeactivateInputText();
	bool IsInputActive();
	struct FLGUIDelegateHandleWrapper RegisterInputActivateEvent(const TDelegate<void(bool InActivate)>& InDelegate);
	struct FLGUIDelegateHandleWrapper RegisterSubmitEvent(const TDelegate<void(const class FString& InString)>& InDelegate);
	struct FLGUIDelegateHandleWrapper RegisterValueChangeEvent(const TDelegate<void(const class FString& InString)>& InDelegate);
	void SetCustomInputTypeFunction(const TDelegate<void(const class FString& InString)>& InFunction);
	void SetInputType(ELGUITextInputType NewValue);
	void SetText(const class FString& InText, bool InFireEvent);
	void UnregisterInputActivateEvent(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	void UnregisterSubmitEvent(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);
	void UnregisterValueChangeEvent(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);

	ELGUITextInputType GetInputType() const;
	class FString GetText() const;
	class UUIText* GetTextComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITextInputComponent">();
	}
	static class UUITextInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITextInputComponent>();
	}
};
static_assert(alignof(UUITextInputComponent) == 0x000008, "Wrong alignment on UUITextInputComponent");
static_assert(sizeof(UUITextInputComponent) == 0x0006D0, "Wrong size on UUITextInputComponent");
static_assert(offsetof(UUITextInputComponent, TextActor) == 0x0003D8, "Member 'UUITextInputComponent::TextActor' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, Text) == 0x0003E0, "Member 'UUITextInputComponent::Text' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, InputType) == 0x0003F0, "Member 'UUITextInputComponent::InputType' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, PasswordChar) == 0x0003F8, "Member 'UUITextInputComponent::PasswordChar' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, bAllowMultiLine) == 0x000408, "Member 'UUITextInputComponent::bAllowMultiLine' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, PlaceHolderActor) == 0x00040C, "Member 'UUITextInputComponent::PlaceHolderActor' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, CaretBlinkRate) == 0x000414, "Member 'UUITextInputComponent::CaretBlinkRate' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, CaretWidth) == 0x000418, "Member 'UUITextInputComponent::CaretWidth' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, IsShowDefaultText) == 0x00041C, "Member 'UUITextInputComponent::IsShowDefaultText' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, CaretColor) == 0x000420, "Member 'UUITextInputComponent::CaretColor' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, SelectionColor) == 0x000424, "Member 'UUITextInputComponent::SelectionColor' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, VirtualKeyboradOptions) == 0x000428, "Member 'UUITextInputComponent::VirtualKeyboradOptions' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, IgnoreKeys) == 0x000430, "Member 'UUITextInputComponent::IgnoreKeys' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, OnValueChange) == 0x000458, "Member 'UUITextInputComponent::OnValueChange' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, OnSubmit) == 0x000488, "Member 'UUITextInputComponent::OnSubmit' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, OnInputActivate) == 0x0004B8, "Member 'UUITextInputComponent::OnInputActivate' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, OnCheckTextInputDelegate) == 0x0004D0, "Member 'UUITextInputComponent::OnCheckTextInputDelegate' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, MaxInput) == 0x0004F8, "Member 'UUITextInputComponent::MaxInput' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, PlayerController) == 0x000588, "Member 'UUITextInputComponent::PlayerController' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, CaretObject) == 0x0005A8, "Member 'UUITextInputComponent::CaretObject' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, SelectionMaskObjectArray) == 0x0005B0, "Member 'UUITextInputComponent::SelectionMaskObjectArray' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, OnTextChange) == 0x000630, "Member 'UUITextInputComponent::OnTextChange' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, OnTextSubmit) == 0x000658, "Member 'UUITextInputComponent::OnTextSubmit' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, OnTextClip) == 0x000680, "Member 'UUITextInputComponent::OnTextClip' has a wrong offset!");
static_assert(offsetof(UUITextInputComponent, OnInputActivateDelegate) == 0x0006A8, "Member 'UUITextInputComponent::OnInputActivateDelegate' has a wrong offset!");

// Class LGUI.UITextureActor
// 0x0008 (0x0398 - 0x0390)
class AUITextureActor final : public AUIBaseActor
{
public:
	class UUITexture*                             UITexture;                                         // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITextureActor">();
	}
	static class AUITextureActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUITextureActor>();
	}
};
static_assert(alignof(AUITextureActor) == 0x000008, "Wrong alignment on AUITextureActor");
static_assert(sizeof(AUITextureActor) == 0x000398, "Wrong size on AUITextureActor");
static_assert(offsetof(AUITextureActor, UITexture) == 0x000390, "Member 'AUITextureActor::UITexture' has a wrong offset!");

// Class LGUI.UITextureBox
// 0x0010 (0x07B0 - 0x07A0)
class UUITextureBox final : public UUITextureBase
{
public:
	float                                         Thickness;                                         // 0x0798(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          SeperateFrontColor;                                // 0x079C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12D2[0x3];                                     // 0x079D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 FrontFaceColor;                                    // 0x07A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12D3[0xC];                                     // 0x07A4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITextureBox">();
	}
	static class UUITextureBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITextureBox>();
	}
};
static_assert(alignof(UUITextureBox) == 0x000010, "Wrong alignment on UUITextureBox");
static_assert(sizeof(UUITextureBox) == 0x0007B0, "Wrong size on UUITextureBox");
static_assert(offsetof(UUITextureBox, Thickness) == 0x000798, "Member 'UUITextureBox::Thickness' has a wrong offset!");
static_assert(offsetof(UUITextureBox, SeperateFrontColor) == 0x00079C, "Member 'UUITextureBox::SeperateFrontColor' has a wrong offset!");
static_assert(offsetof(UUITextureBox, FrontFaceColor) == 0x0007A0, "Member 'UUITextureBox::FrontFaceColor' has a wrong offset!");

// Class LGUI.UITextureTransitionComponent
// 0x0080 (0x02E8 - 0x0268)
class UUITextureTransitionComponent final : public UUITransitionBase
{
public:
	struct FTextureTransitionInfo                 Transition;                                        // 0x0268(0x0080)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void SetAllStateTexture(class UTexture* NewTexture);
	void SetStateTexture(EUISelectableSelectionState State, class UTexture* NewTexture);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UITextureTransitionComponent">();
	}
	static class UUITextureTransitionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUITextureTransitionComponent>();
	}
};
static_assert(alignof(UUITextureTransitionComponent) == 0x000008, "Wrong alignment on UUITextureTransitionComponent");
static_assert(sizeof(UUITextureTransitionComponent) == 0x0002E8, "Wrong size on UUITextureTransitionComponent");
static_assert(offsetof(UUITextureTransitionComponent, Transition) == 0x000268, "Member 'UUITextureTransitionComponent::Transition' has a wrong offset!");

// Class LGUI.UIToggleComponent
// 0x00C8 (0x0498 - 0x03D0)
class UUIToggleComponent final : public UUISelectableComponent
{
public:
	TWeakObjectPtr<class AUIBaseActor>            ToggleActor;                                       // 0x03D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUIToggleTransitionType                       ToggleTransition;                                  // 0x03D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12D5[0x3];                                     // 0x03D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UUISelectableTransitionComponent> ToggleTransitionComp;                              // 0x03DC(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12D6[0x4];                                     // 0x03E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULTweener*                              ToggleTransitionTweener;                           // 0x03E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OnAlpha;                                           // 0x03F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OffAlpha;                                          // 0x03F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 OnColor;                                           // 0x03F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 OffColor;                                          // 0x03FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ToggleDuration;                                    // 0x0400(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   OnTransitionName;                                  // 0x0404(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   OffTransitionName;                                 // 0x0410(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AUIBaseActor>            OnActor;                                           // 0x041C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AUIBaseActor>            OffActor;                                          // 0x0424(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsOn;                                              // 0x042C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bToggleOnSelect;                                   // 0x042D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12D7[0x2];                                     // 0x042E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  UIToggleGroupActor;                                // 0x0430(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UUIToggleGroupComponent> GroupComp;                                         // 0x0438(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12D8[0x18];                                    // 0x0440(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGUIDrawableEvent                     OnToggle;                                          // 0x0458(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	TDelegate<void(bool InBool)>                  OnToggleEvent;                                     // 0x0470(0x0028)(Edit, ZeroConstructor, InstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	struct FLGUIDelegateHandleWrapper RegisterToggleEvent(const TDelegate<void(bool InBool)>& InDelegate);
	void SetState(bool NewState, bool FireEvent);
	void SetToggleGroup(class UUIToggleGroupComponent* InGroupComp);
	void SetValue(bool NewValue, bool FireEvent);
	void UnregisterToggleEvent(const struct FLGUIDelegateHandleWrapper& InDelegateHandle);

	int32 GetIndexInGroup() const;
	bool GetState() const;
	class AActor* GetToggleGroupActor() const;
	bool GetValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIToggleComponent">();
	}
	static class UUIToggleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIToggleComponent>();
	}
};
static_assert(alignof(UUIToggleComponent) == 0x000008, "Wrong alignment on UUIToggleComponent");
static_assert(sizeof(UUIToggleComponent) == 0x000498, "Wrong size on UUIToggleComponent");
static_assert(offsetof(UUIToggleComponent, ToggleActor) == 0x0003D0, "Member 'UUIToggleComponent::ToggleActor' has a wrong offset!");
static_assert(offsetof(UUIToggleComponent, ToggleTransition) == 0x0003D8, "Member 'UUIToggleComponent::ToggleTransition' has a wrong offset!");
static_assert(offsetof(UUIToggleComponent, ToggleTransitionComp) == 0x0003DC, "Member 'UUIToggleComponent::ToggleTransitionComp' has a wrong offset!");
static_assert(offsetof(UUIToggleComponent, ToggleTransitionTweener) == 0x0003E8, "Member 'UUIToggleComponent::ToggleTransitionTweener' has a wrong offset!");
static_assert(offsetof(UUIToggleComponent, OnAlpha) == 0x0003F0, "Member 'UUIToggleComponent::OnAlpha' has a wrong offset!");
static_assert(offsetof(UUIToggleComponent, OffAlpha) == 0x0003F4, "Member 'UUIToggleComponent::OffAlpha' has a wrong offset!");
static_assert(offsetof(UUIToggleComponent, OnColor) == 0x0003F8, "Member 'UUIToggleComponent::OnColor' has a wrong offset!");
static_assert(offsetof(UUIToggleComponent, OffColor) == 0x0003FC, "Member 'UUIToggleComponent::OffColor' has a wrong offset!");
static_assert(offsetof(UUIToggleComponent, ToggleDuration) == 0x000400, "Member 'UUIToggleComponent::ToggleDuration' has a wrong offset!");
static_assert(offsetof(UUIToggleComponent, OnTransitionName) == 0x000404, "Member 'UUIToggleComponent::OnTransitionName' has a wrong offset!");
static_assert(offsetof(UUIToggleComponent, OffTransitionName) == 0x000410, "Member 'UUIToggleComponent::OffTransitionName' has a wrong offset!");
static_assert(offsetof(UUIToggleComponent, OnActor) == 0x00041C, "Member 'UUIToggleComponent::OnActor' has a wrong offset!");
static_assert(offsetof(UUIToggleComponent, OffActor) == 0x000424, "Member 'UUIToggleComponent::OffActor' has a wrong offset!");
static_assert(offsetof(UUIToggleComponent, IsOn) == 0x00042C, "Member 'UUIToggleComponent::IsOn' has a wrong offset!");
static_assert(offsetof(UUIToggleComponent, bToggleOnSelect) == 0x00042D, "Member 'UUIToggleComponent::bToggleOnSelect' has a wrong offset!");
static_assert(offsetof(UUIToggleComponent, UIToggleGroupActor) == 0x000430, "Member 'UUIToggleComponent::UIToggleGroupActor' has a wrong offset!");
static_assert(offsetof(UUIToggleComponent, GroupComp) == 0x000438, "Member 'UUIToggleComponent::GroupComp' has a wrong offset!");
static_assert(offsetof(UUIToggleComponent, OnToggle) == 0x000458, "Member 'UUIToggleComponent::OnToggle' has a wrong offset!");
static_assert(offsetof(UUIToggleComponent, OnToggleEvent) == 0x000470, "Member 'UUIToggleComponent::OnToggleEvent' has a wrong offset!");

// Class LGUI.UIVerticalLayout
// 0x0030 (0x01C0 - 0x0190)
class UUIVerticalLayout final : public UUILayoutWithAnimation
{
public:
	struct FMargin                                Padding;                                           // 0x0190(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         Spacing;                                           // 0x01A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELGUILayoutAlignmentType                      Align;                                             // 0x01A4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ExpendChildrenWidth;                               // 0x01A5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ExpendChildrenHeight;                              // 0x01A6(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          HeightFitToChildren;                               // 0x01A7(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          WidthFitToChildren;                                // 0x01A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12D9[0x17];                                    // 0x01A9(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAlign(ELGUILayoutAlignmentType Value);
	void SetExpendChildrenHeight(bool Value);
	void SetExpendChildrenWidth(bool Value);
	void SetHeightFitToChildren(bool Value);
	void SetPadding(const struct FMargin& Value);
	void SetSpacing(float Value);
	void SetWidthFitToChildren(bool Value);

	float GetActuralRange() const;
	ELGUILayoutAlignmentType GetAlign() const;
	bool GetExpendChildrenHeight() const;
	bool GetExpendChildrenWidth() const;
	bool GetHeightFitToChildren() const;
	struct FMargin GetPadding() const;
	float GetSpacing() const;
	bool GetWidthFitToChildren() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIVerticalLayout">();
	}
	static class UUIVerticalLayout* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIVerticalLayout>();
	}
};
static_assert(alignof(UUIVerticalLayout) == 0x000008, "Wrong alignment on UUIVerticalLayout");
static_assert(sizeof(UUIVerticalLayout) == 0x0001C0, "Wrong size on UUIVerticalLayout");
static_assert(offsetof(UUIVerticalLayout, Padding) == 0x000190, "Member 'UUIVerticalLayout::Padding' has a wrong offset!");
static_assert(offsetof(UUIVerticalLayout, Spacing) == 0x0001A0, "Member 'UUIVerticalLayout::Spacing' has a wrong offset!");
static_assert(offsetof(UUIVerticalLayout, Align) == 0x0001A4, "Member 'UUIVerticalLayout::Align' has a wrong offset!");
static_assert(offsetof(UUIVerticalLayout, ExpendChildrenWidth) == 0x0001A5, "Member 'UUIVerticalLayout::ExpendChildrenWidth' has a wrong offset!");
static_assert(offsetof(UUIVerticalLayout, ExpendChildrenHeight) == 0x0001A6, "Member 'UUIVerticalLayout::ExpendChildrenHeight' has a wrong offset!");
static_assert(offsetof(UUIVerticalLayout, HeightFitToChildren) == 0x0001A7, "Member 'UUIVerticalLayout::HeightFitToChildren' has a wrong offset!");
static_assert(offsetof(UUIVerticalLayout, WidthFitToChildren) == 0x0001A8, "Member 'UUIVerticalLayout::WidthFitToChildren' has a wrong offset!");

// Class LGUI.UIViewTweenParams
// 0x0020 (0x00E0 - 0x00C0)
class UUIViewTweenParams final : public UActorComponent
{
public:
	float                                         TweenSize;                                         // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TweenAlpha;                                        // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TweenTime;                                         // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12DA[0x4];                                     // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ViewNameBlackList;                                 // 0x00D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	float GetTweenAlpha() const;
	float GetTweenSize() const;
	float GetTweenTime() const;
	const TArray<class FString> GetViewNameBlackList() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIViewTweenParams">();
	}
	static class UUIViewTweenParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIViewTweenParams>();
	}
};
static_assert(alignof(UUIViewTweenParams) == 0x000008, "Wrong alignment on UUIViewTweenParams");
static_assert(sizeof(UUIViewTweenParams) == 0x0000E0, "Wrong size on UUIViewTweenParams");
static_assert(offsetof(UUIViewTweenParams, TweenSize) == 0x0000C0, "Member 'UUIViewTweenParams::TweenSize' has a wrong offset!");
static_assert(offsetof(UUIViewTweenParams, TweenAlpha) == 0x0000C4, "Member 'UUIViewTweenParams::TweenAlpha' has a wrong offset!");
static_assert(offsetof(UUIViewTweenParams, TweenTime) == 0x0000C8, "Member 'UUIViewTweenParams::TweenTime' has a wrong offset!");
static_assert(offsetof(UUIViewTweenParams, ViewNameBlackList) == 0x0000D0, "Member 'UUIViewTweenParams::ViewNameBlackList' has a wrong offset!");

// Class LGUI.ViewportUITexture
// 0x0010 (0x0830 - 0x0820)
class UViewportUITexture final : public UUITexture
{
public:
	class ASceneCapture2D*                        SceneCaptureActor;                                 // 0x0820(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSyncSizeToRT;                                     // 0x0828(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12DB[0x7];                                     // 0x0829(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USceneCaptureComponent2D* GetSceneCapture() const;
	void ViewPointToWorld(const struct FVector2D& InViewPoint, struct FVector* OutWorldLocation, struct FVector* OutWorldDirection) const;
	bool WorldToViewPoint(const struct FVector& InWorldLocation, struct FVector2D* OutViewPoint) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ViewportUITexture">();
	}
	static class UViewportUITexture* GetDefaultObj()
	{
		return GetDefaultObjImpl<UViewportUITexture>();
	}
};
static_assert(alignof(UViewportUITexture) == 0x000010, "Wrong alignment on UViewportUITexture");
static_assert(sizeof(UViewportUITexture) == 0x000830, "Wrong size on UViewportUITexture");
static_assert(offsetof(UViewportUITexture, SceneCaptureActor) == 0x000820, "Member 'UViewportUITexture::SceneCaptureActor' has a wrong offset!");
static_assert(offsetof(UViewportUITexture, bSyncSizeToRT) == 0x000828, "Member 'UViewportUITexture::bSyncSizeToRT' has a wrong offset!");

// Class LGUI.WwiseAudioComponent
// 0x0008 (0x00C8 - 0x00C0)
class UWwiseAudioComponent final : public UActorComponent
{
public:
	int32                                         AudioStateSystemLevel;                             // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12DD[0x4];                                     // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetAudioStateSystemLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WwiseAudioComponent">();
	}
	static class UWwiseAudioComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWwiseAudioComponent>();
	}
};
static_assert(alignof(UWwiseAudioComponent) == 0x000008, "Wrong alignment on UWwiseAudioComponent");
static_assert(sizeof(UWwiseAudioComponent) == 0x0000C8, "Wrong size on UWwiseAudioComponent");
static_assert(offsetof(UWwiseAudioComponent, AudioStateSystemLevel) == 0x0000C0, "Member 'UWwiseAudioComponent::AudioStateSystemLevel' has a wrong offset!");

}

