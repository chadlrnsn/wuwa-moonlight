#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: SMSystem

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "SMSystem_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class SMSystem.SMInstanceInterface
// 0x0000 (0x0030 - 0x0030)
class ISMInstanceInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SMInstanceInterface">();
	}
	static class ISMInstanceInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISMInstanceInterface>();
	}
};
static_assert(alignof(ISMInstanceInterface) == 0x000008, "Wrong alignment on ISMInstanceInterface");
static_assert(sizeof(ISMInstanceInterface) == 0x000030, "Wrong size on ISMInstanceInterface");

// Class SMSystem.SMStateMachineInterface
// 0x0000 (0x0030 - 0x0030)
class ISMStateMachineInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SMStateMachineInterface">();
	}
	static class ISMStateMachineInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISMStateMachineInterface>();
	}
};
static_assert(alignof(ISMStateMachineInterface) == 0x000008, "Wrong alignment on ISMStateMachineInterface");
static_assert(sizeof(ISMStateMachineInterface) == 0x000030, "Wrong size on ISMStateMachineInterface");

// Class SMSystem.SMStateMachineNetworkedInterface
// 0x0000 (0x0030 - 0x0030)
class ISMStateMachineNetworkedInterface final : public IInterface
{
public:
	bool HasAuthority() const;
	bool IsConfiguredForNetworking() const;
	bool IsSimulatedProxy() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SMStateMachineNetworkedInterface">();
	}
	static class ISMStateMachineNetworkedInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISMStateMachineNetworkedInterface>();
	}
};
static_assert(alignof(ISMStateMachineNetworkedInterface) == 0x000008, "Wrong alignment on ISMStateMachineNetworkedInterface");
static_assert(sizeof(ISMStateMachineNetworkedInterface) == 0x000030, "Wrong size on ISMStateMachineNetworkedInterface");

// Class SMSystem.SMBlueprint
// 0x0008 (0x00B0 - 0x00A8)
class USMBlueprint final : public UBlueprint
{
public:
	int32                                         AssetVersion;                                      // 0x00A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SMBlueprint">();
	}
	static class USMBlueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<USMBlueprint>();
	}
};
static_assert(alignof(USMBlueprint) == 0x000008, "Wrong alignment on USMBlueprint");
static_assert(sizeof(USMBlueprint) == 0x0000B0, "Wrong size on USMBlueprint");
static_assert(offsetof(USMBlueprint, AssetVersion) == 0x0000A8, "Member 'USMBlueprint::AssetVersion' has a wrong offset!");

// Class SMSystem.SMNodeBlueprint
// 0x0000 (0x00A8 - 0x00A8)
class USMNodeBlueprint final : public UBlueprint
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SMNodeBlueprint">();
	}
	static class USMNodeBlueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<USMNodeBlueprint>();
	}
};
static_assert(alignof(USMNodeBlueprint) == 0x000008, "Wrong alignment on USMNodeBlueprint");
static_assert(sizeof(USMNodeBlueprint) == 0x0000A8, "Wrong size on USMNodeBlueprint");

// Class SMSystem.SMBlueprintGeneratedClass
// 0x0020 (0x0358 - 0x0338)
class USMBlueprintGeneratedClass final : public UBlueprintGeneratedClass
{
public:
	struct FGuid                                  RootGuid;                                          // 0x0338(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USMStateMachineInstance*>        AllRootInstances;                                  // 0x0348(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SMBlueprintGeneratedClass">();
	}
	static class USMBlueprintGeneratedClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<USMBlueprintGeneratedClass>();
	}
};
static_assert(alignof(USMBlueprintGeneratedClass) == 0x000008, "Wrong alignment on USMBlueprintGeneratedClass");
static_assert(sizeof(USMBlueprintGeneratedClass) == 0x000358, "Wrong size on USMBlueprintGeneratedClass");
static_assert(offsetof(USMBlueprintGeneratedClass, RootGuid) == 0x000338, "Member 'USMBlueprintGeneratedClass::RootGuid' has a wrong offset!");
static_assert(offsetof(USMBlueprintGeneratedClass, AllRootInstances) == 0x000348, "Member 'USMBlueprintGeneratedClass::AllRootInstances' has a wrong offset!");

// Class SMSystem.SMNodeBlueprintGeneratedClass
// 0x0000 (0x0338 - 0x0338)
class USMNodeBlueprintGeneratedClass final : public UBlueprintGeneratedClass
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SMNodeBlueprintGeneratedClass">();
	}
	static class USMNodeBlueprintGeneratedClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<USMNodeBlueprintGeneratedClass>();
	}
};
static_assert(alignof(USMNodeBlueprintGeneratedClass) == 0x000008, "Wrong alignment on USMNodeBlueprintGeneratedClass");
static_assert(sizeof(USMNodeBlueprintGeneratedClass) == 0x000338, "Wrong size on USMNodeBlueprintGeneratedClass");

// Class SMSystem.SMNodeInstance
// 0x0020 (0x0050 - 0x0030)
class USMNodeInstance : public UObject
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  TemplateGuid;                                      // 0x0040(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UObject* GetContext() const;
	const struct FGuid GetGuid() const;
	TScriptInterface<class ISMStateMachineNetworkedInterface> GetNetworkInterface() const;
	class FString GetNodeName() const;
	class USMStateMachineInstance* GetOwningStateMachineNodeInstance() const;
	class USMInstance* GetStateMachineInstance(bool bTopMostInstance) const;
	float GetTimeInState() const;
	bool HasUpdated() const;
	bool IsActive() const;
	bool IsInEndState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SMNodeInstance">();
	}
	static class USMNodeInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USMNodeInstance>();
	}
};
static_assert(alignof(USMNodeInstance) == 0x000008, "Wrong alignment on USMNodeInstance");
static_assert(sizeof(USMNodeInstance) == 0x000050, "Wrong size on USMNodeInstance");
static_assert(offsetof(USMNodeInstance, TemplateGuid) == 0x000040, "Member 'USMNodeInstance::TemplateGuid' has a wrong offset!");

// Class SMSystem.SMStateInstance_Base
// 0x00A0 (0x00F0 - 0x0050)
class USMStateInstance_Base : public USMNodeInstance
{
public:
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnStateBeginEvent;                                 // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPostStateBeginEvent;                             // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStateUpdateEvent;                                // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStateEndEvent;                                   // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	ETakeControlType                              TakeControlType;                                   // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETransitionRule                               TransitionRule;                                    // 0x0099(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UASMTask*                               Task;                                              // 0x00A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UASMBindState*>                  BindStates;                                        // 0x00A8(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UASMAction*>                     OnEnterActions;                                    // 0x00B8(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UASMAction*>                     OnExitActions;                                     // 0x00C8(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FString                                 NodeName;                                          // 0x00D8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRefNode;                                         // 0x00E8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOvrNode;                                         // 0x00E9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EA[0x6];                                       // 0x00EA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EvaluateTransitions();
	void SetActive(bool bValue, bool bSetAllParents, bool bActivateNow);
	void SetAlwaysUpdate(const bool bValue);
	void SetDisableTickTransitionEvaluation(const bool bValue);
	void SetEvalTransitionsOnStart(const bool bValue);
	void SetExcludeFromAnyState(const bool bValue);
	bool SwitchToLinkedState(class USMStateInstance_Base* NextStateInstance, bool bRequireTransitionToPass, bool bActivateNow);
	bool SwitchToLinkedStateByName(const class FString& NextStateName, bool bRequireTransitionToPass, bool bActivateNow);
	bool SwitchToLinkedStateByTransition(class USMTransitionInstance* TransitionInstance, bool bRequireTransitionToPass, bool bActivateNow);

	bool AreAllIncomingTransitionsFromAnAnyState() const;
	bool AreAllOutgoingTransitionsFromAnAnyState() const;
	bool GetAlwaysUpdate() const;
	bool GetDisableTickTransitionEvaluation() const;
	bool GetEvalTransitionsOnStart() const;
	bool GetExcludeFromAnyState() const;
	bool GetIncomingTransitions(TArray<class USMTransitionInstance*>* Transitions, bool bExcludeAlwaysFalse) const;
	class USMStateInstance_Base* GetNextStateByName(const class FString& StateName) const;
	class USMStateInstance_Base* GetNextStateByTransitionIndex(int32 Index_0) const;
	bool GetOutgoingTransitions(TArray<class USMTransitionInstance*>* Transitions, bool bExcludeAlwaysFalse) const;
	class USMStateInstance_Base* GetPreviousActiveState() const;
	class USMTransitionInstance* GetPreviousActiveTransition() const;
	class USMStateInstance_Base* GetPreviousStateByName(const class FString& StateName) const;
	float GetServerTimeInState(bool* bOutUsedLocalTime) const;
	const struct FDateTime GetStartTime() const;
	void GetStateInfo(struct FSMStateInfo* State) const;
	class USMTransitionInstance* GetTransitionByIndex(int32 Index_0) const;
	class USMTransitionInstance* GetTransitionToTake() const;
	bool IsEntryState() const;
	bool IsStateMachine() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SMStateInstance_Base">();
	}
	static class USMStateInstance_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<USMStateInstance_Base>();
	}
};
static_assert(alignof(USMStateInstance_Base) == 0x000008, "Wrong alignment on USMStateInstance_Base");
static_assert(sizeof(USMStateInstance_Base) == 0x0000F0, "Wrong size on USMStateInstance_Base");
static_assert(offsetof(USMStateInstance_Base, OnStateBeginEvent) == 0x000058, "Member 'USMStateInstance_Base::OnStateBeginEvent' has a wrong offset!");
static_assert(offsetof(USMStateInstance_Base, OnPostStateBeginEvent) == 0x000068, "Member 'USMStateInstance_Base::OnPostStateBeginEvent' has a wrong offset!");
static_assert(offsetof(USMStateInstance_Base, OnStateUpdateEvent) == 0x000078, "Member 'USMStateInstance_Base::OnStateUpdateEvent' has a wrong offset!");
static_assert(offsetof(USMStateInstance_Base, OnStateEndEvent) == 0x000088, "Member 'USMStateInstance_Base::OnStateEndEvent' has a wrong offset!");
static_assert(offsetof(USMStateInstance_Base, TakeControlType) == 0x000098, "Member 'USMStateInstance_Base::TakeControlType' has a wrong offset!");
static_assert(offsetof(USMStateInstance_Base, TransitionRule) == 0x000099, "Member 'USMStateInstance_Base::TransitionRule' has a wrong offset!");
static_assert(offsetof(USMStateInstance_Base, Task) == 0x0000A0, "Member 'USMStateInstance_Base::Task' has a wrong offset!");
static_assert(offsetof(USMStateInstance_Base, BindStates) == 0x0000A8, "Member 'USMStateInstance_Base::BindStates' has a wrong offset!");
static_assert(offsetof(USMStateInstance_Base, OnEnterActions) == 0x0000B8, "Member 'USMStateInstance_Base::OnEnterActions' has a wrong offset!");
static_assert(offsetof(USMStateInstance_Base, OnExitActions) == 0x0000C8, "Member 'USMStateInstance_Base::OnExitActions' has a wrong offset!");
static_assert(offsetof(USMStateInstance_Base, NodeName) == 0x0000D8, "Member 'USMStateInstance_Base::NodeName' has a wrong offset!");
static_assert(offsetof(USMStateInstance_Base, IsRefNode) == 0x0000E8, "Member 'USMStateInstance_Base::IsRefNode' has a wrong offset!");
static_assert(offsetof(USMStateInstance_Base, IsOvrNode) == 0x0000E9, "Member 'USMStateInstance_Base::IsOvrNode' has a wrong offset!");

// Class SMSystem.SMConduitInstance
// 0x0008 (0x00F8 - 0x00F0)
class USMConduitInstance final : public USMStateInstance_Base
{
public:
	bool                                          bEvalWithTransitions;                              // 0x00F0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanEvaluate;                                      // 0x00F1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F2[0x6];                                       // 0x00F2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCanEvaluate(const bool bValue);
	void SetEvalWithTransitions(const bool bValue);

	bool GetCanEvaluate() const;
	bool GetEvalWithTransitions() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SMConduitInstance">();
	}
	static class USMConduitInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USMConduitInstance>();
	}
};
static_assert(alignof(USMConduitInstance) == 0x000008, "Wrong alignment on USMConduitInstance");
static_assert(sizeof(USMConduitInstance) == 0x0000F8, "Wrong size on USMConduitInstance");
static_assert(offsetof(USMConduitInstance, bEvalWithTransitions) == 0x0000F0, "Member 'USMConduitInstance::bEvalWithTransitions' has a wrong offset!");
static_assert(offsetof(USMConduitInstance, bCanEvaluate) == 0x0000F1, "Member 'USMConduitInstance::bCanEvaluate' has a wrong offset!");

// Class SMSystem.SMInstance
// 0x0580 (0x05B0 - 0x0030)
class USMInstance final : public UObject
{
public:
	uint8                                         Pad_30[0x38];                                      // 0x0030(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSMReferenceContainer>          ReplicatedReferences;                              // 0x0068(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	struct FGuid                                  RootStateMachineGuid;                              // 0x0078(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USMStateMachineInstance*>        AllRootNodeInstances;                              // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPreStateMachineInitializedEvent;                 // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStateMachineInitializedEvent;                    // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStateMachineStartedEvent;                        // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStateMachineUpdatedEvent;                        // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStateMachineStoppedEvent;                        // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStateMachineTransitionTakenEvent;                // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStateMachineStateChangedEvent;                   // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStateMachineStateStartedEvent;                   // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USMStateMachineComponent*               ComponentOwner;                                    // 0x0118(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TScriptInterface<class ISMStateMachineNetworkedInterface> NetworkInterface;                                  // 0x0120(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_130[0x140];                                    // 0x0130(0x0140)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSMStateMachine                        RootStateMachine;                                  // 0x0270(0x0298)(Protected, NativeAccessSpecifierProtected)
	class UObject*                                R_StateMachineContext;                             // 0x0508(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USMInstance*                            ReferenceOwner;                                    // 0x0510(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class USMStateMachineInstance>    StateMachineClass;                                 // 0x0518(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAutoManageTime : 1;                               // 0x0520(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bStopOnEndState : 1;                               // 0x0520(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanEverTick : 1;                                  // 0x0520(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanTickWhenPaused : 1;                            // 0x0520(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bTickRegistered : 1;                               // 0x0520(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bTickBeforeInitialize : 1;                         // 0x0520(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bTickBeforeBeginPlay : 1;                          // 0x0520(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_521[0x3];                                      // 0x0521(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TickInterval;                                      // 0x0524(0x0004)(Edit, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_528[0x10];                                     // 0x0528(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSMStateHistory>                StateHistory;                                      // 0x0538(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	int32                                         StateHistoryMaxCount;                              // 0x0548(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bEnableLogging : 1;                                // 0x054C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bLogStateChange : 1;                               // 0x054C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bLogTransitionTaken : 1;                           // 0x054C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanReplicateAsReference : 1;                      // 0x054C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_54D[0x3];                                      // 0x054D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGuid, struct FGuid>              PathGuidRedirectMap;                               // 0x0550(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<class UObject*>                        ReferenceTemplates;                                // 0x05A0(0x0010)(ExportObject, ZeroConstructor, DuplicateTransient, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	void ClearLoadedStates();
	void ClearStateHistory();
	bool EvaluateAndFindTransitionChain(class USMTransitionInstance* InFirstTransitionInstance, TArray<class USMTransitionInstance*>* OutTransitionChain, class USMStateInstance_Base** OutDestinationState, bool bRequirePreviousStateActive);
	bool EvaluateAndTakeTransitionChain(class USMTransitionInstance* InFirstTransitionInstance);
	void EvaluateTransitions();
	void GetAllRootNodeInstance(TArray<class USMStateMachineInstance*>* Nodes);
	TMap<struct FGuid, struct FGuid> GetGuidRedirectMap();
	class USMInstance* GetMasterReferenceOwner();
	class USMInstance* GetPrimaryReferenceOwner();
	void Initialize(class UObject* Context);
	bool Internal_EvaluateAndTakeTransitionChainByGuid(const struct FGuid& PathGuid);
	void Internal_EventCleanup(const struct FGuid& PathGuid);
	void Internal_EventUpdate();
	void Internal_Update(float DeltaSeconds);
	void K2_TryGetNetworkInterface(TScriptInterface<class ISMStateMachineNetworkedInterface>* Interface, bool* bIsValid);
	void LoadFromMultipleStates(const TArray<struct FGuid>& FromGuids, bool bNotify);
	void LoadFromState(const struct FGuid& FromGuid, bool bAllParents, bool bNotify);
	void OnPostCompile();
	void OnPreStateMachineInitialized();
	void OnStateMachineInitialized();
	void OnStateMachineInitialStateLoaded(const struct FGuid& StateGuid);
	void OnStateMachineStart();
	void OnStateMachineStateChanged(const struct FSMStateInfo& ToState, const struct FSMStateInfo& FromState);
	void OnStateMachineStateStarted(const struct FSMStateInfo& State);
	void OnStateMachineStop();
	void OnStateMachineTransitionTaken(const struct FSMTransitionInfo& Transition);
	void OnStateMachineUpdate(float DeltaSeconds);
	void PreloadAllNodeInstances();
	void REP_OnReplicatedReferencesLoaded();
	void ReplicatedRestart();
	void ReplicatedStart();
	void ReplicatedStop();
	void Restart();
	void RunUpdateAsReference(float DeltaSeconds);
	void SetAutoManageTime(bool Value);
	void SetCanEverTick(bool Value);
	void SetCanTickWhenPaused(bool Value);
	void SetContext(class UObject* Context);
	void SetGuidRedirectMap(const TMap<struct FGuid, struct FGuid>& InGuidMap);
	void SetStateHistoryMaxCount(int32 NewSize);
	void SetStateMachineClass(TSubclassOf<class USMStateMachineInstance> NewStateMachineClass);
	void SetStopOnEndState(bool Value);
	void SetTickBeforeBeginPlay(bool Value);
	void SetTickInterval(float Value);
	void SetTickOnManualUpdate(bool Value);
	void Shutdown();
	void Start();
	void StartWithNewContext(class UObject* Context);
	void Stop();
	void SwitchActiveState(class USMStateInstance_Base* NewStateInstance, bool bDeactivateOtherStates);
	void SwitchActiveStateByQualifiedName(const class FString& InFullPath, bool bDeactivateOtherStates);
	bool TakeTransitionChain(const TArray<class USMTransitionInstance*>& InTransitionChain);
	void Tick(float DeltaTime);
	void Update(float DeltaSeconds);

	bool AreInitialStatesSetFromLoad() const;
	bool CanAutoManageTime() const;
	bool CanEverTick() const;
	bool CanTickOnManualUpdate() const;
	struct FGuid GetActiveStateGuid() const;
	class USMStateInstance_Base* GetActiveStateInstance(bool bCheckNested) const;
	class FString GetActiveStateName() const;
	void GetAllActiveStateGuids(TArray<struct FGuid>* ActiveGuids) const;
	void GetAllActiveStateInstances(TArray<class USMStateInstance_Base*>* ActiveStateInstances) const;
	TArray<struct FGuid> GetAllCurrentStateGuids() const;
	TArray<class USMInstance*> GetAllReferencedInstances(bool bIncludeChildren) const;
	void GetAllStateInstances(TArray<class USMStateInstance_Base*>* StateInstances) const;
	void GetAllTransitionInstances(TArray<class USMTransitionInstance*>* TransitionInstances) const;
	class USMStateMachineComponent* GetComponentOwner() const;
	class UObject* GetContext() const;
	struct FGuid GetNestedActiveStateGuid() const;
	class FString GetNestedActiveStateName() const;
	TScriptInterface<class ISMStateMachineNetworkedInterface> GetNetworkInterface() const;
	class USMNodeInstance* GetNodeInstanceByGuid(const struct FGuid& Guid) const;
	class USMInstance* GetReferencedInstanceByGuid(const struct FGuid& Guid) const;
	class USMInstance* GetReferenceOwner() const;
	class USMStateMachineInstance* GetRootStateMachineInstance() const;
	class USMStateMachineInstance* GetRootStateMachineNodeInstance() const;
	struct FGuid GetSingleActiveStateGuid(bool bCheckNested) const;
	class USMStateInstance_Base* GetSingleActiveStateInstance(bool bCheckNested) const;
	const TArray<struct FSMStateHistory> GetStateHistory() const;
	int32 GetStateHistoryMaxCount() const;
	class USMStateInstance_Base* GetStateInstanceByGuid(const struct FGuid& Guid) const;
	class USMStateInstance_Base* GetStateInstanceByQualifiedName(const class FString& InFullPath) const;
	TSubclassOf<class USMStateMachineInstance> GetStateMachineClass() const;
	bool GetStopOnEndState() const;
	float GetTickInterval() const;
	class USMTransitionInstance* GetTransitionInstanceByGuid(const struct FGuid& Guid) const;
	bool HasStarted() const;
	bool IsActive() const;
	bool IsInEndState() const;
	bool IsInitialized() const;
	bool IsTickable() const;
	bool IsTickableWhenPaused() const;
	void TryGetNestedActiveState(struct FSMStateInfo* FoundState, bool* bSuccess) const;
	void TryGetStateInfo(const struct FGuid& Guid, struct FSMStateInfo* StateInfo, bool* bSuccess) const;
	void TryGetTransitionInfo(const struct FGuid& Guid, struct FSMTransitionInfo* TransitionInfo, bool* bSuccess) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SMInstance">();
	}
	static class USMInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USMInstance>();
	}
};
static_assert(alignof(USMInstance) == 0x000008, "Wrong alignment on USMInstance");
static_assert(sizeof(USMInstance) == 0x0005B0, "Wrong size on USMInstance");
static_assert(offsetof(USMInstance, ReplicatedReferences) == 0x000068, "Member 'USMInstance::ReplicatedReferences' has a wrong offset!");
static_assert(offsetof(USMInstance, RootStateMachineGuid) == 0x000078, "Member 'USMInstance::RootStateMachineGuid' has a wrong offset!");
static_assert(offsetof(USMInstance, AllRootNodeInstances) == 0x000088, "Member 'USMInstance::AllRootNodeInstances' has a wrong offset!");
static_assert(offsetof(USMInstance, OnPreStateMachineInitializedEvent) == 0x000098, "Member 'USMInstance::OnPreStateMachineInitializedEvent' has a wrong offset!");
static_assert(offsetof(USMInstance, OnStateMachineInitializedEvent) == 0x0000A8, "Member 'USMInstance::OnStateMachineInitializedEvent' has a wrong offset!");
static_assert(offsetof(USMInstance, OnStateMachineStartedEvent) == 0x0000B8, "Member 'USMInstance::OnStateMachineStartedEvent' has a wrong offset!");
static_assert(offsetof(USMInstance, OnStateMachineUpdatedEvent) == 0x0000C8, "Member 'USMInstance::OnStateMachineUpdatedEvent' has a wrong offset!");
static_assert(offsetof(USMInstance, OnStateMachineStoppedEvent) == 0x0000D8, "Member 'USMInstance::OnStateMachineStoppedEvent' has a wrong offset!");
static_assert(offsetof(USMInstance, OnStateMachineTransitionTakenEvent) == 0x0000E8, "Member 'USMInstance::OnStateMachineTransitionTakenEvent' has a wrong offset!");
static_assert(offsetof(USMInstance, OnStateMachineStateChangedEvent) == 0x0000F8, "Member 'USMInstance::OnStateMachineStateChangedEvent' has a wrong offset!");
static_assert(offsetof(USMInstance, OnStateMachineStateStartedEvent) == 0x000108, "Member 'USMInstance::OnStateMachineStateStartedEvent' has a wrong offset!");
static_assert(offsetof(USMInstance, ComponentOwner) == 0x000118, "Member 'USMInstance::ComponentOwner' has a wrong offset!");
static_assert(offsetof(USMInstance, NetworkInterface) == 0x000120, "Member 'USMInstance::NetworkInterface' has a wrong offset!");
static_assert(offsetof(USMInstance, RootStateMachine) == 0x000270, "Member 'USMInstance::RootStateMachine' has a wrong offset!");
static_assert(offsetof(USMInstance, R_StateMachineContext) == 0x000508, "Member 'USMInstance::R_StateMachineContext' has a wrong offset!");
static_assert(offsetof(USMInstance, ReferenceOwner) == 0x000510, "Member 'USMInstance::ReferenceOwner' has a wrong offset!");
static_assert(offsetof(USMInstance, StateMachineClass) == 0x000518, "Member 'USMInstance::StateMachineClass' has a wrong offset!");
static_assert(offsetof(USMInstance, TickInterval) == 0x000524, "Member 'USMInstance::TickInterval' has a wrong offset!");
static_assert(offsetof(USMInstance, StateHistory) == 0x000538, "Member 'USMInstance::StateHistory' has a wrong offset!");
static_assert(offsetof(USMInstance, StateHistoryMaxCount) == 0x000548, "Member 'USMInstance::StateHistoryMaxCount' has a wrong offset!");
static_assert(offsetof(USMInstance, PathGuidRedirectMap) == 0x000550, "Member 'USMInstance::PathGuidRedirectMap' has a wrong offset!");
static_assert(offsetof(USMInstance, ReferenceTemplates) == 0x0005A0, "Member 'USMInstance::ReferenceTemplates' has a wrong offset!");

// Class SMSystem.SMRuntimeSettings
// 0x0008 (0x0038 - 0x0030)
class USMRuntimeSettings final : public UObject
{
public:
	bool                                          bPreloadDefaultNodes;                              // 0x0030(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SMRuntimeSettings">();
	}
	static class USMRuntimeSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USMRuntimeSettings>();
	}
};
static_assert(alignof(USMRuntimeSettings) == 0x000008, "Wrong alignment on USMRuntimeSettings");
static_assert(sizeof(USMRuntimeSettings) == 0x000038, "Wrong size on USMRuntimeSettings");
static_assert(offsetof(USMRuntimeSettings, bPreloadDefaultNodes) == 0x000030, "Member 'USMRuntimeSettings::bPreloadDefaultNodes' has a wrong offset!");

// Class SMSystem.ASMBindState
// 0x0000 (0x0030 - 0x0030)
class UASMBindState : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASMBindState">();
	}
	static class UASMBindState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UASMBindState>();
	}
};
static_assert(alignof(UASMBindState) == 0x000008, "Wrong alignment on UASMBindState");
static_assert(sizeof(UASMBindState) == 0x000030, "Wrong size on UASMBindState");

// Class SMSystem.ASMAction
// 0x0000 (0x0030 - 0x0030)
class UASMAction : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASMAction">();
	}
	static class UASMAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UASMAction>();
	}
};
static_assert(alignof(UASMAction) == 0x000008, "Wrong alignment on UASMAction");
static_assert(sizeof(UASMAction) == 0x000030, "Wrong size on UASMAction");

// Class SMSystem.ASMTask
// 0x0000 (0x0030 - 0x0030)
class UASMTask : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASMTask">();
	}
	static class UASMTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UASMTask>();
	}
};
static_assert(alignof(UASMTask) == 0x000008, "Wrong alignment on UASMTask");
static_assert(sizeof(UASMTask) == 0x000030, "Wrong size on UASMTask");

// Class SMSystem.SMStateInstance
// 0x0000 (0x00F0 - 0x00F0)
class USMStateInstance final : public USMStateInstance_Base
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SMStateInstance">();
	}
	static class USMStateInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USMStateInstance>();
	}
};
static_assert(alignof(USMStateInstance) == 0x000008, "Wrong alignment on USMStateInstance");
static_assert(sizeof(USMStateInstance) == 0x0000F0, "Wrong size on USMStateInstance");

// Class SMSystem.SMStateMachineComponent
// 0x0148 (0x0208 - 0x00C0)
class USMStateMachineComponent final : public UActorComponent
{
public:
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnStateMachineInitializedEvent;                    // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStateMachineStartedEvent;                        // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStateMachineUpdatedEvent;                        // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStateMachineStoppedEvent;                        // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStateMachineTransitionTakenEvent;                // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStateMachineStateChangedEvent;                   // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStateMachineStateStartedEvent;                   // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSet<class UActorChannel*>                    CurrentActorChannels;                              // 0x0140(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_190[0x24];                                     // 0x0190(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bAutomaticallyHandleNewConnections : 1;            // 0x01B4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1B5[0x3];                                      // 0x01B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class USMInstance>                StateMachineClass;                                 // 0x01B8(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bInitializeOnBeginPlay : 1;                        // 0x01C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, Net, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bStartOnBeginPlay : 1;                             // 0x01C0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, Net, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bStopOnEndPlay : 1;                                // 0x01C0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, Net, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLetInstanceManageTick : 1;                        // 0x01C0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bReuseInstanceAfterShutdown : 1;                   // 0x01C0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, Net, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	ESMNetworkConfigurationType                   StateChangeAuthority;                              // 0x01C1(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESMNetworkConfigurationType                   NetworkTransitionConfiguration;                    // 0x01C2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESMNetworkConfigurationType                   NetworkTickConfiguration;                          // 0x01C3(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESMNetworkConfigurationType                   NetworkStateExecution;                             // 0x01C4(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESMNetworkConfigurationType                   NetworkStateConfiguration;                         // 0x01C5(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIncludeSimulatedProxies : 1;                      // 0x01C6(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, Net, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	ESMNetworkConfigurationType                   NetworkTransitionEnteredConfiguration;             // 0x01C7(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bWaitForTransactionsFromServer : 1;                // 0x01C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, Net, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTakeTransitionsFromServerOnly : 1;                // 0x01C8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCalculateServerTimeForClients : 1;                // 0x01C8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, Net, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseOwnerNetUpdateFrequency : 1;                   // 0x01C8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, Net, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1C9[0x3];                                      // 0x01C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ServerNetUpdateFrequency;                          // 0x01CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClientNetUpdateFrequency;                          // 0x01D0(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAlwaysMulticast : 1;                              // 0x01D4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, Net, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDiscardTransitionsBeforeInitialize : 1;           // 0x01D4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bReplicateStatesOnLoad : 1;                        // 0x01D4(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D5[0x3];                                      // 0x01D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TransitionResetTimeSeconds;                        // 0x01D8(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTimeToWaitForTransitionUpdate;                  // 0x01DC(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USMStateMachineComponent*               ComponentToCopy;                                   // 0x01E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E8[0x8];                                      // 0x01E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USMInstance*                            R_Instance;                                        // 0x01F0(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USMInstance*                            InstanceTemplate;                                  // 0x01F8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bOverrideTick : 1;                                 // 0x0200(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Deprecated, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanEverTick : 1;                                  // 0x0200(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Deprecated, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bOverrideTickInterval : 1;                         // 0x0200(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Deprecated, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanInstanceNetworkTick : 1;                       // 0x0200(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_201[0x3];                                      // 0x0201(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TickInterval;                                      // 0x0204(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CLIENT_ActivateStates(const TArray<struct FSMActivateStateTransaction>& StateTransactions);
	void CLIENT_FullSync(const struct FSMFullSyncTransaction& FullSyncTransaction);
	void CLIENT_Shutdown(const struct FSMTransaction_Base& Transaction);
	void CLIENT_Start(const struct FSMTransaction_Base& Transaction);
	void CLIENT_Stop(const struct FSMTransaction_Base& Transaction);
	void CLIENT_TakeTransitions(const TArray<struct FSMTransitionTransaction>& Transactions);
	void CopySettingsFromOtherComponent(class USMStateMachineComponent* OtherComponent);
	void Initialize(class UObject* Context);
	void Internal_OnReplicatedInstanceInitialized(class USMInstance* Instance);
	void Internal_OnStateMachineStarted(class USMInstance* Instance);
	void Internal_OnStateMachineStateChanged(class USMInstance* Instance, const struct FSMStateInfo& ToState, const struct FSMStateInfo& FromState);
	void Internal_OnStateMachineStateStarted(class USMInstance* Instance, const struct FSMStateInfo& State);
	void Internal_OnStateMachineStopped(class USMInstance* Instance);
	void Internal_OnStateMachineTransitionTaken(class USMInstance* Instance, const struct FSMTransitionInfo& Transition);
	void Internal_OnStateMachineUpdated(class USMInstance* Instance, float DeltaSeconds);
	void MULTICAST_ActivateStates(const TArray<struct FSMActivateStateTransaction>& StateTransactions);
	void MULTICAST_FullSync(const struct FSMFullSyncTransaction& FullSyncTransaction);
	void MULTICAST_Shutdown(const struct FSMTransaction_Base& Transaction);
	void MULTICAST_Start(const struct FSMTransaction_Base& Transaction);
	void MULTICAST_Stop(const struct FSMTransaction_Base& Transaction);
	void MULTICAST_TakeTransitions(const TArray<struct FSMTransitionTransaction>& Transactions);
	void OnPostInitialize();
	void REP_OnInstanceLoaded();
	void Restart();
	void SERVER_ActivateStates(const TArray<struct FSMActivateStateTransaction>& StateTransactions);
	void SERVER_FullSync(const struct FSMFullSyncTransaction& FullSyncTransaction);
	void SERVER_Initialize(const struct FSMInitializeTransaction& Transaction);
	void SERVER_RequestFullSync();
	void SERVER_Shutdown(const struct FSMTransaction_Base& Transaction);
	void SERVER_Start(const struct FSMTransaction_Base& Transaction);
	void SERVER_Stop(const struct FSMTransaction_Base& Transaction);
	void SERVER_TakeTransitions(const TArray<struct FSMTransitionTransaction>& TransitionTransactions);
	void SERVER_Update(float DeltaTime);
	void SetCanInstanceNetworkTick(bool bCanEverTick_0);
	void Shutdown();
	void Start();
	void Stop();
	void Update(float DeltaSeconds);

	class UObject* GetContextForInitialization() const;
	class USMInstance* GetInstance() const;
	class AActor* GetTopMostParentActor() const;
	bool IsInitialized() const;
	bool IsStateMachineActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SMStateMachineComponent">();
	}
	static class USMStateMachineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USMStateMachineComponent>();
	}
};
static_assert(alignof(USMStateMachineComponent) == 0x000008, "Wrong alignment on USMStateMachineComponent");
static_assert(sizeof(USMStateMachineComponent) == 0x000208, "Wrong size on USMStateMachineComponent");
static_assert(offsetof(USMStateMachineComponent, OnStateMachineInitializedEvent) == 0x0000D0, "Member 'USMStateMachineComponent::OnStateMachineInitializedEvent' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, OnStateMachineStartedEvent) == 0x0000E0, "Member 'USMStateMachineComponent::OnStateMachineStartedEvent' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, OnStateMachineUpdatedEvent) == 0x0000F0, "Member 'USMStateMachineComponent::OnStateMachineUpdatedEvent' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, OnStateMachineStoppedEvent) == 0x000100, "Member 'USMStateMachineComponent::OnStateMachineStoppedEvent' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, OnStateMachineTransitionTakenEvent) == 0x000110, "Member 'USMStateMachineComponent::OnStateMachineTransitionTakenEvent' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, OnStateMachineStateChangedEvent) == 0x000120, "Member 'USMStateMachineComponent::OnStateMachineStateChangedEvent' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, OnStateMachineStateStartedEvent) == 0x000130, "Member 'USMStateMachineComponent::OnStateMachineStateStartedEvent' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, CurrentActorChannels) == 0x000140, "Member 'USMStateMachineComponent::CurrentActorChannels' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, StateMachineClass) == 0x0001B8, "Member 'USMStateMachineComponent::StateMachineClass' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, StateChangeAuthority) == 0x0001C1, "Member 'USMStateMachineComponent::StateChangeAuthority' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, NetworkTransitionConfiguration) == 0x0001C2, "Member 'USMStateMachineComponent::NetworkTransitionConfiguration' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, NetworkTickConfiguration) == 0x0001C3, "Member 'USMStateMachineComponent::NetworkTickConfiguration' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, NetworkStateExecution) == 0x0001C4, "Member 'USMStateMachineComponent::NetworkStateExecution' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, NetworkStateConfiguration) == 0x0001C5, "Member 'USMStateMachineComponent::NetworkStateConfiguration' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, NetworkTransitionEnteredConfiguration) == 0x0001C7, "Member 'USMStateMachineComponent::NetworkTransitionEnteredConfiguration' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, ServerNetUpdateFrequency) == 0x0001CC, "Member 'USMStateMachineComponent::ServerNetUpdateFrequency' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, ClientNetUpdateFrequency) == 0x0001D0, "Member 'USMStateMachineComponent::ClientNetUpdateFrequency' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, TransitionResetTimeSeconds) == 0x0001D8, "Member 'USMStateMachineComponent::TransitionResetTimeSeconds' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, MaxTimeToWaitForTransitionUpdate) == 0x0001DC, "Member 'USMStateMachineComponent::MaxTimeToWaitForTransitionUpdate' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, ComponentToCopy) == 0x0001E0, "Member 'USMStateMachineComponent::ComponentToCopy' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, R_Instance) == 0x0001F0, "Member 'USMStateMachineComponent::R_Instance' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, InstanceTemplate) == 0x0001F8, "Member 'USMStateMachineComponent::InstanceTemplate' has a wrong offset!");
static_assert(offsetof(USMStateMachineComponent, TickInterval) == 0x000204, "Member 'USMStateMachineComponent::TickInterval' has a wrong offset!");

// Class SMSystem.SMStateMachineInstance
// 0x0028 (0x0118 - 0x00F0)
class USMStateMachineInstance final : public USMStateInstance_Base
{
public:
	TArray<class USMStateInstance_Base*>          Children;                                          // 0x00F0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class USMTransitionInstance*>          TransitionList;                                    // 0x0100(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_110[0x8];                                      // 0x0110(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetReuseCurrentState(const bool bValue);
	void SetReuseIfNotEndState(const bool bValue);
	void SetWaitForEndState(const bool bValue);

	void GetActiveStates(TArray<class USMStateInstance_Base*>* ActiveStates) const;
	void GetAllStateInstances(TArray<class USMStateInstance_Base*>* StateInstances) const;
	class USMStateInstance_Base* GetContainedStateByName(const class FString& StateName) const;
	void GetEntryStates(TArray<class USMStateInstance_Base*>* EntryStates) const;
	bool GetReuseCurrentState() const;
	bool GetReuseIfNotEndState() const;
	class USMInstance* GetStateMachineReference() const;
	bool GetWaitForEndState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SMStateMachineInstance">();
	}
	static class USMStateMachineInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USMStateMachineInstance>();
	}
};
static_assert(alignof(USMStateMachineInstance) == 0x000008, "Wrong alignment on USMStateMachineInstance");
static_assert(sizeof(USMStateMachineInstance) == 0x000118, "Wrong size on USMStateMachineInstance");
static_assert(offsetof(USMStateMachineInstance, Children) == 0x0000F0, "Member 'USMStateMachineInstance::Children' has a wrong offset!");
static_assert(offsetof(USMStateMachineInstance, TransitionList) == 0x000100, "Member 'USMStateMachineInstance::TransitionList' has a wrong offset!");

// Class SMSystem.ASMConditionBase
// 0x0008 (0x0038 - 0x0030)
class UASMConditionBase : public UObject
{
public:
	bool                                          Reverse;                                           // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASMConditionBase">();
	}
	static class UASMConditionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UASMConditionBase>();
	}
};
static_assert(alignof(UASMConditionBase) == 0x000008, "Wrong alignment on UASMConditionBase");
static_assert(sizeof(UASMConditionBase) == 0x000038, "Wrong size on UASMConditionBase");
static_assert(offsetof(UASMConditionBase, Reverse) == 0x000030, "Member 'UASMConditionBase::Reverse' has a wrong offset!");

// Class SMSystem.ASMConditionAnd
// 0x0010 (0x0048 - 0x0038)
class UASMConditionAnd final : public UASMConditionBase
{
public:
	TArray<class UASMConditionBase*>              Conditions;                                        // 0x0038(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASMConditionAnd">();
	}
	static class UASMConditionAnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UASMConditionAnd>();
	}
};
static_assert(alignof(UASMConditionAnd) == 0x000008, "Wrong alignment on UASMConditionAnd");
static_assert(sizeof(UASMConditionAnd) == 0x000048, "Wrong size on UASMConditionAnd");
static_assert(offsetof(UASMConditionAnd, Conditions) == 0x000038, "Member 'UASMConditionAnd::Conditions' has a wrong offset!");

// Class SMSystem.ASMConditionOr
// 0x0010 (0x0048 - 0x0038)
class UASMConditionOr final : public UASMConditionBase
{
public:
	TArray<class UASMConditionBase*>              Conditions;                                        // 0x0038(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASMConditionOr">();
	}
	static class UASMConditionOr* GetDefaultObj()
	{
		return GetDefaultObjImpl<UASMConditionOr>();
	}
};
static_assert(alignof(UASMConditionOr) == 0x000008, "Wrong alignment on UASMConditionOr");
static_assert(sizeof(UASMConditionOr) == 0x000048, "Wrong size on UASMConditionOr");
static_assert(offsetof(UASMConditionOr, Conditions) == 0x000038, "Member 'UASMConditionOr::Conditions' has a wrong offset!");

// Class SMSystem.SMTransitionInstance
// 0x0038 (0x0088 - 0x0050)
class USMTransitionInstance final : public USMNodeInstance
{
public:
	int32                                         PriorityOrder;                                     // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnTransitionEnteredEvent;                          // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	ETransitionPredictionType                     TransitionPredictionType;                          // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UASMConditionBase*                      Condition;                                         // 0x0070(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USMStateInstance_Base*                  From;                                              // 0x0078(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USMStateInstance_Base*                  To;                                                // 0x0080(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void EvaluateFromManuallyBoundEvent();
	void SetCanEvaluate(const bool bValue);
	void SetCanEvaluateFromEvent(const bool bValue);
	void SetCanEvalWithStartState(const bool bValue);
	void SetPriorityOrder(const int32 Value);

	bool DoesTransitionPass() const;
	bool GetCanEvaluate() const;
	bool GetCanEvaluateFromEvent() const;
	bool GetCanEvalWithStartState() const;
	class USMStateInstance_Base* GetDestinationStateForActiveTransition() const;
	class USMStateInstance_Base* GetNextStateInstance() const;
	class USMStateInstance_Base* GetPreviousStateInstance() const;
	int32 GetPriorityOrder() const;
	const struct FDateTime GetServerTimestamp() const;
	class USMStateInstance_Base* GetSourceStateForActiveTransition() const;
	void GetTransitionInfo(struct FSMTransitionInfo* Transition) const;
	bool IsTransitionFromAnyState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SMTransitionInstance">();
	}
	static class USMTransitionInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USMTransitionInstance>();
	}
};
static_assert(alignof(USMTransitionInstance) == 0x000008, "Wrong alignment on USMTransitionInstance");
static_assert(sizeof(USMTransitionInstance) == 0x000088, "Wrong size on USMTransitionInstance");
static_assert(offsetof(USMTransitionInstance, PriorityOrder) == 0x000050, "Member 'USMTransitionInstance::PriorityOrder' has a wrong offset!");
static_assert(offsetof(USMTransitionInstance, OnTransitionEnteredEvent) == 0x000058, "Member 'USMTransitionInstance::OnTransitionEnteredEvent' has a wrong offset!");
static_assert(offsetof(USMTransitionInstance, TransitionPredictionType) == 0x000068, "Member 'USMTransitionInstance::TransitionPredictionType' has a wrong offset!");
static_assert(offsetof(USMTransitionInstance, Condition) == 0x000070, "Member 'USMTransitionInstance::Condition' has a wrong offset!");
static_assert(offsetof(USMTransitionInstance, From) == 0x000078, "Member 'USMTransitionInstance::From' has a wrong offset!");
static_assert(offsetof(USMTransitionInstance, To) == 0x000080, "Member 'USMTransitionInstance::To' has a wrong offset!");

// Class SMSystem.SMBlueprintUtils
// 0x0000 (0x0030 - 0x0030)
class USMBlueprintUtils final : public UBlueprintFunctionLibrary
{
public:
	static class USMInstance* CreateStateMachineInstanceFromTemplate(TSubclassOf<class USMInstance> StateMachineClass, class UObject* Context, class USMInstance* Template, bool bInitializeNow);
	static class USMInstance* K2_CreateStateMachineInstance(TSubclassOf<class USMInstance> StateMachineClass, class UObject* Context, bool bInitializeNow);
	static class USMInstance* K2_CreateStateMachineInstancePure(TSubclassOf<class USMInstance> StateMachineClass, class UObject* Context, bool bInitializeNow);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SMBlueprintUtils">();
	}
	static class USMBlueprintUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<USMBlueprintUtils>();
	}
};
static_assert(alignof(USMBlueprintUtils) == 0x000008, "Wrong alignment on USMBlueprintUtils");
static_assert(sizeof(USMBlueprintUtils) == 0x000030, "Wrong size on USMBlueprintUtils");

}

