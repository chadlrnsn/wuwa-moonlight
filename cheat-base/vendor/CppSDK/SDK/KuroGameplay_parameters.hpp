#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroGameplay

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "KuroGameplay_structs.hpp"
#include "Niagara_structs.hpp"
#include "InputCore_structs.hpp"


namespace SDK::Params
{

// Function KuroGameplay.KuroEffectLibrary.AddSceneComponent
// 0x0028 (0x0028 - 0x0000)
struct KuroEffectLibrary_AddSceneComponent final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 Class_0;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        Parent;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeferredFinish;                                   // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        ReturnValue;                                       // 0x0020(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroEffectLibrary_AddSceneComponent) == 0x000008, "Wrong alignment on KuroEffectLibrary_AddSceneComponent");
static_assert(sizeof(KuroEffectLibrary_AddSceneComponent) == 0x000028, "Wrong size on KuroEffectLibrary_AddSceneComponent");
static_assert(offsetof(KuroEffectLibrary_AddSceneComponent, Actor) == 0x000000, "Member 'KuroEffectLibrary_AddSceneComponent::Actor' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_AddSceneComponent, Class_0) == 0x000008, "Member 'KuroEffectLibrary_AddSceneComponent::Class_0' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_AddSceneComponent, Parent) == 0x000010, "Member 'KuroEffectLibrary_AddSceneComponent::Parent' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_AddSceneComponent, bDeferredFinish) == 0x000018, "Member 'KuroEffectLibrary_AddSceneComponent::bDeferredFinish' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_AddSceneComponent, ReturnValue) == 0x000020, "Member 'KuroEffectLibrary_AddSceneComponent::ReturnValue' has a wrong offset!");

// Function KuroGameplay.KuroEffectLibrary.AddSceneComponentWithTransform
// 0x0060 (0x0060 - 0x0000)
struct KuroEffectLibrary_AddSceneComponentWithTransform final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 Class_0;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        Parent;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeferredFinish;                                   // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0020(0x0030)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class USceneComponent*                        ReturnValue;                                       // 0x0050(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroEffectLibrary_AddSceneComponentWithTransform) == 0x000010, "Wrong alignment on KuroEffectLibrary_AddSceneComponentWithTransform");
static_assert(sizeof(KuroEffectLibrary_AddSceneComponentWithTransform) == 0x000060, "Wrong size on KuroEffectLibrary_AddSceneComponentWithTransform");
static_assert(offsetof(KuroEffectLibrary_AddSceneComponentWithTransform, Actor) == 0x000000, "Member 'KuroEffectLibrary_AddSceneComponentWithTransform::Actor' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_AddSceneComponentWithTransform, Class_0) == 0x000008, "Member 'KuroEffectLibrary_AddSceneComponentWithTransform::Class_0' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_AddSceneComponentWithTransform, Parent) == 0x000010, "Member 'KuroEffectLibrary_AddSceneComponentWithTransform::Parent' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_AddSceneComponentWithTransform, bDeferredFinish) == 0x000018, "Member 'KuroEffectLibrary_AddSceneComponentWithTransform::bDeferredFinish' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_AddSceneComponentWithTransform, Transform) == 0x000020, "Member 'KuroEffectLibrary_AddSceneComponentWithTransform::Transform' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_AddSceneComponentWithTransform, ReturnValue) == 0x000050, "Member 'KuroEffectLibrary_AddSceneComponentWithTransform::ReturnValue' has a wrong offset!");

// Function KuroGameplay.KuroEffectLibrary.EqualWorld
// 0x0018 (0x0018 - 0x0000)
struct KuroEffectLibrary_EqualWorld final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWorld*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroEffectLibrary_EqualWorld) == 0x000008, "Wrong alignment on KuroEffectLibrary_EqualWorld");
static_assert(sizeof(KuroEffectLibrary_EqualWorld) == 0x000018, "Wrong size on KuroEffectLibrary_EqualWorld");
static_assert(offsetof(KuroEffectLibrary_EqualWorld, World) == 0x000000, "Member 'KuroEffectLibrary_EqualWorld::World' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_EqualWorld, Other) == 0x000008, "Member 'KuroEffectLibrary_EqualWorld::Other' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_EqualWorld, ReturnValue) == 0x000010, "Member 'KuroEffectLibrary_EqualWorld::ReturnValue' has a wrong offset!");

// Function KuroGameplay.KuroEffectLibrary.GetActorDefaultAttachComponent
// 0x0010 (0x0010 - 0x0000)
struct KuroEffectLibrary_GetActorDefaultAttachComponent final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroEffectLibrary_GetActorDefaultAttachComponent) == 0x000008, "Wrong alignment on KuroEffectLibrary_GetActorDefaultAttachComponent");
static_assert(sizeof(KuroEffectLibrary_GetActorDefaultAttachComponent) == 0x000010, "Wrong size on KuroEffectLibrary_GetActorDefaultAttachComponent");
static_assert(offsetof(KuroEffectLibrary_GetActorDefaultAttachComponent, Actor) == 0x000000, "Member 'KuroEffectLibrary_GetActorDefaultAttachComponent::Actor' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_GetActorDefaultAttachComponent, ReturnValue) == 0x000008, "Member 'KuroEffectLibrary_GetActorDefaultAttachComponent::ReturnValue' has a wrong offset!");

// Function KuroGameplay.KuroEffectLibrary.GetNiagaraEffectRegularTypeScalabilitySettingsMaxDistance
// 0x0008 (0x0008 - 0x0000)
struct KuroEffectLibrary_GetNiagaraEffectRegularTypeScalabilitySettingsMaxDistance final
{
public:
	EKuroNiagaraEffectRegularType                 EffectRegularType;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroEffectLibrary_GetNiagaraEffectRegularTypeScalabilitySettingsMaxDistance) == 0x000004, "Wrong alignment on KuroEffectLibrary_GetNiagaraEffectRegularTypeScalabilitySettingsMaxDistance");
static_assert(sizeof(KuroEffectLibrary_GetNiagaraEffectRegularTypeScalabilitySettingsMaxDistance) == 0x000008, "Wrong size on KuroEffectLibrary_GetNiagaraEffectRegularTypeScalabilitySettingsMaxDistance");
static_assert(offsetof(KuroEffectLibrary_GetNiagaraEffectRegularTypeScalabilitySettingsMaxDistance, EffectRegularType) == 0x000000, "Member 'KuroEffectLibrary_GetNiagaraEffectRegularTypeScalabilitySettingsMaxDistance::EffectRegularType' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_GetNiagaraEffectRegularTypeScalabilitySettingsMaxDistance, ReturnValue) == 0x000004, "Member 'KuroEffectLibrary_GetNiagaraEffectRegularTypeScalabilitySettingsMaxDistance::ReturnValue' has a wrong offset!");

// Function KuroGameplay.KuroEffectLibrary.GetNiagaraSystemEffectRegularType
// 0x0010 (0x0010 - 0x0000)
struct KuroEffectLibrary_GetNiagaraSystemEffectRegularType final
{
public:
	class UNiagaraSystem*                         NiagaraSystem;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroNiagaraEffectRegularType                 ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroEffectLibrary_GetNiagaraSystemEffectRegularType) == 0x000008, "Wrong alignment on KuroEffectLibrary_GetNiagaraSystemEffectRegularType");
static_assert(sizeof(KuroEffectLibrary_GetNiagaraSystemEffectRegularType) == 0x000010, "Wrong size on KuroEffectLibrary_GetNiagaraSystemEffectRegularType");
static_assert(offsetof(KuroEffectLibrary_GetNiagaraSystemEffectRegularType, NiagaraSystem) == 0x000000, "Member 'KuroEffectLibrary_GetNiagaraSystemEffectRegularType::NiagaraSystem' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_GetNiagaraSystemEffectRegularType, ReturnValue) == 0x000008, "Member 'KuroEffectLibrary_GetNiagaraSystemEffectRegularType::ReturnValue' has a wrong offset!");

// Function KuroGameplay.KuroEffectLibrary.GetNpcDisappearDistance
// 0x0004 (0x0004 - 0x0000)
struct KuroEffectLibrary_GetNpcDisappearDistance final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroEffectLibrary_GetNpcDisappearDistance) == 0x000004, "Wrong alignment on KuroEffectLibrary_GetNpcDisappearDistance");
static_assert(sizeof(KuroEffectLibrary_GetNpcDisappearDistance) == 0x000004, "Wrong size on KuroEffectLibrary_GetNpcDisappearDistance");
static_assert(offsetof(KuroEffectLibrary_GetNpcDisappearDistance, ReturnValue) == 0x000000, "Member 'KuroEffectLibrary_GetNpcDisappearDistance::ReturnValue' has a wrong offset!");

// Function KuroGameplay.KuroEffectLibrary.InitModelNiagaraSpec
// 0x0010 (0x0010 - 0x0000)
struct KuroEffectLibrary_InitModelNiagaraSpec final
{
public:
	class UNiagaraComponent*                      NiagaraComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUIScene;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReceivesDecals;                                   // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TranslucencySortPriority;                          // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroEffectLibrary_InitModelNiagaraSpec) == 0x000008, "Wrong alignment on KuroEffectLibrary_InitModelNiagaraSpec");
static_assert(sizeof(KuroEffectLibrary_InitModelNiagaraSpec) == 0x000010, "Wrong size on KuroEffectLibrary_InitModelNiagaraSpec");
static_assert(offsetof(KuroEffectLibrary_InitModelNiagaraSpec, NiagaraComponent) == 0x000000, "Member 'KuroEffectLibrary_InitModelNiagaraSpec::NiagaraComponent' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_InitModelNiagaraSpec, bUIScene) == 0x000008, "Member 'KuroEffectLibrary_InitModelNiagaraSpec::bUIScene' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_InitModelNiagaraSpec, bReceivesDecals) == 0x000009, "Member 'KuroEffectLibrary_InitModelNiagaraSpec::bReceivesDecals' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_InitModelNiagaraSpec, TranslucencySortPriority) == 0x00000C, "Member 'KuroEffectLibrary_InitModelNiagaraSpec::TranslucencySortPriority' has a wrong offset!");

// Function KuroGameplay.KuroEffectLibrary.IsNiagaraComponentHasBound
// 0x0010 (0x0010 - 0x0000)
struct KuroEffectLibrary_IsNiagaraComponentHasBound final
{
public:
	class UNiagaraComponent*                      NiagaraComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroEffectLibrary_IsNiagaraComponentHasBound) == 0x000008, "Wrong alignment on KuroEffectLibrary_IsNiagaraComponentHasBound");
static_assert(sizeof(KuroEffectLibrary_IsNiagaraComponentHasBound) == 0x000010, "Wrong size on KuroEffectLibrary_IsNiagaraComponentHasBound");
static_assert(offsetof(KuroEffectLibrary_IsNiagaraComponentHasBound, NiagaraComponent) == 0x000000, "Member 'KuroEffectLibrary_IsNiagaraComponentHasBound::NiagaraComponent' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_IsNiagaraComponentHasBound, ReturnValue) == 0x000008, "Member 'KuroEffectLibrary_IsNiagaraComponentHasBound::ReturnValue' has a wrong offset!");

// Function KuroGameplay.KuroEffectLibrary.RegisterOnSystemFinished
// 0x0008 (0x0008 - 0x0000)
struct KuroEffectLibrary_RegisterOnSystemFinished final
{
public:
	class UNiagaraComponent*                      NiagaraComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroEffectLibrary_RegisterOnSystemFinished) == 0x000008, "Wrong alignment on KuroEffectLibrary_RegisterOnSystemFinished");
static_assert(sizeof(KuroEffectLibrary_RegisterOnSystemFinished) == 0x000008, "Wrong size on KuroEffectLibrary_RegisterOnSystemFinished");
static_assert(offsetof(KuroEffectLibrary_RegisterOnSystemFinished, NiagaraComponent) == 0x000000, "Member 'KuroEffectLibrary_RegisterOnSystemFinished::NiagaraComponent' has a wrong offset!");

// Function KuroGameplay.KuroEffectLibrary.RegisterOnSystemPaused
// 0x0008 (0x0008 - 0x0000)
struct KuroEffectLibrary_RegisterOnSystemPaused final
{
public:
	class UNiagaraComponent*                      NiagaraComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroEffectLibrary_RegisterOnSystemPaused) == 0x000008, "Wrong alignment on KuroEffectLibrary_RegisterOnSystemPaused");
static_assert(sizeof(KuroEffectLibrary_RegisterOnSystemPaused) == 0x000008, "Wrong size on KuroEffectLibrary_RegisterOnSystemPaused");
static_assert(offsetof(KuroEffectLibrary_RegisterOnSystemPaused, NiagaraComponent) == 0x000000, "Member 'KuroEffectLibrary_RegisterOnSystemPaused::NiagaraComponent' has a wrong offset!");

// Function KuroGameplay.KuroEffectLibrary.SetNiagaraFrameDeltaTime
// 0x0010 (0x0010 - 0x0000)
struct KuroEffectLibrary_SetNiagaraFrameDeltaTime final
{
public:
	class UNiagaraComponent*                      NiagaraComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroEffectLibrary_SetNiagaraFrameDeltaTime) == 0x000008, "Wrong alignment on KuroEffectLibrary_SetNiagaraFrameDeltaTime");
static_assert(sizeof(KuroEffectLibrary_SetNiagaraFrameDeltaTime) == 0x000010, "Wrong size on KuroEffectLibrary_SetNiagaraFrameDeltaTime");
static_assert(offsetof(KuroEffectLibrary_SetNiagaraFrameDeltaTime, NiagaraComponent) == 0x000000, "Member 'KuroEffectLibrary_SetNiagaraFrameDeltaTime::NiagaraComponent' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_SetNiagaraFrameDeltaTime, DeltaTime) == 0x000008, "Member 'KuroEffectLibrary_SetNiagaraFrameDeltaTime::DeltaTime' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_SetNiagaraFrameDeltaTime, ReturnValue) == 0x00000C, "Member 'KuroEffectLibrary_SetNiagaraFrameDeltaTime::ReturnValue' has a wrong offset!");

// Function KuroGameplay.KuroEffectLibrary.SetOnSystemFinishedDelegate
// 0x0028 (0x0028 - 0x0000)
struct KuroEffectLibrary_SetOnSystemFinishedDelegate final
{
public:
	TDelegate<void(class UNiagaraComponent* NiagaraComponent)> Delegate;                                          // 0x0000(0x0028)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroEffectLibrary_SetOnSystemFinishedDelegate) == 0x000004, "Wrong alignment on KuroEffectLibrary_SetOnSystemFinishedDelegate");
static_assert(sizeof(KuroEffectLibrary_SetOnSystemFinishedDelegate) == 0x000028, "Wrong size on KuroEffectLibrary_SetOnSystemFinishedDelegate");
static_assert(offsetof(KuroEffectLibrary_SetOnSystemFinishedDelegate, Delegate) == 0x000000, "Member 'KuroEffectLibrary_SetOnSystemFinishedDelegate::Delegate' has a wrong offset!");

// Function KuroGameplay.KuroEffectLibrary.SetOnSystemPausedDelegate
// 0x0028 (0x0028 - 0x0000)
struct KuroEffectLibrary_SetOnSystemPausedDelegate final
{
public:
	TDelegate<void(class UNiagaraComponent* NiagaraComponent, bool IsPaused)> Delegate;                                          // 0x0000(0x0028)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroEffectLibrary_SetOnSystemPausedDelegate) == 0x000004, "Wrong alignment on KuroEffectLibrary_SetOnSystemPausedDelegate");
static_assert(sizeof(KuroEffectLibrary_SetOnSystemPausedDelegate) == 0x000028, "Wrong size on KuroEffectLibrary_SetOnSystemPausedDelegate");
static_assert(offsetof(KuroEffectLibrary_SetOnSystemPausedDelegate, Delegate) == 0x000000, "Member 'KuroEffectLibrary_SetOnSystemPausedDelegate::Delegate' has a wrong offset!");

// Function KuroGameplay.KuroEffectLibrary.UpdateEffectModelLightSpec
// 0x0020 (0x0020 - 0x0000)
struct KuroEffectLibrary_UpdateEffectModelLightSpec final
{
public:
	class UEffectModelLight*                      EffectModelLight;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPointLightComponent*                   LightComponent;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceUpdate;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Time;                                              // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultMaxLightRadius;                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroEffectLibrary_UpdateEffectModelLightSpec) == 0x000008, "Wrong alignment on KuroEffectLibrary_UpdateEffectModelLightSpec");
static_assert(sizeof(KuroEffectLibrary_UpdateEffectModelLightSpec) == 0x000020, "Wrong size on KuroEffectLibrary_UpdateEffectModelLightSpec");
static_assert(offsetof(KuroEffectLibrary_UpdateEffectModelLightSpec, EffectModelLight) == 0x000000, "Member 'KuroEffectLibrary_UpdateEffectModelLightSpec::EffectModelLight' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_UpdateEffectModelLightSpec, LightComponent) == 0x000008, "Member 'KuroEffectLibrary_UpdateEffectModelLightSpec::LightComponent' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_UpdateEffectModelLightSpec, bForceUpdate) == 0x000010, "Member 'KuroEffectLibrary_UpdateEffectModelLightSpec::bForceUpdate' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_UpdateEffectModelLightSpec, Time) == 0x000014, "Member 'KuroEffectLibrary_UpdateEffectModelLightSpec::Time' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_UpdateEffectModelLightSpec, DefaultMaxLightRadius) == 0x000018, "Member 'KuroEffectLibrary_UpdateEffectModelLightSpec::DefaultMaxLightRadius' has a wrong offset!");

// Function KuroGameplay.KuroEffectLibrary.UpdateEffectModelNiagaraSpec
// 0x0020 (0x0020 - 0x0000)
struct KuroEffectLibrary_UpdateEffectModelNiagaraSpec final
{
public:
	class UEffectModelNiagara*                    EffectModelNiagara;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NiagaraComponent;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceUpdate;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Time;                                              // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExtraState;                                        // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroEffectLibrary_UpdateEffectModelNiagaraSpec) == 0x000008, "Wrong alignment on KuroEffectLibrary_UpdateEffectModelNiagaraSpec");
static_assert(sizeof(KuroEffectLibrary_UpdateEffectModelNiagaraSpec) == 0x000020, "Wrong size on KuroEffectLibrary_UpdateEffectModelNiagaraSpec");
static_assert(offsetof(KuroEffectLibrary_UpdateEffectModelNiagaraSpec, EffectModelNiagara) == 0x000000, "Member 'KuroEffectLibrary_UpdateEffectModelNiagaraSpec::EffectModelNiagara' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_UpdateEffectModelNiagaraSpec, NiagaraComponent) == 0x000008, "Member 'KuroEffectLibrary_UpdateEffectModelNiagaraSpec::NiagaraComponent' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_UpdateEffectModelNiagaraSpec, bForceUpdate) == 0x000010, "Member 'KuroEffectLibrary_UpdateEffectModelNiagaraSpec::bForceUpdate' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_UpdateEffectModelNiagaraSpec, Time) == 0x000014, "Member 'KuroEffectLibrary_UpdateEffectModelNiagaraSpec::Time' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_UpdateEffectModelNiagaraSpec, ExtraState) == 0x000018, "Member 'KuroEffectLibrary_UpdateEffectModelNiagaraSpec::ExtraState' has a wrong offset!");

// Function KuroGameplay.KuroEffectLibrary.UpdateEffectModelPostProcessMaterial
// 0x0018 (0x0018 - 0x0000)
struct KuroEffectLibrary_UpdateEffectModelPostProcessMaterial final
{
public:
	class UEffectModelPostProcess*                EffectModelPostProcess;                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               DynMaterial;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceUpdate;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Time;                                              // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroEffectLibrary_UpdateEffectModelPostProcessMaterial) == 0x000008, "Wrong alignment on KuroEffectLibrary_UpdateEffectModelPostProcessMaterial");
static_assert(sizeof(KuroEffectLibrary_UpdateEffectModelPostProcessMaterial) == 0x000018, "Wrong size on KuroEffectLibrary_UpdateEffectModelPostProcessMaterial");
static_assert(offsetof(KuroEffectLibrary_UpdateEffectModelPostProcessMaterial, EffectModelPostProcess) == 0x000000, "Member 'KuroEffectLibrary_UpdateEffectModelPostProcessMaterial::EffectModelPostProcess' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_UpdateEffectModelPostProcessMaterial, DynMaterial) == 0x000008, "Member 'KuroEffectLibrary_UpdateEffectModelPostProcessMaterial::DynMaterial' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_UpdateEffectModelPostProcessMaterial, bForceUpdate) == 0x000010, "Member 'KuroEffectLibrary_UpdateEffectModelPostProcessMaterial::bForceUpdate' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_UpdateEffectModelPostProcessMaterial, Time) == 0x000014, "Member 'KuroEffectLibrary_UpdateEffectModelPostProcessMaterial::Time' has a wrong offset!");

// Function KuroGameplay.KuroEffectLibrary.UpdateEffectModelPostProcessSpec
// 0x0040 (0x0040 - 0x0000)
struct KuroEffectLibrary_UpdateEffectModelPostProcessSpec final
{
public:
	class UEffectModelPostProcess*                EffectModelPostProcess;                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKuroPostProcessComponent*              PostProcessComponent;                              // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceUpdate;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Time;                                              // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      Controller;                                        // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACharacter*                             Character;                                         // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 EffectActor;                                       // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LastScreenUV;                                      // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0038(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroEffectLibrary_UpdateEffectModelPostProcessSpec) == 0x000008, "Wrong alignment on KuroEffectLibrary_UpdateEffectModelPostProcessSpec");
static_assert(sizeof(KuroEffectLibrary_UpdateEffectModelPostProcessSpec) == 0x000040, "Wrong size on KuroEffectLibrary_UpdateEffectModelPostProcessSpec");
static_assert(offsetof(KuroEffectLibrary_UpdateEffectModelPostProcessSpec, EffectModelPostProcess) == 0x000000, "Member 'KuroEffectLibrary_UpdateEffectModelPostProcessSpec::EffectModelPostProcess' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_UpdateEffectModelPostProcessSpec, PostProcessComponent) == 0x000008, "Member 'KuroEffectLibrary_UpdateEffectModelPostProcessSpec::PostProcessComponent' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_UpdateEffectModelPostProcessSpec, bForceUpdate) == 0x000010, "Member 'KuroEffectLibrary_UpdateEffectModelPostProcessSpec::bForceUpdate' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_UpdateEffectModelPostProcessSpec, Time) == 0x000014, "Member 'KuroEffectLibrary_UpdateEffectModelPostProcessSpec::Time' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_UpdateEffectModelPostProcessSpec, Controller) == 0x000018, "Member 'KuroEffectLibrary_UpdateEffectModelPostProcessSpec::Controller' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_UpdateEffectModelPostProcessSpec, Character) == 0x000020, "Member 'KuroEffectLibrary_UpdateEffectModelPostProcessSpec::Character' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_UpdateEffectModelPostProcessSpec, EffectActor) == 0x000028, "Member 'KuroEffectLibrary_UpdateEffectModelPostProcessSpec::EffectActor' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_UpdateEffectModelPostProcessSpec, LastScreenUV) == 0x000030, "Member 'KuroEffectLibrary_UpdateEffectModelPostProcessSpec::LastScreenUV' has a wrong offset!");
static_assert(offsetof(KuroEffectLibrary_UpdateEffectModelPostProcessSpec, ReturnValue) == 0x000038, "Member 'KuroEffectLibrary_UpdateEffectModelPostProcessSpec::ReturnValue' has a wrong offset!");

// Function KuroGameplay.KuroInputEvent.DoActionCallback
// 0x0020 (0x0020 - 0x0000)
struct KuroInputEvent_DoActionCallback final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0020)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroInputEvent_DoActionCallback) == 0x000008, "Wrong alignment on KuroInputEvent_DoActionCallback");
static_assert(sizeof(KuroInputEvent_DoActionCallback) == 0x000020, "Wrong size on KuroInputEvent_DoActionCallback");
static_assert(offsetof(KuroInputEvent_DoActionCallback, Key) == 0x000000, "Member 'KuroInputEvent_DoActionCallback::Key' has a wrong offset!");

// Function KuroGameplay.KuroInputEvent.DoAxisCallback
// 0x0004 (0x0004 - 0x0000)
struct KuroInputEvent_DoAxisCallback final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroInputEvent_DoAxisCallback) == 0x000004, "Wrong alignment on KuroInputEvent_DoAxisCallback");
static_assert(sizeof(KuroInputEvent_DoAxisCallback) == 0x000004, "Wrong size on KuroInputEvent_DoAxisCallback");
static_assert(offsetof(KuroInputEvent_DoAxisCallback, Value) == 0x000000, "Member 'KuroInputEvent_DoAxisCallback::Value' has a wrong offset!");

// Function KuroGameplay.KuroInputEvent.DoKeyCallback
// 0x0020 (0x0020 - 0x0000)
struct KuroInputEvent_DoKeyCallback final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0020)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroInputEvent_DoKeyCallback) == 0x000008, "Wrong alignment on KuroInputEvent_DoKeyCallback");
static_assert(sizeof(KuroInputEvent_DoKeyCallback) == 0x000020, "Wrong size on KuroInputEvent_DoKeyCallback");
static_assert(offsetof(KuroInputEvent_DoKeyCallback, Key) == 0x000000, "Member 'KuroInputEvent_DoKeyCallback::Key' has a wrong offset!");

// Function KuroGameplay.KuroInputEvent.DoTouchCallback
// 0x0010 (0x0010 - 0x0000)
struct KuroInputEvent_DoTouchCallback final
{
public:
	ETouchIndex                                   TouchIndex;                                        // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Position;                                          // 0x0004(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroInputEvent_DoTouchCallback) == 0x000004, "Wrong alignment on KuroInputEvent_DoTouchCallback");
static_assert(sizeof(KuroInputEvent_DoTouchCallback) == 0x000010, "Wrong size on KuroInputEvent_DoTouchCallback");
static_assert(offsetof(KuroInputEvent_DoTouchCallback, TouchIndex) == 0x000000, "Member 'KuroInputEvent_DoTouchCallback::TouchIndex' has a wrong offset!");
static_assert(offsetof(KuroInputEvent_DoTouchCallback, Position) == 0x000004, "Member 'KuroInputEvent_DoTouchCallback::Position' has a wrong offset!");

// Function KuroGameplay.GameBudgetAllocator.AfterTickOutside
// 0x0004 (0x0004 - 0x0000)
struct GameBudgetAllocator_AfterTickOutside final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameBudgetAllocator_AfterTickOutside) == 0x000004, "Wrong alignment on GameBudgetAllocator_AfterTickOutside");
static_assert(sizeof(GameBudgetAllocator_AfterTickOutside) == 0x000004, "Wrong size on GameBudgetAllocator_AfterTickOutside");
static_assert(offsetof(GameBudgetAllocator_AfterTickOutside, DeltaSeconds) == 0x000000, "Member 'GameBudgetAllocator_AfterTickOutside::DeltaSeconds' has a wrong offset!");

// Function KuroGameplay.GameBudgetAllocator.SetCenterActor
// 0x0008 (0x0008 - 0x0000)
struct GameBudgetAllocator_SetCenterActor final
{
public:
	class AActor*                                 CenterActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameBudgetAllocator_SetCenterActor) == 0x000008, "Wrong alignment on GameBudgetAllocator_SetCenterActor");
static_assert(sizeof(GameBudgetAllocator_SetCenterActor) == 0x000008, "Wrong size on GameBudgetAllocator_SetCenterActor");
static_assert(offsetof(GameBudgetAllocator_SetCenterActor, CenterActor) == 0x000000, "Member 'GameBudgetAllocator_SetCenterActor::CenterActor' has a wrong offset!");

// Function KuroGameplay.GameBudgetAllocator.SetDefaultTickIntervalDetailConfig
// 0x0080 (0x0080 - 0x0000)
struct GameBudgetAllocator_SetDefaultTickIntervalDetailConfig final
{
public:
	struct FGameBudgetAllocatorGroupConfig        Config;                                            // 0x0000(0x0078)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	uint32                                        MaxTickInterval;                                   // 0x0078(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        TickReductionStartSize;                            // 0x007C(0x0002)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        TickReductionIntervalSize;                         // 0x007E(0x0002)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameBudgetAllocator_SetDefaultTickIntervalDetailConfig) == 0x000004, "Wrong alignment on GameBudgetAllocator_SetDefaultTickIntervalDetailConfig");
static_assert(sizeof(GameBudgetAllocator_SetDefaultTickIntervalDetailConfig) == 0x000080, "Wrong size on GameBudgetAllocator_SetDefaultTickIntervalDetailConfig");
static_assert(offsetof(GameBudgetAllocator_SetDefaultTickIntervalDetailConfig, Config) == 0x000000, "Member 'GameBudgetAllocator_SetDefaultTickIntervalDetailConfig::Config' has a wrong offset!");
static_assert(offsetof(GameBudgetAllocator_SetDefaultTickIntervalDetailConfig, MaxTickInterval) == 0x000078, "Member 'GameBudgetAllocator_SetDefaultTickIntervalDetailConfig::MaxTickInterval' has a wrong offset!");
static_assert(offsetof(GameBudgetAllocator_SetDefaultTickIntervalDetailConfig, TickReductionStartSize) == 0x00007C, "Member 'GameBudgetAllocator_SetDefaultTickIntervalDetailConfig::TickReductionStartSize' has a wrong offset!");
static_assert(offsetof(GameBudgetAllocator_SetDefaultTickIntervalDetailConfig, TickReductionIntervalSize) == 0x00007E, "Member 'GameBudgetAllocator_SetDefaultTickIntervalDetailConfig::TickReductionIntervalSize' has a wrong offset!");

// Function KuroGameplay.GameBudgetAllocator.SetGlobalMode
// 0x0001 (0x0001 - 0x0000)
struct GameBudgetAllocator_SetGlobalMode final
{
public:
	EGameBudgetAllocatorGlobalMode                Mode;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameBudgetAllocator_SetGlobalMode) == 0x000001, "Wrong alignment on GameBudgetAllocator_SetGlobalMode");
static_assert(sizeof(GameBudgetAllocator_SetGlobalMode) == 0x000001, "Wrong size on GameBudgetAllocator_SetGlobalMode");
static_assert(offsetof(GameBudgetAllocator_SetGlobalMode, Mode) == 0x000000, "Member 'GameBudgetAllocator_SetGlobalMode::Mode' has a wrong offset!");

// Function KuroGameplay.GameBudgetAllocator.SetGroupConfig
// 0x0084 (0x0084 - 0x0000)
struct GameBudgetAllocator_SetGroupConfig final
{
public:
	class FName                                   GroupName;                                         // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameBudgetAllocatorGroupConfig        Config;                                            // 0x000C(0x0078)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameBudgetAllocator_SetGroupConfig) == 0x000004, "Wrong alignment on GameBudgetAllocator_SetGroupConfig");
static_assert(sizeof(GameBudgetAllocator_SetGroupConfig) == 0x000084, "Wrong size on GameBudgetAllocator_SetGroupConfig");
static_assert(offsetof(GameBudgetAllocator_SetGroupConfig, GroupName) == 0x000000, "Member 'GameBudgetAllocator_SetGroupConfig::GroupName' has a wrong offset!");
static_assert(offsetof(GameBudgetAllocator_SetGroupConfig, Config) == 0x00000C, "Member 'GameBudgetAllocator_SetGroupConfig::Config' has a wrong offset!");

// Function KuroGameplay.GameBudgetAllocator.SetMaximumFrameRate
// 0x0004 (0x0004 - 0x0000)
struct GameBudgetAllocator_SetMaximumFrameRate final
{
public:
	uint32                                        MaxFPS;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameBudgetAllocator_SetMaximumFrameRate) == 0x000004, "Wrong alignment on GameBudgetAllocator_SetMaximumFrameRate");
static_assert(sizeof(GameBudgetAllocator_SetMaximumFrameRate) == 0x000004, "Wrong size on GameBudgetAllocator_SetMaximumFrameRate");
static_assert(offsetof(GameBudgetAllocator_SetMaximumFrameRate, MaxFPS) == 0x000000, "Member 'GameBudgetAllocator_SetMaximumFrameRate::MaxFPS' has a wrong offset!");

// Function KuroGameplay.GameBudgetAllocator.SetTickIntervalDetailConfig
// 0x0084 (0x0084 - 0x0000)
struct GameBudgetAllocator_SetTickIntervalDetailConfig final
{
public:
	struct FGameBudgetAllocatorGroupConfig        Config;                                            // 0x0000(0x0078)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	EGameBudgetAllocatorGlobalMode                GlobalMode;                                        // 0x0078(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameBudgetAllocatorActorMode                 ActorMode;                                         // 0x0079(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0x2];                                       // 0x007A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        MaxTickInterval;                                   // 0x007C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        TickReductionStartSize;                            // 0x0080(0x0002)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        TickReductionIntervalSize;                         // 0x0082(0x0002)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameBudgetAllocator_SetTickIntervalDetailConfig) == 0x000004, "Wrong alignment on GameBudgetAllocator_SetTickIntervalDetailConfig");
static_assert(sizeof(GameBudgetAllocator_SetTickIntervalDetailConfig) == 0x000084, "Wrong size on GameBudgetAllocator_SetTickIntervalDetailConfig");
static_assert(offsetof(GameBudgetAllocator_SetTickIntervalDetailConfig, Config) == 0x000000, "Member 'GameBudgetAllocator_SetTickIntervalDetailConfig::Config' has a wrong offset!");
static_assert(offsetof(GameBudgetAllocator_SetTickIntervalDetailConfig, GlobalMode) == 0x000078, "Member 'GameBudgetAllocator_SetTickIntervalDetailConfig::GlobalMode' has a wrong offset!");
static_assert(offsetof(GameBudgetAllocator_SetTickIntervalDetailConfig, ActorMode) == 0x000079, "Member 'GameBudgetAllocator_SetTickIntervalDetailConfig::ActorMode' has a wrong offset!");
static_assert(offsetof(GameBudgetAllocator_SetTickIntervalDetailConfig, MaxTickInterval) == 0x00007C, "Member 'GameBudgetAllocator_SetTickIntervalDetailConfig::MaxTickInterval' has a wrong offset!");
static_assert(offsetof(GameBudgetAllocator_SetTickIntervalDetailConfig, TickReductionStartSize) == 0x000080, "Member 'GameBudgetAllocator_SetTickIntervalDetailConfig::TickReductionStartSize' has a wrong offset!");
static_assert(offsetof(GameBudgetAllocator_SetTickIntervalDetailConfig, TickReductionIntervalSize) == 0x000082, "Member 'GameBudgetAllocator_SetTickIntervalDetailConfig::TickReductionIntervalSize' has a wrong offset!");

// Function KuroGameplay.GameBudgetAllocator.TickOutside
// 0x0004 (0x0004 - 0x0000)
struct GameBudgetAllocator_TickOutside final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameBudgetAllocator_TickOutside) == 0x000004, "Wrong alignment on GameBudgetAllocator_TickOutside");
static_assert(sizeof(GameBudgetAllocator_TickOutside) == 0x000004, "Wrong size on GameBudgetAllocator_TickOutside");
static_assert(offsetof(GameBudgetAllocator_TickOutside, DeltaSeconds) == 0x000000, "Member 'GameBudgetAllocator_TickOutside::DeltaSeconds' has a wrong offset!");

// Function KuroGameplay.GameBudgetAllocator.UpdateMinUpdateFIFOBudgetTime
// 0x0004 (0x0004 - 0x0000)
struct GameBudgetAllocator_UpdateMinUpdateFIFOBudgetTime final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameBudgetAllocator_UpdateMinUpdateFIFOBudgetTime) == 0x000004, "Wrong alignment on GameBudgetAllocator_UpdateMinUpdateFIFOBudgetTime");
static_assert(sizeof(GameBudgetAllocator_UpdateMinUpdateFIFOBudgetTime) == 0x000004, "Wrong size on GameBudgetAllocator_UpdateMinUpdateFIFOBudgetTime");
static_assert(offsetof(GameBudgetAllocator_UpdateMinUpdateFIFOBudgetTime, Time) == 0x000000, "Member 'GameBudgetAllocator_UpdateMinUpdateFIFOBudgetTime::Time' has a wrong offset!");

// Function KuroGameplay.KuroInputManager.OnActorDestroy
// 0x0008 (0x0008 - 0x0000)
struct KuroInputManager_OnActorDestroy final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroInputManager_OnActorDestroy) == 0x000008, "Wrong alignment on KuroInputManager_OnActorDestroy");
static_assert(sizeof(KuroInputManager_OnActorDestroy) == 0x000008, "Wrong size on KuroInputManager_OnActorDestroy");
static_assert(offsetof(KuroInputManager_OnActorDestroy, Actor) == 0x000000, "Member 'KuroInputManager_OnActorDestroy::Actor' has a wrong offset!");

// Function KuroGameplay.KuroLevelPlayLibrary.GetEntityIdByBaseItem
// 0x0010 (0x0010 - 0x0000)
struct KuroLevelPlayLibrary_GetEntityIdByBaseItem final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroLevelPlayLibrary_GetEntityIdByBaseItem) == 0x000008, "Wrong alignment on KuroLevelPlayLibrary_GetEntityIdByBaseItem");
static_assert(sizeof(KuroLevelPlayLibrary_GetEntityIdByBaseItem) == 0x000010, "Wrong size on KuroLevelPlayLibrary_GetEntityIdByBaseItem");
static_assert(offsetof(KuroLevelPlayLibrary_GetEntityIdByBaseItem, Actor) == 0x000000, "Member 'KuroLevelPlayLibrary_GetEntityIdByBaseItem::Actor' has a wrong offset!");
static_assert(offsetof(KuroLevelPlayLibrary_GetEntityIdByBaseItem, ReturnValue) == 0x000008, "Member 'KuroLevelPlayLibrary_GetEntityIdByBaseItem::ReturnValue' has a wrong offset!");

// Function KuroGameplay.KuroLevelPlayLibrary.RegisterBaseItemInfo
// 0x0018 (0x0018 - 0x0000)
struct KuroLevelPlayLibrary_RegisterBaseItemInfo final
{
public:
	class UClass*                                 BaseItemClass;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EntityIdName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroLevelPlayLibrary_RegisterBaseItemInfo) == 0x000008, "Wrong alignment on KuroLevelPlayLibrary_RegisterBaseItemInfo");
static_assert(sizeof(KuroLevelPlayLibrary_RegisterBaseItemInfo) == 0x000018, "Wrong size on KuroLevelPlayLibrary_RegisterBaseItemInfo");
static_assert(offsetof(KuroLevelPlayLibrary_RegisterBaseItemInfo, BaseItemClass) == 0x000000, "Member 'KuroLevelPlayLibrary_RegisterBaseItemInfo::BaseItemClass' has a wrong offset!");
static_assert(offsetof(KuroLevelPlayLibrary_RegisterBaseItemInfo, EntityIdName) == 0x000008, "Member 'KuroLevelPlayLibrary_RegisterBaseItemInfo::EntityIdName' has a wrong offset!");

// Function KuroGameplay.KuroMultilBgProgressBar.SetFillColorAndOpacity
// 0x0010 (0x0010 - 0x0000)
struct KuroMultilBgProgressBar_SetFillColorAndOpacity final
{
public:
	struct FLinearColor                           InColor;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMultilBgProgressBar_SetFillColorAndOpacity) == 0x000004, "Wrong alignment on KuroMultilBgProgressBar_SetFillColorAndOpacity");
static_assert(sizeof(KuroMultilBgProgressBar_SetFillColorAndOpacity) == 0x000010, "Wrong size on KuroMultilBgProgressBar_SetFillColorAndOpacity");
static_assert(offsetof(KuroMultilBgProgressBar_SetFillColorAndOpacity, InColor) == 0x000000, "Member 'KuroMultilBgProgressBar_SetFillColorAndOpacity::InColor' has a wrong offset!");

// Function KuroGameplay.KuroMultilBgProgressBar.SetIsMarquee
// 0x0001 (0x0001 - 0x0000)
struct KuroMultilBgProgressBar_SetIsMarquee final
{
public:
	bool                                          InbIsMarquee;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMultilBgProgressBar_SetIsMarquee) == 0x000001, "Wrong alignment on KuroMultilBgProgressBar_SetIsMarquee");
static_assert(sizeof(KuroMultilBgProgressBar_SetIsMarquee) == 0x000001, "Wrong size on KuroMultilBgProgressBar_SetIsMarquee");
static_assert(offsetof(KuroMultilBgProgressBar_SetIsMarquee, InbIsMarquee) == 0x000000, "Member 'KuroMultilBgProgressBar_SetIsMarquee::InbIsMarquee' has a wrong offset!");

// Function KuroGameplay.KuroMultilBgProgressBar.SetMiddlePercent
// 0x0004 (0x0004 - 0x0000)
struct KuroMultilBgProgressBar_SetMiddlePercent final
{
public:
	float                                         InPercent;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMultilBgProgressBar_SetMiddlePercent) == 0x000004, "Wrong alignment on KuroMultilBgProgressBar_SetMiddlePercent");
static_assert(sizeof(KuroMultilBgProgressBar_SetMiddlePercent) == 0x000004, "Wrong size on KuroMultilBgProgressBar_SetMiddlePercent");
static_assert(offsetof(KuroMultilBgProgressBar_SetMiddlePercent, InPercent) == 0x000000, "Member 'KuroMultilBgProgressBar_SetMiddlePercent::InPercent' has a wrong offset!");

// Function KuroGameplay.KuroMultilBgProgressBar.SetPercent
// 0x0004 (0x0004 - 0x0000)
struct KuroMultilBgProgressBar_SetPercent final
{
public:
	float                                         InPercent;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMultilBgProgressBar_SetPercent) == 0x000004, "Wrong alignment on KuroMultilBgProgressBar_SetPercent");
static_assert(sizeof(KuroMultilBgProgressBar_SetPercent) == 0x000004, "Wrong size on KuroMultilBgProgressBar_SetPercent");
static_assert(offsetof(KuroMultilBgProgressBar_SetPercent, InPercent) == 0x000000, "Member 'KuroMultilBgProgressBar_SetPercent::InPercent' has a wrong offset!");

// Function KuroGameplay.KuroResourceManager.GetAsset
// 0x0010 (0x0010 - 0x0000)
struct KuroResourceManager_GetAsset final
{
public:
	int32                                         HandleId;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroResourceManager_GetAsset) == 0x000008, "Wrong alignment on KuroResourceManager_GetAsset");
static_assert(sizeof(KuroResourceManager_GetAsset) == 0x000010, "Wrong size on KuroResourceManager_GetAsset");
static_assert(offsetof(KuroResourceManager_GetAsset, HandleId) == 0x000000, "Member 'KuroResourceManager_GetAsset::HandleId' has a wrong offset!");
static_assert(offsetof(KuroResourceManager_GetAsset, ReturnValue) == 0x000008, "Member 'KuroResourceManager_GetAsset::ReturnValue' has a wrong offset!");

// Function KuroGameplay.KuroResourceManager.LoadAsyncWithId
// 0x0020 (0x0020 - 0x0000)
struct KuroResourceManager_LoadAsyncWithId final
{
public:
	class FString                                 Path;                                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HandleId;                                          // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0014(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroResourceManager_LoadAsyncWithId) == 0x000008, "Wrong alignment on KuroResourceManager_LoadAsyncWithId");
static_assert(sizeof(KuroResourceManager_LoadAsyncWithId) == 0x000020, "Wrong size on KuroResourceManager_LoadAsyncWithId");
static_assert(offsetof(KuroResourceManager_LoadAsyncWithId, Path) == 0x000000, "Member 'KuroResourceManager_LoadAsyncWithId::Path' has a wrong offset!");
static_assert(offsetof(KuroResourceManager_LoadAsyncWithId, HandleId) == 0x000010, "Member 'KuroResourceManager_LoadAsyncWithId::HandleId' has a wrong offset!");
static_assert(offsetof(KuroResourceManager_LoadAsyncWithId, Priority) == 0x000014, "Member 'KuroResourceManager_LoadAsyncWithId::Priority' has a wrong offset!");
static_assert(offsetof(KuroResourceManager_LoadAsyncWithId, ReturnValue) == 0x000018, "Member 'KuroResourceManager_LoadAsyncWithId::ReturnValue' has a wrong offset!");

// Function KuroGameplay.KuroResourceManager.LoadWithId
// 0x0018 (0x0018 - 0x0000)
struct KuroResourceManager_LoadWithId final
{
public:
	class FString                                 Path;                                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HandleId;                                          // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroResourceManager_LoadWithId) == 0x000008, "Wrong alignment on KuroResourceManager_LoadWithId");
static_assert(sizeof(KuroResourceManager_LoadWithId) == 0x000018, "Wrong size on KuroResourceManager_LoadWithId");
static_assert(offsetof(KuroResourceManager_LoadWithId, Path) == 0x000000, "Member 'KuroResourceManager_LoadWithId::Path' has a wrong offset!");
static_assert(offsetof(KuroResourceManager_LoadWithId, HandleId) == 0x000010, "Member 'KuroResourceManager_LoadWithId::HandleId' has a wrong offset!");
static_assert(offsetof(KuroResourceManager_LoadWithId, ReturnValue) == 0x000014, "Member 'KuroResourceManager_LoadWithId::ReturnValue' has a wrong offset!");

// Function KuroGameplay.KuroResourceManager.Release
// 0x0004 (0x0004 - 0x0000)
struct KuroResourceManager_Release final
{
public:
	int32                                         HandleId;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroResourceManager_Release) == 0x000004, "Wrong alignment on KuroResourceManager_Release");
static_assert(sizeof(KuroResourceManager_Release) == 0x000004, "Wrong size on KuroResourceManager_Release");
static_assert(offsetof(KuroResourceManager_Release, HandleId) == 0x000000, "Member 'KuroResourceManager_Release::HandleId' has a wrong offset!");

// Function KuroGameplay.KuroResourceManager.WaitComplete
// 0x000C (0x000C - 0x0000)
struct KuroResourceManager_WaitComplete final
{
public:
	int32                                         HandleId;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timeout;                                           // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroResourceManager_WaitComplete) == 0x000004, "Wrong alignment on KuroResourceManager_WaitComplete");
static_assert(sizeof(KuroResourceManager_WaitComplete) == 0x00000C, "Wrong size on KuroResourceManager_WaitComplete");
static_assert(offsetof(KuroResourceManager_WaitComplete, HandleId) == 0x000000, "Member 'KuroResourceManager_WaitComplete::HandleId' has a wrong offset!");
static_assert(offsetof(KuroResourceManager_WaitComplete, Timeout) == 0x000004, "Member 'KuroResourceManager_WaitComplete::Timeout' has a wrong offset!");
static_assert(offsetof(KuroResourceManager_WaitComplete, ReturnValue) == 0x000008, "Member 'KuroResourceManager_WaitComplete::ReturnValue' has a wrong offset!");

// Function KuroGameplay.KuroResourceManager.GetLoadedAsset
// 0x0018 (0x0018 - 0x0000)
struct KuroResourceManager_GetLoadedAsset final
{
public:
	class FString                                 Path;                                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroResourceManager_GetLoadedAsset) == 0x000008, "Wrong alignment on KuroResourceManager_GetLoadedAsset");
static_assert(sizeof(KuroResourceManager_GetLoadedAsset) == 0x000018, "Wrong size on KuroResourceManager_GetLoadedAsset");
static_assert(offsetof(KuroResourceManager_GetLoadedAsset, Path) == 0x000000, "Member 'KuroResourceManager_GetLoadedAsset::Path' has a wrong offset!");
static_assert(offsetof(KuroResourceManager_GetLoadedAsset, ReturnValue) == 0x000010, "Member 'KuroResourceManager_GetLoadedAsset::ReturnValue' has a wrong offset!");

// Function KuroGameplay.KuroSequencePerformanceManager.EditPerformanceConfiguration
// 0x0010 (0x0010 - 0x0000)
struct KuroSequencePerformanceManager_EditPerformanceConfiguration final
{
public:
	TArray<class FString>                         CmdArray;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSequencePerformanceManager_EditPerformanceConfiguration) == 0x000008, "Wrong alignment on KuroSequencePerformanceManager_EditPerformanceConfiguration");
static_assert(sizeof(KuroSequencePerformanceManager_EditPerformanceConfiguration) == 0x000010, "Wrong size on KuroSequencePerformanceManager_EditPerformanceConfiguration");
static_assert(offsetof(KuroSequencePerformanceManager_EditPerformanceConfiguration, CmdArray) == 0x000000, "Member 'KuroSequencePerformanceManager_EditPerformanceConfiguration::CmdArray' has a wrong offset!");

// Function KuroGameplay.KuroSequencePerformanceManager.ExecuteCommandInPerformance
// 0x0020 (0x0020 - 0x0000)
struct KuroSequencePerformanceManager_ExecuteCommandInPerformance final
{
public:
	class FString                                 Command;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CommandOriginalValue;                              // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSequencePerformanceManager_ExecuteCommandInPerformance) == 0x000008, "Wrong alignment on KuroSequencePerformanceManager_ExecuteCommandInPerformance");
static_assert(sizeof(KuroSequencePerformanceManager_ExecuteCommandInPerformance) == 0x000020, "Wrong size on KuroSequencePerformanceManager_ExecuteCommandInPerformance");
static_assert(offsetof(KuroSequencePerformanceManager_ExecuteCommandInPerformance, Command) == 0x000000, "Member 'KuroSequencePerformanceManager_ExecuteCommandInPerformance::Command' has a wrong offset!");
static_assert(offsetof(KuroSequencePerformanceManager_ExecuteCommandInPerformance, CommandOriginalValue) == 0x000010, "Member 'KuroSequencePerformanceManager_ExecuteCommandInPerformance::CommandOriginalValue' has a wrong offset!");

// Function KuroGameplay.KuroSequencePerformanceManager.GetPerformanceMode
// 0x0001 (0x0001 - 0x0000)
struct KuroSequencePerformanceManager_GetPerformanceMode final
{
public:
	EKuroPerformanceMode                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSequencePerformanceManager_GetPerformanceMode) == 0x000001, "Wrong alignment on KuroSequencePerformanceManager_GetPerformanceMode");
static_assert(sizeof(KuroSequencePerformanceManager_GetPerformanceMode) == 0x000001, "Wrong size on KuroSequencePerformanceManager_GetPerformanceMode");
static_assert(offsetof(KuroSequencePerformanceManager_GetPerformanceMode, ReturnValue) == 0x000000, "Member 'KuroSequencePerformanceManager_GetPerformanceMode::ReturnValue' has a wrong offset!");

// Function KuroGameplay.KuroSequencePerformanceManager.SetPerformanceMode
// 0x0001 (0x0001 - 0x0000)
struct KuroSequencePerformanceManager_SetPerformanceMode final
{
public:
	EKuroPerformanceMode                          CurrentPerformanceMode;                            // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSequencePerformanceManager_SetPerformanceMode) == 0x000001, "Wrong alignment on KuroSequencePerformanceManager_SetPerformanceMode");
static_assert(sizeof(KuroSequencePerformanceManager_SetPerformanceMode) == 0x000001, "Wrong size on KuroSequencePerformanceManager_SetPerformanceMode");
static_assert(offsetof(KuroSequencePerformanceManager_SetPerformanceMode, CurrentPerformanceMode) == 0x000000, "Member 'KuroSequencePerformanceManager_SetPerformanceMode::CurrentPerformanceMode' has a wrong offset!");

// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.FindBindingById
// 0x0030 (0x0030 - 0x0000)
struct KuroSequenceRuntimeFunctionLibrary_FindBindingById final
{
public:
	class UMovieSceneSequence*                    Sequence;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  BindingId;                                         // 0x0008(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSequencerBindingRuntimeProxy          ReturnValue;                                       // 0x0018(0x0018)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSequenceRuntimeFunctionLibrary_FindBindingById) == 0x000008, "Wrong alignment on KuroSequenceRuntimeFunctionLibrary_FindBindingById");
static_assert(sizeof(KuroSequenceRuntimeFunctionLibrary_FindBindingById) == 0x000030, "Wrong size on KuroSequenceRuntimeFunctionLibrary_FindBindingById");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_FindBindingById, Sequence) == 0x000000, "Member 'KuroSequenceRuntimeFunctionLibrary_FindBindingById::Sequence' has a wrong offset!");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_FindBindingById, BindingId) == 0x000008, "Member 'KuroSequenceRuntimeFunctionLibrary_FindBindingById::BindingId' has a wrong offset!");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_FindBindingById, ReturnValue) == 0x000018, "Member 'KuroSequenceRuntimeFunctionLibrary_FindBindingById::ReturnValue' has a wrong offset!");

// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.FindMasterTracksByType
// 0x0020 (0x0020 - 0x0000)
struct KuroSequenceRuntimeFunctionLibrary_FindMasterTracksByType final
{
public:
	class UMovieSceneSequence*                    Sequence;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMovieSceneTrack>           TrackType;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMovieSceneTrack*>               ReturnValue;                                       // 0x0010(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSequenceRuntimeFunctionLibrary_FindMasterTracksByType) == 0x000008, "Wrong alignment on KuroSequenceRuntimeFunctionLibrary_FindMasterTracksByType");
static_assert(sizeof(KuroSequenceRuntimeFunctionLibrary_FindMasterTracksByType) == 0x000020, "Wrong size on KuroSequenceRuntimeFunctionLibrary_FindMasterTracksByType");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_FindMasterTracksByType, Sequence) == 0x000000, "Member 'KuroSequenceRuntimeFunctionLibrary_FindMasterTracksByType::Sequence' has a wrong offset!");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_FindMasterTracksByType, TrackType) == 0x000008, "Member 'KuroSequenceRuntimeFunctionLibrary_FindMasterTracksByType::TrackType' has a wrong offset!");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_FindMasterTracksByType, ReturnValue) == 0x000010, "Member 'KuroSequenceRuntimeFunctionLibrary_FindMasterTracksByType::ReturnValue' has a wrong offset!");

// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.FindTracksByType
// 0x0030 (0x0030 - 0x0000)
struct KuroSequenceRuntimeFunctionLibrary_FindTracksByType final
{
public:
	struct FSequencerBindingRuntimeProxy          InBinding;                                         // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UMovieSceneTrack>           TrackType;                                         // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMovieSceneTrack*>               ReturnValue;                                       // 0x0020(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSequenceRuntimeFunctionLibrary_FindTracksByType) == 0x000008, "Wrong alignment on KuroSequenceRuntimeFunctionLibrary_FindTracksByType");
static_assert(sizeof(KuroSequenceRuntimeFunctionLibrary_FindTracksByType) == 0x000030, "Wrong size on KuroSequenceRuntimeFunctionLibrary_FindTracksByType");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_FindTracksByType, InBinding) == 0x000000, "Member 'KuroSequenceRuntimeFunctionLibrary_FindTracksByType::InBinding' has a wrong offset!");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_FindTracksByType, TrackType) == 0x000018, "Member 'KuroSequenceRuntimeFunctionLibrary_FindTracksByType::TrackType' has a wrong offset!");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_FindTracksByType, ReturnValue) == 0x000020, "Member 'KuroSequenceRuntimeFunctionLibrary_FindTracksByType::ReturnValue' has a wrong offset!");

// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.GetEndFrame
// 0x0010 (0x0010 - 0x0000)
struct KuroSequenceRuntimeFunctionLibrary_GetEndFrame final
{
public:
	class UMovieSceneSection*                     Section;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroSequenceRuntimeFunctionLibrary_GetEndFrame) == 0x000008, "Wrong alignment on KuroSequenceRuntimeFunctionLibrary_GetEndFrame");
static_assert(sizeof(KuroSequenceRuntimeFunctionLibrary_GetEndFrame) == 0x000010, "Wrong size on KuroSequenceRuntimeFunctionLibrary_GetEndFrame");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_GetEndFrame, Section) == 0x000000, "Member 'KuroSequenceRuntimeFunctionLibrary_GetEndFrame::Section' has a wrong offset!");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_GetEndFrame, ReturnValue) == 0x000008, "Member 'KuroSequenceRuntimeFunctionLibrary_GetEndFrame::ReturnValue' has a wrong offset!");

// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.GetFadeAmountAt
// 0x0018 (0x0018 - 0x0000)
struct KuroSequenceRuntimeFunctionLibrary_GetFadeAmountAt final
{
public:
	class UMovieSceneFadeSection*                 Section;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFrameTime                             Frame;                                             // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroSequenceRuntimeFunctionLibrary_GetFadeAmountAt) == 0x000008, "Wrong alignment on KuroSequenceRuntimeFunctionLibrary_GetFadeAmountAt");
static_assert(sizeof(KuroSequenceRuntimeFunctionLibrary_GetFadeAmountAt) == 0x000018, "Wrong size on KuroSequenceRuntimeFunctionLibrary_GetFadeAmountAt");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_GetFadeAmountAt, Section) == 0x000000, "Member 'KuroSequenceRuntimeFunctionLibrary_GetFadeAmountAt::Section' has a wrong offset!");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_GetFadeAmountAt, Frame) == 0x000008, "Member 'KuroSequenceRuntimeFunctionLibrary_GetFadeAmountAt::Frame' has a wrong offset!");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_GetFadeAmountAt, ReturnValue) == 0x000010, "Member 'KuroSequenceRuntimeFunctionLibrary_GetFadeAmountAt::ReturnValue' has a wrong offset!");

// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.GetFrameTransform
// 0x0040 (0x0040 - 0x0000)
struct KuroSequenceRuntimeFunctionLibrary_GetFrameTransform final
{
public:
	class UMovieSceneTrack*                       Track;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFrameTime                             Frame;                                             // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             ReturnValue;                                       // 0x0010(0x0030)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSequenceRuntimeFunctionLibrary_GetFrameTransform) == 0x000010, "Wrong alignment on KuroSequenceRuntimeFunctionLibrary_GetFrameTransform");
static_assert(sizeof(KuroSequenceRuntimeFunctionLibrary_GetFrameTransform) == 0x000040, "Wrong size on KuroSequenceRuntimeFunctionLibrary_GetFrameTransform");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_GetFrameTransform, Track) == 0x000000, "Member 'KuroSequenceRuntimeFunctionLibrary_GetFrameTransform::Track' has a wrong offset!");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_GetFrameTransform, Frame) == 0x000008, "Member 'KuroSequenceRuntimeFunctionLibrary_GetFrameTransform::Frame' has a wrong offset!");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_GetFrameTransform, ReturnValue) == 0x000010, "Member 'KuroSequenceRuntimeFunctionLibrary_GetFrameTransform::ReturnValue' has a wrong offset!");

// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.GetFrameTransformByTag
// 0x0060 (0x0060 - 0x0000)
struct KuroSequenceRuntimeFunctionLibrary_GetFrameTransformByTag final
{
public:
	class UMovieSceneSequence*                    Sequence;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutsideFrame;                                      // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             OutTransfom;                                       // 0x0020(0x0030)(Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0050(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0xF];                                       // 0x0051(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroSequenceRuntimeFunctionLibrary_GetFrameTransformByTag) == 0x000010, "Wrong alignment on KuroSequenceRuntimeFunctionLibrary_GetFrameTransformByTag");
static_assert(sizeof(KuroSequenceRuntimeFunctionLibrary_GetFrameTransformByTag) == 0x000060, "Wrong size on KuroSequenceRuntimeFunctionLibrary_GetFrameTransformByTag");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_GetFrameTransformByTag, Sequence) == 0x000000, "Member 'KuroSequenceRuntimeFunctionLibrary_GetFrameTransformByTag::Sequence' has a wrong offset!");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_GetFrameTransformByTag, Tag) == 0x000008, "Member 'KuroSequenceRuntimeFunctionLibrary_GetFrameTransformByTag::Tag' has a wrong offset!");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_GetFrameTransformByTag, OutsideFrame) == 0x000014, "Member 'KuroSequenceRuntimeFunctionLibrary_GetFrameTransformByTag::OutsideFrame' has a wrong offset!");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_GetFrameTransformByTag, OutTransfom) == 0x000020, "Member 'KuroSequenceRuntimeFunctionLibrary_GetFrameTransformByTag::OutTransfom' has a wrong offset!");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_GetFrameTransformByTag, ReturnValue) == 0x000050, "Member 'KuroSequenceRuntimeFunctionLibrary_GetFrameTransformByTag::ReturnValue' has a wrong offset!");

// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.GetMasterTracks
// 0x0018 (0x0018 - 0x0000)
struct KuroSequenceRuntimeFunctionLibrary_GetMasterTracks final
{
public:
	class UMovieSceneSequence*                    Sequence;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMovieSceneTrack*>               ReturnValue;                                       // 0x0008(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSequenceRuntimeFunctionLibrary_GetMasterTracks) == 0x000008, "Wrong alignment on KuroSequenceRuntimeFunctionLibrary_GetMasterTracks");
static_assert(sizeof(KuroSequenceRuntimeFunctionLibrary_GetMasterTracks) == 0x000018, "Wrong size on KuroSequenceRuntimeFunctionLibrary_GetMasterTracks");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_GetMasterTracks, Sequence) == 0x000000, "Member 'KuroSequenceRuntimeFunctionLibrary_GetMasterTracks::Sequence' has a wrong offset!");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_GetMasterTracks, ReturnValue) == 0x000008, "Member 'KuroSequenceRuntimeFunctionLibrary_GetMasterTracks::ReturnValue' has a wrong offset!");

// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.GetObjectTemplate
// 0x0020 (0x0020 - 0x0000)
struct KuroSequenceRuntimeFunctionLibrary_GetObjectTemplate final
{
public:
	struct FSequencerBindingRuntimeProxy          InBinding;                                         // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSequenceRuntimeFunctionLibrary_GetObjectTemplate) == 0x000008, "Wrong alignment on KuroSequenceRuntimeFunctionLibrary_GetObjectTemplate");
static_assert(sizeof(KuroSequenceRuntimeFunctionLibrary_GetObjectTemplate) == 0x000020, "Wrong size on KuroSequenceRuntimeFunctionLibrary_GetObjectTemplate");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_GetObjectTemplate, InBinding) == 0x000000, "Member 'KuroSequenceRuntimeFunctionLibrary_GetObjectTemplate::InBinding' has a wrong offset!");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_GetObjectTemplate, ReturnValue) == 0x000018, "Member 'KuroSequenceRuntimeFunctionLibrary_GetObjectTemplate::ReturnValue' has a wrong offset!");

// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.GetPlaybackEnd
// 0x0010 (0x0010 - 0x0000)
struct KuroSequenceRuntimeFunctionLibrary_GetPlaybackEnd final
{
public:
	class UMovieSceneSequence*                    Sequence;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroSequenceRuntimeFunctionLibrary_GetPlaybackEnd) == 0x000008, "Wrong alignment on KuroSequenceRuntimeFunctionLibrary_GetPlaybackEnd");
static_assert(sizeof(KuroSequenceRuntimeFunctionLibrary_GetPlaybackEnd) == 0x000010, "Wrong size on KuroSequenceRuntimeFunctionLibrary_GetPlaybackEnd");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_GetPlaybackEnd, Sequence) == 0x000000, "Member 'KuroSequenceRuntimeFunctionLibrary_GetPlaybackEnd::Sequence' has a wrong offset!");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_GetPlaybackEnd, ReturnValue) == 0x000008, "Member 'KuroSequenceRuntimeFunctionLibrary_GetPlaybackEnd::ReturnValue' has a wrong offset!");

// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.GetPlaybackStart
// 0x0010 (0x0010 - 0x0000)
struct KuroSequenceRuntimeFunctionLibrary_GetPlaybackStart final
{
public:
	class UMovieSceneSequence*                    Sequence;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroSequenceRuntimeFunctionLibrary_GetPlaybackStart) == 0x000008, "Wrong alignment on KuroSequenceRuntimeFunctionLibrary_GetPlaybackStart");
static_assert(sizeof(KuroSequenceRuntimeFunctionLibrary_GetPlaybackStart) == 0x000010, "Wrong size on KuroSequenceRuntimeFunctionLibrary_GetPlaybackStart");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_GetPlaybackStart, Sequence) == 0x000000, "Member 'KuroSequenceRuntimeFunctionLibrary_GetPlaybackStart::Sequence' has a wrong offset!");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_GetPlaybackStart, ReturnValue) == 0x000008, "Member 'KuroSequenceRuntimeFunctionLibrary_GetPlaybackStart::ReturnValue' has a wrong offset!");

// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.GetSections
// 0x0018 (0x0018 - 0x0000)
struct KuroSequenceRuntimeFunctionLibrary_GetSections final
{
public:
	class UMovieSceneTrack*                       Track;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMovieSceneSection*>             ReturnValue;                                       // 0x0008(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSequenceRuntimeFunctionLibrary_GetSections) == 0x000008, "Wrong alignment on KuroSequenceRuntimeFunctionLibrary_GetSections");
static_assert(sizeof(KuroSequenceRuntimeFunctionLibrary_GetSections) == 0x000018, "Wrong size on KuroSequenceRuntimeFunctionLibrary_GetSections");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_GetSections, Track) == 0x000000, "Member 'KuroSequenceRuntimeFunctionLibrary_GetSections::Track' has a wrong offset!");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_GetSections, ReturnValue) == 0x000008, "Member 'KuroSequenceRuntimeFunctionLibrary_GetSections::ReturnValue' has a wrong offset!");

// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.GetSpawnables
// 0x0018 (0x0018 - 0x0000)
struct KuroSequenceRuntimeFunctionLibrary_GetSpawnables final
{
public:
	class UMovieSceneSequence*                    Sequence;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSequencerBindingRuntimeProxy>  ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSequenceRuntimeFunctionLibrary_GetSpawnables) == 0x000008, "Wrong alignment on KuroSequenceRuntimeFunctionLibrary_GetSpawnables");
static_assert(sizeof(KuroSequenceRuntimeFunctionLibrary_GetSpawnables) == 0x000018, "Wrong size on KuroSequenceRuntimeFunctionLibrary_GetSpawnables");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_GetSpawnables, Sequence) == 0x000000, "Member 'KuroSequenceRuntimeFunctionLibrary_GetSpawnables::Sequence' has a wrong offset!");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_GetSpawnables, ReturnValue) == 0x000008, "Member 'KuroSequenceRuntimeFunctionLibrary_GetSpawnables::ReturnValue' has a wrong offset!");

// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.GetStartFrame
// 0x0010 (0x0010 - 0x0000)
struct KuroSequenceRuntimeFunctionLibrary_GetStartFrame final
{
public:
	class UMovieSceneSection*                     Section;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroSequenceRuntimeFunctionLibrary_GetStartFrame) == 0x000008, "Wrong alignment on KuroSequenceRuntimeFunctionLibrary_GetStartFrame");
static_assert(sizeof(KuroSequenceRuntimeFunctionLibrary_GetStartFrame) == 0x000010, "Wrong size on KuroSequenceRuntimeFunctionLibrary_GetStartFrame");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_GetStartFrame, Section) == 0x000000, "Member 'KuroSequenceRuntimeFunctionLibrary_GetStartFrame::Section' has a wrong offset!");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_GetStartFrame, ReturnValue) == 0x000008, "Member 'KuroSequenceRuntimeFunctionLibrary_GetStartFrame::ReturnValue' has a wrong offset!");

// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.GetTracks
// 0x0028 (0x0028 - 0x0000)
struct KuroSequenceRuntimeFunctionLibrary_GetTracks final
{
public:
	struct FSequencerBindingRuntimeProxy          InBinding;                                         // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class UMovieSceneTrack*>               ReturnValue;                                       // 0x0018(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSequenceRuntimeFunctionLibrary_GetTracks) == 0x000008, "Wrong alignment on KuroSequenceRuntimeFunctionLibrary_GetTracks");
static_assert(sizeof(KuroSequenceRuntimeFunctionLibrary_GetTracks) == 0x000028, "Wrong size on KuroSequenceRuntimeFunctionLibrary_GetTracks");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_GetTracks, InBinding) == 0x000000, "Member 'KuroSequenceRuntimeFunctionLibrary_GetTracks::InBinding' has a wrong offset!");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_GetTracks, ReturnValue) == 0x000018, "Member 'KuroSequenceRuntimeFunctionLibrary_GetTracks::ReturnValue' has a wrong offset!");

// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.HandleSeqTexStreaming
// 0x0010 (0x0010 - 0x0000)
struct KuroSequenceRuntimeFunctionLibrary_HandleSeqTexStreaming final
{
public:
	const class ULevelSequence*                   LevelSequences;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartForceStreamIn;                               // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroSequenceRuntimeFunctionLibrary_HandleSeqTexStreaming) == 0x000008, "Wrong alignment on KuroSequenceRuntimeFunctionLibrary_HandleSeqTexStreaming");
static_assert(sizeof(KuroSequenceRuntimeFunctionLibrary_HandleSeqTexStreaming) == 0x000010, "Wrong size on KuroSequenceRuntimeFunctionLibrary_HandleSeqTexStreaming");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_HandleSeqTexStreaming, LevelSequences) == 0x000000, "Member 'KuroSequenceRuntimeFunctionLibrary_HandleSeqTexStreaming::LevelSequences' has a wrong offset!");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_HandleSeqTexStreaming, bStartForceStreamIn) == 0x000008, "Member 'KuroSequenceRuntimeFunctionLibrary_HandleSeqTexStreaming::bStartForceStreamIn' has a wrong offset!");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_HandleSeqTexStreaming, ReturnValue) == 0x000009, "Member 'KuroSequenceRuntimeFunctionLibrary_HandleSeqTexStreaming::ReturnValue' has a wrong offset!");

// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.MuteTrackByTag
// 0x0018 (0x0018 - 0x0000)
struct KuroSequenceRuntimeFunctionLibrary_MuteTrackByTag final
{
public:
	class UMovieSceneSequence*                    Sequence;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMuted;                                          // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroSequenceRuntimeFunctionLibrary_MuteTrackByTag) == 0x000008, "Wrong alignment on KuroSequenceRuntimeFunctionLibrary_MuteTrackByTag");
static_assert(sizeof(KuroSequenceRuntimeFunctionLibrary_MuteTrackByTag) == 0x000018, "Wrong size on KuroSequenceRuntimeFunctionLibrary_MuteTrackByTag");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_MuteTrackByTag, Sequence) == 0x000000, "Member 'KuroSequenceRuntimeFunctionLibrary_MuteTrackByTag::Sequence' has a wrong offset!");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_MuteTrackByTag, Tag) == 0x000008, "Member 'KuroSequenceRuntimeFunctionLibrary_MuteTrackByTag::Tag' has a wrong offset!");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_MuteTrackByTag, bIsMuted) == 0x000014, "Member 'KuroSequenceRuntimeFunctionLibrary_MuteTrackByTag::bIsMuted' has a wrong offset!");

// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.ResetMovieSceneCompiledData
// 0x0008 (0x0008 - 0x0000)
struct KuroSequenceRuntimeFunctionLibrary_ResetMovieSceneCompiledData final
{
public:
	class UMovieSceneSequence*                    Sequence;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSequenceRuntimeFunctionLibrary_ResetMovieSceneCompiledData) == 0x000008, "Wrong alignment on KuroSequenceRuntimeFunctionLibrary_ResetMovieSceneCompiledData");
static_assert(sizeof(KuroSequenceRuntimeFunctionLibrary_ResetMovieSceneCompiledData) == 0x000008, "Wrong size on KuroSequenceRuntimeFunctionLibrary_ResetMovieSceneCompiledData");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_ResetMovieSceneCompiledData, Sequence) == 0x000000, "Member 'KuroSequenceRuntimeFunctionLibrary_ResetMovieSceneCompiledData::Sequence' has a wrong offset!");

// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.SectionContains
// 0x0018 (0x0018 - 0x0000)
struct KuroSequenceRuntimeFunctionLibrary_SectionContains final
{
public:
	class UMovieSceneSection*                     Section;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFrameTime                             Frame;                                             // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroSequenceRuntimeFunctionLibrary_SectionContains) == 0x000008, "Wrong alignment on KuroSequenceRuntimeFunctionLibrary_SectionContains");
static_assert(sizeof(KuroSequenceRuntimeFunctionLibrary_SectionContains) == 0x000018, "Wrong size on KuroSequenceRuntimeFunctionLibrary_SectionContains");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_SectionContains, Section) == 0x000000, "Member 'KuroSequenceRuntimeFunctionLibrary_SectionContains::Section' has a wrong offset!");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_SectionContains, Frame) == 0x000008, "Member 'KuroSequenceRuntimeFunctionLibrary_SectionContains::Frame' has a wrong offset!");
static_assert(offsetof(KuroSequenceRuntimeFunctionLibrary_SectionContains, ReturnValue) == 0x000010, "Member 'KuroSequenceRuntimeFunctionLibrary_SectionContains::ReturnValue' has a wrong offset!");

// Function KuroGameplay.KuroStaticMeshLibrary.MergeSimpleCollisions
// 0x0018 (0x0018 - 0x0000)
struct KuroStaticMeshLibrary_MergeSimpleCollisions final
{
public:
	class UStaticMeshComponent*                   TemplateComponent;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     LocalTransforms;                                   // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticMeshLibrary_MergeSimpleCollisions) == 0x000008, "Wrong alignment on KuroStaticMeshLibrary_MergeSimpleCollisions");
static_assert(sizeof(KuroStaticMeshLibrary_MergeSimpleCollisions) == 0x000018, "Wrong size on KuroStaticMeshLibrary_MergeSimpleCollisions");
static_assert(offsetof(KuroStaticMeshLibrary_MergeSimpleCollisions, TemplateComponent) == 0x000000, "Member 'KuroStaticMeshLibrary_MergeSimpleCollisions::TemplateComponent' has a wrong offset!");
static_assert(offsetof(KuroStaticMeshLibrary_MergeSimpleCollisions, LocalTransforms) == 0x000008, "Member 'KuroStaticMeshLibrary_MergeSimpleCollisions::LocalTransforms' has a wrong offset!");

// Function KuroGameplay.PerformanceStatisticsLibrary.AddStatistics
// 0x0038 (0x0038 - 0x0000)
struct PerformanceStatisticsLibrary_AddStatistics final
{
public:
	class FName                                   SectionName;                                       // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FrameCount;                                        // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Tag;                                               // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MeasureMode;                                       // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UserDefineMessage;                                 // 0x0028(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PerformanceStatisticsLibrary_AddStatistics) == 0x000008, "Wrong alignment on PerformanceStatisticsLibrary_AddStatistics");
static_assert(sizeof(PerformanceStatisticsLibrary_AddStatistics) == 0x000038, "Wrong size on PerformanceStatisticsLibrary_AddStatistics");
static_assert(offsetof(PerformanceStatisticsLibrary_AddStatistics, SectionName) == 0x000000, "Member 'PerformanceStatisticsLibrary_AddStatistics::SectionName' has a wrong offset!");
static_assert(offsetof(PerformanceStatisticsLibrary_AddStatistics, FrameCount) == 0x00000C, "Member 'PerformanceStatisticsLibrary_AddStatistics::FrameCount' has a wrong offset!");
static_assert(offsetof(PerformanceStatisticsLibrary_AddStatistics, Tag) == 0x000010, "Member 'PerformanceStatisticsLibrary_AddStatistics::Tag' has a wrong offset!");
static_assert(offsetof(PerformanceStatisticsLibrary_AddStatistics, MeasureMode) == 0x000020, "Member 'PerformanceStatisticsLibrary_AddStatistics::MeasureMode' has a wrong offset!");
static_assert(offsetof(PerformanceStatisticsLibrary_AddStatistics, Time) == 0x000024, "Member 'PerformanceStatisticsLibrary_AddStatistics::Time' has a wrong offset!");
static_assert(offsetof(PerformanceStatisticsLibrary_AddStatistics, UserDefineMessage) == 0x000028, "Member 'PerformanceStatisticsLibrary_AddStatistics::UserDefineMessage' has a wrong offset!");

// Function KuroGameplay.PerformanceStatisticsLibrary.ReadSectionFromFile
// 0x0010 (0x0010 - 0x0000)
struct PerformanceStatisticsLibrary_ReadSectionFromFile final
{
public:
	class FString                                 FilePath;                                          // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PerformanceStatisticsLibrary_ReadSectionFromFile) == 0x000008, "Wrong alignment on PerformanceStatisticsLibrary_ReadSectionFromFile");
static_assert(sizeof(PerformanceStatisticsLibrary_ReadSectionFromFile) == 0x000010, "Wrong size on PerformanceStatisticsLibrary_ReadSectionFromFile");
static_assert(offsetof(PerformanceStatisticsLibrary_ReadSectionFromFile, FilePath) == 0x000000, "Member 'PerformanceStatisticsLibrary_ReadSectionFromFile::FilePath' has a wrong offset!");

}

